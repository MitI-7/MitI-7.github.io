<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>最小カット on Eating Your Own Cat Food</title><link>https://miti-7.github.io/tags/%E6%9C%80%E5%B0%8F%E3%82%AB%E3%83%83%E3%83%88/</link><description>Recent content in 最小カット on Eating Your Own Cat Food</description><generator>Hugo -- gohugo.io</generator><language>ja</language><lastBuildDate>Tue, 23 Dec 2025 00:00:00 +0900</lastBuildDate><atom:link href="https://miti-7.github.io/tags/%E6%9C%80%E5%B0%8F%E3%82%AB%E3%83%83%E3%83%88/index.xml" rel="self" type="application/rss+xml"/><item><title>Gomory-Hu 木</title><link>https://miti-7.github.io/post/gomory-hu-tree/</link><pubDate>Tue, 23 Dec 2025 00:00:00 +0900</pubDate><guid>https://miti-7.github.io/post/gomory-hu-tree/</guid><description>&lt;img src="https://miti-7.github.io/post/gomory-hu-tree/images/t4.png" alt="Featured image of post Gomory-Hu 木" /&gt;&lt;h2 id="はじめに"&gt;はじめに
&lt;/h2&gt;&lt;p&gt;この記事は&lt;a class="link" href="https://qiita.com/advent-calendar/2025/mathematical-optimization" target="_blank" rel="noopener"
&gt;数理最適化 Advent Calendar 2025&lt;/a&gt; の 23 日目の記事です．&lt;br&gt;
この記事では Gomory-Hu 木を紹介します．Gomory-Hu 木とは無向グラフのすべての頂点対の最小カットの情報を持つ木のことです．&lt;br&gt;
まず，無向グラフの s - t カットを紹介し，カット関数が対称劣モジュラ関数であることを示します．次に，Gomory-Hu 木の定義といくつかの補題を示します．最後に Gomory-Hu 木を構築するアルゴリズムの説明とその証明を行います．&lt;br&gt;
実装は今回紹介するアルゴリズムより Gusfield によって提案されたアルゴリズムの方が簡単です．こちらについては別の記事で扱います．&lt;/p&gt;
&lt;h2 id="無向グラフの-s---t-カット"&gt;無向グラフの s - t カット
&lt;/h2&gt;&lt;p&gt;頂点集合 $V$ と無向辺 $E$ からなる無向グラフ $G(V, E)$ が与えられます．辺 $(u, v)$ には容量 $c_{uv} \ge 0$ が定まっているものとします．&lt;br&gt;
任意の頂点集合 $S \subseteq V$ に対し，辺の一方の端点のみが $S$ に属する辺集合を $\delta(S)$ とします．&lt;br&gt;
このときカット関数を以下のように定義し，この値をカットの容量と呼びます．&lt;/p&gt;
$$c(S) = \sum_{(u, v) \in \delta(S)} c_{uv}$$&lt;p&gt;ただし，$\emptyset \subsetneq S \subsetneq V$ を満たす頂点集合 $S$ をカットと呼ぶことにします．
今回は無向グラフを扱っているため $c(S) = c(V \setminus S)$ が成り立ちます．&lt;br&gt;
また，2 つの異なる頂点 $s$ と $t$ について $|S \cap \{s, t\}| = 1$ となるカット $S$ を s - t カットと呼びます．&lt;br&gt;
すべての s - t カットのうち，カットの容量が最小のものを最小 s - t カットと呼び，その容量を $\lambda_{s, t}$ で表します．&lt;/p&gt;
&lt;p&gt;下のグラフを例に，$s$ に $1$，$t$ に $6$ を選んだときの s - t カットをいくつか見ていきます．&lt;/p&gt;
&lt;img src="images/s-t-cut_sample1.png" width="35%"&gt;
&lt;hr&gt;
&lt;p&gt;$S = \{1, 2, 3 \}$ は s - t カットのうちの 1 つです．
$S$ に属する頂点を赤，$V \setminus S$ に属する頂点を青で示します．&lt;br&gt;
辺の一方の端点のみが $S$ に属する辺は $(2, 4)$ と $(3, 5)$ です．よって，このカットの容量は $4 + 6 = 10$ となります．&lt;/p&gt;
&lt;img src="images/s-t-cut_sample2.png" width="35%"&gt;
&lt;hr&gt;
&lt;p&gt;$S = \{1, 3, 4 \}$ も s - t カットです．&lt;br&gt;
このカットの容量は $2 + 2 + 6 + 4 + 7 + 9 = 30$ となります．&lt;/p&gt;
&lt;img src="images/s-t-cut_sample3.png" width="35%"&gt;
&lt;hr&gt;
&lt;p&gt;$S = \{1 \}$ も s - t カットです．&lt;br&gt;
このカットの容量は $2 + 5 = 7$ となります．&lt;br&gt;
$s$ に $1$，$t$ に $6$ を選んだときこれより容量の小さい s - t カットは存在しないためこのカットは最小 s - t カットです．&lt;/p&gt;
&lt;img src="images/s-t-cut_sample4.png" width="35%"&gt;
&lt;h2 id="カット関数の劣モジュラ性"&gt;カット関数の劣モジュラ性
&lt;/h2&gt;&lt;p&gt;関数 $f: 2^V \rightarrow \mathbb R$ は，任意の $A, B \subseteq V$ で以下の不等式が成立するとき劣モジュラであると呼ばれます．
&lt;/p&gt;
$$f(A) + f(B) \ge f(A \cap B) + f(A \cup B)$$&lt;p&gt;また，関数 $f$ は任意の $S \subseteq V$ について $f(S) = f(V \setminus S)$ が成り立つとき対称であると呼ばれます．&lt;br&gt;
対称で劣モジュラな関数は対称劣モジュラ関数と呼ばれます．&lt;/p&gt;
&lt;p&gt;無向グラフのカット関数 $c(S)$ が対称劣モジュラ関数であることを示します．&lt;br&gt;
頂点集合 $V$ を $V_1 = A \setminus B, V_2 = B \setminus A, V_3 = A \cap B, V_4 = V \setminus (A \cup B)$ の $4$ つに分割します．&lt;/p&gt;
&lt;img src="images/submodular.png" width="35%"&gt;
&lt;p&gt;辺の $2$ つの端点がそれぞれ $V_a$，$V_b$ に属する辺集合の容量の和を $\mathrm{cap}(a, b)$ とします．今回は無向辺を扱っているため $\mathrm{cap}(a, b) = \mathrm{cap}(b, a)$ となります．&lt;br&gt;
このとき，以下の式が成り立ちます．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$c(A) = \mathrm{cap}(3, 4) + \mathrm{cap}(3, 2) + \mathrm{cap}(1, 4) + \mathrm{cap}(1, 2)$&lt;/li&gt;
&lt;li&gt;$c(B) = \mathrm{cap}(3, 4) + \mathrm{cap}(3, 1) + \mathrm{cap}(2, 4) + \mathrm{cap}(2, 1)$&lt;/li&gt;
&lt;li&gt;$c(A \cup B) = \mathrm{cap}(3, 4) + \mathrm{cap}(1, 4) + \mathrm{cap}(2, 4)$&lt;/li&gt;
&lt;li&gt;$c(A \cap B) = \mathrm{cap}(3, 1) + \mathrm{cap}(3, 2) + \mathrm{cap}(3, 4)$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;これらを整理すると&lt;/p&gt;
$$c(A) + c(B) - c(A \cup B) - c(A \cap B) = \mathrm{cap}(1, 2) + \mathrm{cap}(2, 1) = 2\mathrm{cap}(1, 2) \ge 0$$&lt;p&gt;となり，関数 $c(S)$ は劣モジュラ関数であることがわかります．&lt;br&gt;
また，関数 $c(S)$ は $c(S) = c(V \setminus S)$ が成り立つため対称です．&lt;br&gt;
以上により，無向グラフのカット関数が対称劣モジュラ関数であることが示せました．&lt;/p&gt;
&lt;h2 id="gomory-hu-木"&gt;Gomory-Hu 木
&lt;/h2&gt;&lt;p&gt;木から辺 $(u, v)$ を取り除いたときにできるどちらか一方の連結成分を $C_{uv}$ とします．&lt;br&gt;
Gomory-Hu 木は以下のように定義されます．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;無向グラフ $G(V, E)$ の Gomory-Hu 木 $T(V, F)$ は，木のすべての辺 $(u, v) \in F$ について，$C_{uv}$ が $G$ の最小 u - v カットとなるような木である．つまり，$c(C_{uv}) = \lambda_{u, v}$ となる&lt;sup id="fnref:1"&gt;&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref"&gt;1&lt;/a&gt;&lt;/sup&gt;．&lt;/li&gt;
&lt;li&gt;各辺 $(u, v) \in F$ の重みを $w(u, v)$ とすると，$w(u, v) = \lambda_{u, v}$ が成り立つ．&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Gomory-Hu 木の定義では，木の辺となるような頂点対のみが $G$ の最小カットとなることを要求しています．&lt;br&gt;
あとで示しますが，この定義は任意の頂点対に拡張することができ，結果として Gomory-Hu 木は次の性質を持つといえます．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$V$ 上の全域木 $T(V, F)$ である（ただし，$F \subseteq E$ とは限らない）．&lt;/li&gt;
&lt;li&gt;任意の異なる $2$ 点 $s, t \in V$ について，$T$ 上の最小 s - t カットは $G$ 上の最小 s - t カットとなり，その容量は一致する．&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下の図を例に Gomory-Hu 木の性質を確認します．&lt;/p&gt;
&lt;img src="images/gomory-hu_sample1.png" width="70%"&gt;
&lt;ul&gt;
&lt;li&gt;グラフの頂点 $1$ と頂点 $6$ の最小カットは $\{1\}$ でその容量は $7$ です．一方，木の頂点 $1$ と頂点 $6$ の最小カットは $\{1\}$ でその容量は $7$ です．&lt;/li&gt;
&lt;li&gt;グラフの頂点 $3$ と頂点 $5$ の最小カットは $\{1, 3\}$ でその容量は $10$ です．一方，木の頂点 $3$ と頂点 $5$ の最小カットは $\{1, 3\}$ でその容量は $10$ です．&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;このように，任意の異なる 2 点 $s$，$t$ について，木の最小 s - t カットはグラフの最小 s - t カットになり，その容量は一致します．&lt;br&gt;
木の最小 s - t カットは，頂点 $s$ から頂点 $t$ へのパスのうち最も重みの小さい辺 $e$ を削除したときの一方の連結成分となり，カットの容量は辺 $e$ の重みとなるため簡単に求めることができます．&lt;/p&gt;
&lt;p&gt;Gomory-Hu 木は $n - 1$ 回の最小 s -t カット計算で求めることができます．&lt;br&gt;
Gomory-Hu のアルゴリズムを紹介する前に，準備としていくつかの補題を導入し，Gomory-Hu 木の性質が定義から導けることを示します．&lt;/p&gt;
&lt;h3 id="補題-1"&gt;補題 1
&lt;/h3&gt;&lt;p&gt;長さ $k \ge 2$ の互いに異なる頂点列 $v_1, v_2, v_3, \cdots, v_k$ について，$\lambda_{v_1, v_k} \ge \min \limits_{1 \le i \le k - 1} \lambda_{v_i, v_{i + 1}}$ が成り立つ&lt;/p&gt;
&lt;p&gt;補題 1 を示します．&lt;br&gt;
$U$ を最小 $v_1$ - $v_k$ カットとし，$v_1 \in U$，$v_k \notin U$ とします．&lt;br&gt;
このとき，頂点列のどこかに $v_i \in U$，$v_{i + 1} \notin U$ であるような $i$ が存在します．&lt;/p&gt;
&lt;p&gt;直観的には，次のように考えると分かりやすいです．&lt;br&gt;
$U$ に属する頂点を $\circ$，属さない頂点を $\times$，不明な頂点を $?$ とします．&lt;br&gt;
このとき，頂点列の所属は $(\circ, ?, ?, \cdots, ?, \times)$ と表せますが，$?$ がどのように決められようとどこかに $\circ, \times$ というペアが現れます．これは，$v_i \in U$，$v_{i + 1} \notin U$ であるような $i$ が存在しているということです．&lt;/p&gt;
&lt;p&gt;よって，$U$ は $v_i$ - $v_{i+1}$ カットでもあります．ただし，$U$ は最小 $v_i$ - $v_{i+1}$ カットとは限らないため，$\lambda_{v_i, v_{i + 1}} \le c(U) = \lambda_{v_1, v_k}$ となります．&lt;br&gt;
以上により，$\lambda_{v_1, v_k} \ge \min_{1 \le i \le k - 1} \lambda_{v_i, v_{i + 1}}$ が示せました．&lt;/p&gt;
&lt;h3 id="補題-2"&gt;補題 2
&lt;/h3&gt;&lt;p&gt;$s, t \in V$ を異なる 2 点とし，最小 s - t カットを $A$ とする．任意の異なる 2 点 $u, v \notin A$ について，$A \subseteq B$ か $A \cap B = \emptyset$ となるような最小 u - v カット $B$ が存在する．&lt;/p&gt;
&lt;img src="images/lemma2.png" width="45%"&gt;
&lt;p&gt;この補題は，すでに存在する最小 s - t カット $A$ と交差しないように最小 u - v カット $B$ をとることができることを意味します．図は $A \subseteq B$ の場合を表しています．&lt;/p&gt;
&lt;p&gt;補題 2 を示します．&lt;br&gt;
最小 s - t カットを $A$，最小 u - v カットを $B$ とします．$A \subseteq B$ か $A \cap B = \emptyset$ の場合は補題が成立しているので，$A \nsubseteq B$ かつ $A \cap B \ne \emptyset$ を仮定します．
$s \in A$，$s, u \in B$ であるとします&lt;sup id="fnref:2"&gt;&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref"&gt;2&lt;/a&gt;&lt;/sup&gt;．&lt;br&gt;
このとき，$A \cup B$ が最小 u - v カットとなることを示します．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;$A \cup B$ は u - v カット&lt;br&gt;
$u \in B$ であるため $u \in A \cup B$ であり，$v \notin A$ かつ $v \notin B$ であるため $v \notin A \cup B$ です．&lt;br&gt;
よってこのカットは u - v カットです．&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$c(A \cup B) = c(B)$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$c(A \cup B) \le c(B)$&lt;br&gt;
仮定より，$s \in A \cap B$，$t \notin A \cap B$ であるため，$A \cap B$ は s - t カットです．&lt;br&gt;
$A$ は最小 s - t カットで $A \cap B$ も s - t カットであるため，$c(A \cap B) \ge c(A)$ となります．&lt;br&gt;
この不等式をカットの劣モジュラ性である $c(A) + c(B) \ge c(A \cap B) + c(A \cup B)$ に代入することで，$c(A \cup B) \le c(B)$ を得ます．&lt;/li&gt;
&lt;li&gt;$c(A \cup B) \ge c(B)$&lt;br&gt;
$B$ は最小 u - v カットで $A \cup B$ も u - v カットであるため，$c(A \cup B) \ge c(B)$ を得ます．&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上により，$A \cup B$ は最小 u - v カットといえます．$A \cup B$ を新しく $B$ ととることで，$A \subseteq B$ であるような最小 u - v カット $B$ とすることができます．&lt;/p&gt;
&lt;h3 id="gomory-hu-木の性質"&gt;Gomory-Hu 木の性質
&lt;/h3&gt;&lt;p&gt;Gomory-Hu 木の定義から Gomory-Hu 木の性質が導かれることを示します．&lt;/p&gt;
&lt;p&gt;$T$ の s - t パス上の最小重みの辺を $(a, b) \in F$ とします．このとき，$C_{ab}$ は s - t カットとなり，最小 s - t カットの容量 $\lambda_{s, t}$ が $w(a, b)$ と一致することを示します．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;$\lambda_{s, t} \ge w(a, b)$&lt;br&gt;
s - t パスの頂点列を考えます．&lt;br&gt;
$v_1 = s$，$v_k = t$ とすると，補題 1 より $\lambda_{s, t} \ge \min \limits_{1 \le i \le k - 1} \lambda_{v_i, v_{i + 1}}$ が成り立ちます．&lt;br&gt;
Gomory-Hu 木の定義より $\min \limits_{1 \le i \le k - 1} \lambda_{v_i, v_{i + 1}} = \lambda_{a, b} = w(a, b)$ なので，$\lambda_{s, t} \ge w(a, b)$ が成り立ちます．&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$\lambda_{s, t} \le w(a, b)$&lt;br&gt;
$\lambda_{s, t}$ は定義より最小 s - t カットの値です．&lt;br&gt;
辺 $(a, b) \in F$ は $s$ から $t$ への唯一のパス上に存在するため，$C_{ab}$ は s - t カットでもあります．このカットの容量は Gomory-Hu 木の定義から $w(a, b)$ です．よって，$\lambda_{s, t} \le c(C_{ab}) = w(a, b)$ が成り立ちます．&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上により，$C_{ab}$ が s - t カットであり，$\lambda_{s, t} = w(a, b)$ となることが示せました．&lt;/p&gt;
&lt;h2 id="gomory-hu-のアルゴリズム"&gt;Gomory-Hu のアルゴリズム
&lt;/h2&gt;&lt;p&gt;Gomory-Hu 木 $T$ を構築するアルゴリズムを説明します．&lt;br&gt;
Gomory-Hu 木は，木の各辺がある頂点対の最小カットを表し，その結果として任意の $2$ 頂点間の最小カットが木上で読み取れるという形になっていました．&lt;br&gt;
そこで直感的には，最初に $G$ のすべての頂点を $1$ つの縮約頂点として持ち，辺がある頂点対の最小カットとなるように縮約頂点を分割していくことで木を構築すればよさそうです．&lt;br&gt;
ただし，適当に分割してしまうと以前の分割と交差してしまいすでに作った構造を壊してしまうことがあります．&lt;br&gt;
Gomory-Hu のアルゴリズムはこの問題に対処するために，すでにできている縮約頂点をそれぞれ $1$ 頂点に縮約したグラフの上で最小カットを計算し，その結果を使って縮約頂点を分割します．&lt;br&gt;
こうすると新しい分割は以前の分割を壊さない形で実行することができるため，分割を積み重ねながら木を安全に構築できます．&lt;br&gt;
具体的なアルゴリズムは以下の通りです．&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;初期化&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$V(T) = \{V(G)\}$&lt;/li&gt;
&lt;li&gt;$E(T) = \emptyset$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;要素数が $2$ 以上の $X \in V(T)$ がある間以下を行う．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$X$ の中から異なる $2$ 頂点 $s, t \in X$ を選ぶ．&lt;/li&gt;
&lt;li&gt;縮約グラフ $H$ を構築する．
&lt;ul&gt;
&lt;li&gt;$T$ から $X$ を削除したときの連結成分を $C_1, C_2, \cdots, C_k$ とし，$C_i$ のすべての要素の和集合を $S_i$ とする．&lt;/li&gt;
&lt;li&gt;$G$ 上で各 $S_i$ を $1$ つの頂点に縮約したグラフを $H$ とする．縮約で生じる並行辺は維持し，同一成分内の辺を除去する．&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;$H$ 上で最小 s - t カット $S$ を求め，$A = X \cap S$，$B = X \setminus S$ とする．&lt;/li&gt;
&lt;li&gt;$X$ を $A$ と $B$ に分割する．
&lt;ul&gt;
&lt;li&gt;$V(T) = (V(T) - \{ X\}) \cup \{A, B\}$ と更新する．&lt;/li&gt;
&lt;li&gt;新しい辺 $AB$ を $T$ に追加し，その重みを先程求めた最小 s - t カットの値とする．&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;既存の辺を置き換える．
&lt;ul&gt;
&lt;li&gt;$X$ に接続する辺 $XY \in E(T)$について以下を行う．
&lt;ul&gt;
&lt;li&gt;$XY$ を $E(T)$ から削除する．&lt;/li&gt;
&lt;li&gt;$Y$ が属する側の縮約頂点 $v_{S_i}$ について，$v_{S_i} \in S$ なら $AY$ を，そうでないなら $BY$ を追加する．追加する辺の重みは $XY$ と同じとする．&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;単一集合となったすべての頂点 $\{v\}$ について以下を行う．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;頂点 $\{v\}$ を $v$ に，辺 $(\{u\}, \{v\})$ を $(u, v)$ に置き換える．&lt;/li&gt;
&lt;li&gt;Gomory-Hu 木 $(V(T), E(T))$ を返す．&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="アルゴリズムの実行例"&gt;アルゴリズムの実行例
&lt;/h2&gt;&lt;p&gt;下のグラフの Gomory-Hu 木を求めます．&lt;br&gt;
&lt;img src="images/s-t-cut_sample1.png" width="50%"&gt;&lt;/p&gt;
&lt;h3 id="phase-1"&gt;Phase 1
&lt;/h3&gt;&lt;p&gt;はじめ，$V(T) = \{ \{1, 2, 3, 4, 5, 6\} \}$ です．&lt;br&gt;
$X$ として $\{1, 2, 3, 4, 5, 6\}$ を選び，縮約グラフ $H$ を構築します．&lt;br&gt;
今回は $X$ に接続する辺はないので，$H = G$ となります．&lt;br&gt;
下の左の図が $T$ で，右の図が $H$ です．&lt;/p&gt;
&lt;img src="images/t1.png" width="30%"&gt;
&lt;img src="images/h1.png" width="30%"&gt;
&lt;ul&gt;
&lt;li&gt;最小 s - t カットの計算&lt;br&gt;
$s$ と $t$ は任意に選べます．今回は $s = 3$，$t = 5$ として，$H$ での最小 s - t カットを求めると，$S = \{1, 3\}$ となり，その容量は $10$ です．&lt;/li&gt;
&lt;li&gt;$X$ の分割&lt;br&gt;
$X$ を $A = X \cap S = \{1, 3\}$ と $B = X \setminus S = \{2, 4, 5, 6\}$ に分割し，重み $10$ の辺を張ります&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;これらの操作により，$T$ は以下のようになります．&lt;/p&gt;
&lt;img src="images/t2-1.png" width="30%"&gt;
&lt;hr&gt;
&lt;h3 id="phase-2"&gt;Phase 2
&lt;/h3&gt;&lt;p&gt;$X$ として $\{2, 4, 5, 6\}$ を選び，縮約グラフ $H$ を構築します．&lt;br&gt;
$G$ について，$T$ から $X$ を削除したときの連結成分 $C_1$ の展開 $S_1$ を $1$ つの頂点 $v_{S_1}$ として縮約します．&lt;/p&gt;
&lt;img src="images/t2.png" width="30%"&gt;
&lt;img src="images/h2.png" width="30%"&gt;
&lt;ul&gt;
&lt;li&gt;最小 s - t カットの計算&lt;br&gt;
$s = 5, t = 4$ とすると，$H$ での最小 s - t カットは $S = \{\{1, 3\}, 2, 5\}$ となり，その容量は $14$ です．&lt;/li&gt;
&lt;li&gt;$X$ の分割&lt;br&gt;
$X$ を $A = \{2, 5\}$ と $B = \{4, 6\}$ に分割し，重み $14$ の辺を張ります．&lt;/li&gt;
&lt;li&gt;既存の辺の付け替え&lt;br&gt;
$X$ の分割後，更新前の $T$ の辺 $(\{1, 3\}, X)$ がどうなるか考えます．$v_{S_1} \in S$ であるため，この辺は $A$ と接続します．&lt;br&gt;
よって辺 $(\{1, 3\}, X)$ は辺 $(\{1, 3\}, A)$ に付け替えられます．&lt;/li&gt;
&lt;/ul&gt;
&lt;img src="images/t3-1.png" width="30%"&gt;
&lt;hr&gt;
&lt;h3 id="phase-3"&gt;Phase 3
&lt;/h3&gt;&lt;p&gt;$X$ として $\{1, 3\}$ を選び，縮約グラフ $H$ を構築します．&lt;br&gt;
$S_1$ を $1$ つの頂点 $v_{S_1}$ として縮約します．&lt;/p&gt;
&lt;img src="images/t3.png" width="30%"&gt;
&lt;img src="images/h3.png" width="30%"&gt;
&lt;ul&gt;
&lt;li&gt;最小 s - t カットの計算&lt;br&gt;
$s = 1, t = 3$ とすると，グラフ $H$ での最小 s - t カットは $S = \{1\}$ となり，その容量は $7$ です．&lt;/li&gt;
&lt;li&gt;$X$ の分割&lt;br&gt;
$X$ を $A = \{1\}$ と $B = \{3\}$ に分割し，重み $7$ の辺を張ります．&lt;/li&gt;
&lt;li&gt;既存の辺の付け替え&lt;br&gt;
$X$ の分割後，更新前の $T$ の辺 $(X, \{2, 5\})$ がどうなるか考えます．$v_{S_1} \notin S$ であるため，この辺は $B$ と接続します．&lt;br&gt;
よって辺 $(X, \{2, 5\})$ は辺 $(B, \{2, 5\})$ に付け替えられます．&lt;/li&gt;
&lt;/ul&gt;
&lt;img src="images/t4-1.png" width="30%"&gt;
&lt;hr&gt;
&lt;h3 id="phase-4"&gt;Phase 4
&lt;/h3&gt;&lt;p&gt;$X$ として $\{2, 5\}$ を選び，縮約グラフ $H$ を構築します．&lt;br&gt;
$S_1$ と $S_2$ をそれぞれ $1$ つの頂点 $v_{S_1}, v_{S_2}$ として縮約します．&lt;/p&gt;
&lt;img src="images/t4.png" width="30%"&gt;
&lt;img src="images/h4.png" width="30%"&gt;
&lt;ul&gt;
&lt;li&gt;最小 s - t カットの計算&lt;br&gt;
$s = 2, t = 5$ とすると，グラフ $H$ での最小 s - t カット $S$ は $\{2\}$ となり，その容量は $8$ です．&lt;/li&gt;
&lt;li&gt;$X$ の分割&lt;br&gt;
$X$ を $A = \{2\}$ と $B = \{5\}$ に分割し，重み $8$ の辺を張ります．&lt;/li&gt;
&lt;li&gt;既存の辺の付け替え&lt;br&gt;
$X$ の分割後，更新前の $T$ の辺 $(\{3\}, X)$ がどうなるか考えます．&lt;br&gt;
$v_{S_1} \notin S$ であるため，この辺は $B$ と接続します．
また，更新前の $T$ の辺 $(X, \{4, 6\})$ は $v_{S_2} \notin S$ であるため，この辺も $B$ と接続します．&lt;br&gt;
よって辺 $(\{3\}, X)$ は辺 $(\{3\}, B)$ に，辺 $(X, \{4, 6\})$ は $(B, \{4, 6\})$ に付け替えられます．&lt;/li&gt;
&lt;/ul&gt;
&lt;img src="images/t5-1.png" width="30%"&gt;
&lt;hr&gt;
&lt;h3 id="phase-5"&gt;Phase 5
&lt;/h3&gt;&lt;p&gt;$X$ として $\{4, 6\}$ を選び，縮約グラフ $H$ を構築します．&lt;br&gt;
$S_1$ を $1$ つの頂点 $v_{S_1}$ として縮約します．&lt;/p&gt;
&lt;img src="images/t5.png" width="30%"&gt;
&lt;img src="images/h5.png" width="30%"&gt;
&lt;ul&gt;
&lt;li&gt;最小 s - t カットの計算&lt;br&gt;
$s = 4, t = 6$ とすると，グラフ $H$ での最小 s - t カット $S$ は $\{4, \{1, 2, 3, 5\}\}$ となり，その容量は $12$ です．&lt;/li&gt;
&lt;li&gt;$X$ の分割&lt;br&gt;
$X$ を $A = \{4\}$ と $B = \{6\}$ に分割し，重み $12$ の辺を張ります．&lt;/li&gt;
&lt;li&gt;既存の辺の付け替え&lt;br&gt;
$X$ の分割後，更新前の $T$ の辺 $(5, X)$ がどうなるか考えます．$v_{S_1} \in S$ であるため，この辺は $A$ と接続します．&lt;br&gt;
よって辺 $(5, X)$ は辺 $(5, A)$ に付け替えられます．&lt;/li&gt;
&lt;/ul&gt;
&lt;img src="images/t6-1.png" width="30%"&gt;
&lt;hr&gt;
&lt;h3 id="phase-6"&gt;Phase 6
&lt;/h3&gt;&lt;p&gt;$T$ のすべての頂点の要素数が $1$ なので Step 2 を終了します．&lt;br&gt;
Step 3 は省略します．&lt;/p&gt;
&lt;img src="images/t6.png" width="30%"&gt;
&lt;h2 id="証明"&gt;証明
&lt;/h2&gt;&lt;p&gt;アルゴリズムが Gomory-Hu 木を構築する証明をします．&lt;br&gt;
表記を整理しておきます．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$\lambda_{s,t;G}$：グラフ $G$ の最小 s - t カットの容量&lt;/li&gt;
&lt;li&gt;$\lambda_{s,t;H}$：縮約グラフ $H$ の最小 s - t カットの容量&lt;/li&gt;
&lt;li&gt;$w(YZ)$：木 $T$ の辺 $YZ$ の重み&lt;/li&gt;
&lt;li&gt;$C^{\prime}_{YZ}$：木 $T$ から辺 $YZ$ を削除したときにできる 2 つの連結成分のうち，$Y$ に属する連結成分をすべて展開したもの&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;アルゴリズムの開始時と各イテレーション終了時に，次の不変条件が成り立つことを示します．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;木 $T$ の任意の辺 $YZ$ に対してある頂点 $s \in Y, t \in Z$ が存在し，$C^{\prime}_{YZ}$ は元のグラフ $G$ における最小 s - t カットであり，$\lambda_{s, t;G} = w(YZ)$ となる&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;まず，アルゴリズムの開始時には辺がないので不変条件は成り立ちます．&lt;br&gt;
このあとで，各イテレーション時に以下の $3$ つの辺について不変条件が成り立つことを示します．&lt;/p&gt;
&lt;ol type="a"&gt;
&lt;li&gt;新しく追加される辺 $AB$&lt;/li&gt;
&lt;li&gt;既存の辺 $XY$ から付け替えられた辺&lt;/li&gt;
&lt;li&gt;その他の辺&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;アルゴリズムの終了時には縮約頂点はすべて展開され，木 $T$ は Gomory-Hu 木の定義を満たしているため，アルゴリズムは Gomory-Hu 木を構築するといえます．&lt;/p&gt;
&lt;h3 id="a-新しく追加される辺"&gt;a. 新しく追加される辺 $AB$
&lt;/h3&gt;&lt;p&gt;アルゴリズムは縮約グラフ $H$ 上で $s, t \in X$ について最小 s - t カット $S$ を求め，$A = X \cap S$，$B = X \setminus S$ と分割します．その上で，辺 $AB$ の重み $w(AB)$ を $\lambda_{s,t;H}$ とします．&lt;/p&gt;
&lt;p&gt;辺 $AB$ が不変条件を満たすことを示すため，以下を確認します．&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$H$ 上の最小 s - t カットを展開した頂点集合は $G$ 上の最小 s - t カットとなりその容量は一致する．つまり，$\lambda_{s, t;G} = w(AB) = \lambda_{s,t;H}$ となる&lt;/li&gt;
&lt;li&gt;$H$ 上の最小 s - t カットを展開した頂点集合は $C^{\prime}_{AB}$ となる&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id="1--上の最小-s---t-カットを展開した頂点集合は--上の最小-s---t-カットとなりその容量は一致する"&gt;1. $H$ 上の最小 s - t カットを展開した頂点集合は $G$ 上の最小 s - t カットとなりその容量は一致する
&lt;/h4&gt;&lt;p&gt;アルゴリズムのあるイテレーションで，$S_1, \cdots, S_k$ を順番に縮約していくことを考えます．$S_i$ までを縮約したグラフを $H_i$ とします．$H_0$ はグラフ $G$ に，$H_k$ はアルゴリズムで述べられている縮約グラフ $H$ に一致します．&lt;/p&gt;
&lt;p&gt;不変条件より，木の各辺 $YZ$ に対してある頂点対 $(s_{YZ}, t_{YZ})$ が存在し，$C^{\prime}_{YZ}$ は $G$ 上の最小 $s_{YZ}$ - $t_{YZ}$ カットになっています．頂点 $X \in T$ を削除したときの連結成分 $C_i$ と $X$ を結ぶ辺を $Y_i X$ とおくと，$S_i = C^{\prime}_{Y_i X}$ が成り立ちます．&lt;br&gt;
よって，各 $S_i$ はある頂点対 $(s_i, t_i)$ に対する最小 $s_i$ - $t_i$ カットです．&lt;br&gt;
また，$S_i$ は $T \setminus X$ の連結成分から構成されているので，$s, t \notin S_i$ です．&lt;/p&gt;
&lt;p&gt;各ステップ $i$ について，$H_i$ には $G$ における最小 s - t カットの容量である $\lambda_{s, t;G}$ と同じ容量の s - t カットが存在することを帰納法で示します．&lt;br&gt;
$i = 0$ のとき，$H_0 = G$ なので自明です．&lt;br&gt;
帰納法の仮定より，$H_i$ には容量 $\lambda_{s, t;G}$ の s - t カット $C$ があります．このとき，$S_{i + 1}$ を縮約して得られる $H_{i + 1}$ にも容量 $\lambda_{s, t;G}$ の s - t カットが存在することを示します．&lt;br&gt;
補題 2 により $H_i$ の s - t カット $C$ は $S_{i + 1}$ を交差しないようにとりなおすことができます．よって，$S_{i + 1}$ を縮約して $H_{i + 1}$ を構築しても，容量 $\lambda_{s, t;G}$ の s - t カットが存在するといえます．&lt;br&gt;
よって，$H$ には容量 $\lambda_{s, t;G}$ の s - t カットが存在することが示せました．&lt;/p&gt;
&lt;p&gt;任意の $H$ 上の s - t カットは，縮約を展開すれば $G$ 上の s - t カットになります．縮約は辺の容量を変えないので，カットの容量も維持されます．&lt;br&gt;
したがって，任意の $H$ 上の s - t カットの容量 = 対応する $G$ 上の s - t カットの容量 $\ge \lambda_{s, t;G}$ となり，$H$ の最小 s - t カットの容量は $\lambda_{s, t;G}$ となります．&lt;/p&gt;
&lt;h4 id="2--上の最小-s---t-カットを展開した頂点集合は--となる"&gt;2. $H$ 上の最小 s - t カットを展開した頂点集合は $C^{\prime}_{AB}$ となる
&lt;/h4&gt;&lt;p&gt;$H$ の最小 s - t カット $S$ を展開して得られる頂点集合は，アルゴリズムにおける辺の付け替え規則から，更新後の木 $T^{\prime}$ で辺 $AB$ を削除したときの $A$ 側成分 $C^{\prime}_{AB}$ と一致します．&lt;br&gt;
これは，$X$ 内の頂点のうち $S$ に属するものは $A$ に，また各連結成分 $C_i$ に対応する縮約頂点 $v_{S_i}$ が $S$ に属する場合に限り，その成分は $A$ 側に接続されるように付け替えられているためです．&lt;/p&gt;
&lt;p&gt;以上のことから辺 $AB$ が不変条件を満たすことがわかりました．&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id="b-既存の辺--から付け替えられた辺"&gt;b. 既存の辺 $XY$ から付け替えられた辺
&lt;/h3&gt;&lt;p&gt;アルゴリズムは，縮約グラフ $H$ 上で $s, t \in X$ について最小 s - t カット $S$ をみつけ，$X$ を $A = X \cap S$ と $B = X \setminus S$ に分割します．もともと $X$ と $Y$ の間に張られていた辺 $XY$ は $A$ に付け替えられて $AY$ になるか，$B$ に付け替えられて $BY$ になります．&lt;br&gt;
以降は $A$ に付け替えられた場合を考えますが $B$ でも同じことがいえます．&lt;/p&gt;
&lt;p&gt;$p \in X$，$q \in Y$ であり，XY の重みは $\lambda_{pq}$ であったとします．&lt;br&gt;
&lt;img src="images/replace0.png" width="30%"&gt;&lt;/p&gt;
&lt;p&gt;$X$ の最小 s - t カットを求め，$A$ と $B$ に分割されたとき，$s \in A$，$t \in B$ であるとします．&lt;br&gt;
$A$ と $B$ は $X$ を分割したものであるため，$C^{\prime}_{AY} = C^{\prime}_{XY}$ とみなすことができます．&lt;br&gt;
辺 $AY$ の重みが $\lambda_{p,q}$ であることを $p \in A$ の場合と $p \notin A$ の場合について示します．&lt;/p&gt;
&lt;p&gt;$p \in A$ の場合&lt;br&gt;
&lt;img src="images/replace1.png" width="30%"&gt;&lt;/p&gt;
&lt;p&gt;辺 $AY$ の重みは $\lambda_{pq}$ なので，不変条件を満たします．&lt;/p&gt;
&lt;p&gt;$p \notin A$ の場合&lt;br&gt;
&lt;img src="images/replace2.png" width="30%"&gt;&lt;/p&gt;
&lt;p&gt;$\lambda_{s, q} = \lambda_{p, q}$ であることを示します．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;$\lambda_{s, q} \ge \lambda_{p, q}$&lt;br&gt;
頂点列 $s, t, p, q$ を考えると補題 1 より $\lambda_{s, q} \ge \min \{\lambda_{s, t}, \lambda_{t, p}, \lambda_{p, q} \}$ が言えます．&lt;br&gt;
最小 s - t カット $S$ は $s, q \in S$，$t, p \in B \subseteq V \setminus S$ です．&lt;/p&gt;
&lt;p&gt;無向グラフでは $\delta(S) = \delta(V \setminus S)$ なので $V \setminus S$ も最小 s - t カットです．&lt;br&gt;
そこで，補題 2 を $A = V \setminus S$，$(u, v) = (s, q)$ に適用します（このとき $s, q \notin A$ が成り立ちます）．&lt;br&gt;
すると，ある最小 s - q カット $C^{\prime}$ が存在して&lt;/p&gt;
$$(V \setminus S) \subseteq C^{\prime} \text{または} (V \setminus S) \cap C^{\prime} = \emptyset$$&lt;p&gt;が成り立ちます．&lt;br&gt;
前者なら無向グラフなので $V \setminus C^{\prime}$ も最小 s - q カットであり，こちらは $(V \setminus S) \cap (V \setminus C^{\prime}) = \emptyset$ となるので，$C = V \setminus C^{\prime} \subseteq S$ とできます．&lt;br&gt;
後者ならそのまま $C = C^{\prime}$ とおけば $C \subseteq S$ です．&lt;br&gt;
よって，ある最小 s - q カット C は，$C \subseteq S$ であるようにとることができます．&lt;br&gt;
つまり，最小 s - q カットは $t, p \in B$ となるようにとれるので，$\lambda_{s, q}$ は 辺 $(t, p)$ の容量に依存しないことがわかります．&lt;br&gt;
よって，大きな容量をもつ辺 $(t, p)$ を追加したとしても不等式が成り立ち，$\lambda_{s, q} \ge \min \{\lambda_{s, t}, \lambda_{p, q} \}$ が成立します．&lt;br&gt;
また，最小 s - t カットは p-q カットでもあるため，$\lambda_{s, t} \ge \lambda_{p, q}$ が成り立ちます．&lt;br&gt;
よって，$\lambda_{s, q} \ge \lambda_{p, q}$ が示せました．&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$\lambda_{s, q} \le \lambda_{p, q}$&lt;br&gt;
$C^{\prime}_{XY}$ は $X$ と $Y$ を分けるカットであり，$p \in X$ と $q \in Y$ を分離していて，重みは $\lambda_{p, q}$ でした．&lt;br&gt;
$s \in A \subset X$ なので，$C^{\prime}_{XY}$ は s - q カットでもあります．&lt;br&gt;
よって，$\lambda_{s, q} \le \lambda_{p, q}$ が示せました．&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="c-その他の辺"&gt;c. その他の辺
&lt;/h3&gt;&lt;p&gt;アルゴリズムで選んだ $X$ に接続していない辺 $YZ$ は，木 $T$ 上での位置も対応するカット $C^{\prime}_{YZ}$ も変化しないため，不変条件を満たします．&lt;/p&gt;
&lt;h2 id="参考"&gt;参考
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="link" href="https://doi.org/10.1137%2F0109047" target="_blank" rel="noopener"
&gt;Multi-Terminal Network Flows&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="link" href="https://webdocs.cs.ualberta.ca/~zacharyf/courses/combopt_2016/notes/lec5.pdf" target="_blank" rel="noopener"
&gt;Lecture 5 (Sept. 16): Undirected Cuts and Gomory-Hu Trees&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="link" href="https://webdocs.cs.ualberta.ca/~zacharyf/courses/combopt_2016/notes/lec6.pdf" target="_blank" rel="noopener"
&gt;Lecture 6 (Sept. 19): Gomory-Hu Trees&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="link" href="https://www.contrib.andrew.cmu.edu/~ravi/book.pdf" target="_blank" rel="noopener"
&gt;Iterative Methods in Combinatorial Optimization&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="footnotes" role="doc-endnotes"&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;カット関数は $G$ に対して定義されています&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink"&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:2"&gt;
&lt;p&gt;必要に応じて，$B$ を $V \setminus B$ に置き換える操作と名前の付け替えを行います&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink"&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description></item><item><title>Quadratic Pseudo-Boolean Optimization</title><link>https://miti-7.github.io/post/quadratic-pseudo-boolean-optimization/</link><pubDate>Thu, 09 Jan 2025 00:00:00 +0900</pubDate><guid>https://miti-7.github.io/post/quadratic-pseudo-boolean-optimization/</guid><description>&lt;img src="https://miti-7.github.io/post/quadratic-pseudo-boolean-optimization/images/general_sample_ab_1.png" alt="Featured image of post Quadratic Pseudo-Boolean Optimization" /&gt;&lt;h2 id="quadratic-pseudo-boolean-optimization"&gt;Quadratic Pseudo-Boolean Optimization
&lt;/h2&gt;&lt;p&gt;次の関数 $E(\bold x)$ を最小化する問題を考えます．$x_{p} \in \lbrace 0, 1 \rbrace$ とし，$\theta_{const}$ は定数を表します．この問題を &lt;a class="link" href="https://en.wikipedia.org/wiki/Quadratic_pseudo-Boolean_optimization" target="_blank" rel="noopener"
&gt;Quadratic Pseudo-Boolean Optimization&lt;/a&gt;(以下 QPBO)と呼びます．&lt;/p&gt;
$$
\begin{equation}
E(\bold x) = \theta_{const} + \sum_p \theta_{p}(x_p) + \sum_{p \lt q} \theta_{pq}(x_p, x_q)
\end{equation}
$$&lt;p&gt;競プロ界隈で「燃やす埋める」や「Project Selection Problem」などと言われる問題は QPBO に帰着することができます&lt;sup id="fnref:1"&gt;&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref"&gt;1&lt;/a&gt;&lt;/sup&gt;．&lt;br&gt;
これらの問題は minimum s-t cut に帰着して解くことができますが，どのように辺を張るかなど混乱しがちです．本記事の目的は QPBO を解くアルゴリズムをライブラリ化することで，問題を解くときに辺の張り方や変数のフリップ操作などを考えなくてすむようにすることです．実装は &lt;a class="link" href="https://github.com/MitI-7/CompetitiveProgrammingLibrary/blob/1c8b83e0e54a6729cce7cf2c7eee09d1de0e4c05/library/cpp/optimization/QPBO.hpp" target="_blank" rel="noopener"
&gt;QPBO.hpp&lt;/a&gt; にあります．&lt;/p&gt;
&lt;p&gt;記事の構成は以下の通りです．&lt;br&gt;
&lt;a class="link" href="#1-s-t-cut" &gt;節 1&lt;/a&gt; では s-t cut と minimum s-t cut の説明をします．minimum s-t cut は多項式時間で求めることができます．&lt;/p&gt;
&lt;p&gt;&lt;a class="link" href="#2-%e5%8d%98%e7%b4%94%e3%81%aa%e9%96%a2%e6%95%b0%e3%81%ae%e5%a0%b4%e5%90%88" &gt;節 2&lt;/a&gt; では関数 $E(\bold x)$ が $\theta_{pq}(0, 0) = \theta_{pq}(1, 1) = 0$ であり，どの関数も $0$ 以上の値を返すという単純な関数の場合について考えます．
この場合は minimum s-t cut を見つける問題にそのまま帰着できます．&lt;/p&gt;
&lt;p&gt;&lt;a class="link" href="#3-%e5%8a%a3%e3%83%a2%e3%82%b8%e3%83%a5%e3%83%a9%e9%96%a2%e6%95%b0%e3%81%ae%e5%a0%b4%e5%90%88" &gt;節 3&lt;/a&gt; では節 2 の仮定を排除し，関数 $E(\bold x)$ が劣モジュラ関数であるという仮定のみをおいた場合について考えます．&lt;br&gt;
この場合は再パラメータ化という操作を行うことで単純な関数の場合に帰着させることができます．&lt;/p&gt;
&lt;p&gt;&lt;a class="link" href="#4-%e4%b8%80%e8%88%ac%e3%81%ae%e9%96%a2%e6%95%b0%e3%81%ae%e5%a0%b4%e5%90%88" &gt;節 4&lt;/a&gt; では関数 $E(\bold x)$ が一般の関数の場合について考えます．&lt;br&gt;
$E(\bold x)$ が一般の関数の場合，これを最小化する問題は NP-hard であり，多項式時間で解くことは(今のところ)できそうもありません．この場合は問題を緩和することで劣モジュラ関数の場合に帰着させ近似解を得ることができます．さらに，ここで得られた解は最適解の一部となることが保証されます．&lt;/p&gt;
&lt;p&gt;&lt;a class="link" href="#5-%e5%95%8f%e9%a1%8c" &gt;節 5&lt;/a&gt; では競プロの問題をいくつか解いていきます．&lt;/p&gt;
&lt;h2 id="1-s-t-cut"&gt;1. s-t cut
&lt;/h2&gt;&lt;p&gt;頂点集合 $V$ と 有向辺 $E$ からなる有向グラフ $G = (V, E)$ が与えられます．辺 $(i, j)$ には容量 $c_{ij} \ge 0$ が定まっているものとします．&lt;br&gt;
頂点集合 $V$ を 2 つの部分集合 $S$ と $T = V \backslash S$ に分割します．2 つのノード $s$ と $t$ について $s \in S$，$t \in T$ となるような分割を s-t cut と呼びます．&lt;br&gt;
$S$ から出て $T$ に入るような辺の容量の総和を s-t cut の容量と呼び，以下で定義されます．すべての s-t cut のうち最小のものを minimum s-t cut と呼びます．&lt;/p&gt;
$$
\begin{aligned}
c(S) = \sum_{(i, j) \in (S, T)} c_{ij}
\end{aligned}
$$&lt;p&gt;下のグラフの s-t cut の例をいくつか見ていきます &lt;sup id="fnref:2"&gt;&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref"&gt;2&lt;/a&gt;&lt;/sup&gt;．&lt;/p&gt;
&lt;img src="images/s-t-cut_sample1.png" width="50%"&gt;
&lt;p&gt;頂点の部分集合として，$S = \lbrace s, 0, 1 \rbrace$ を選んだとします．&lt;br&gt;
$S$ に属する頂点を赤，$T = V \backslash S$ に属する頂点を青で示します． $S$ から出て $T$ に入るような辺は辺 (0, 2) と辺 (1, 3) です．よって，この s-t cut の容量は 3 + 2 = 5 となります．&lt;br&gt;
すべての s-t cut の中でこのカットより容量の小さい s-t cut は存在しないのでこれは minimum s-t cut です．&lt;/p&gt;
&lt;img src="images/s-t-cut_sample2.png" width="50%"&gt;
&lt;p&gt;頂点の部分集合として $S = \lbrace s, 0, 1, 2, 3 \rbrace$ を選んだとします．&lt;br&gt;
この s-t cut の容量は 2 + 3 = 5 となります．&lt;br&gt;
このカットも minimum s-t cut です．このように minimum s-t cut は複数存在することがあります．&lt;/p&gt;
&lt;img src="images/s-t-cut_sample3.png" width="50%"&gt;
&lt;p&gt;頂点の部分集合として $S = \lbrace s, 1, 2 \rbrace$ を選んだとします．&lt;br&gt;
この s-t cut の容量は，3 + 2 + 4 + 2 = 11 となります．&lt;br&gt;
辺 (0, 1) や辺 (0, 2) は $T$ から $S$ に入る辺なので含まれません．&lt;/p&gt;
&lt;img src="images/s-t-cut_sample4.png" width="50%"&gt;
&lt;p&gt;minimum s-t cut は最大流問題を解き，残余ネットワーク上で頂点 $s$ から到達できる頂点集合を $S$ とすることで求められます．詳しくは &lt;a class="link" href="https://ja.wikipedia.org/wiki/%E6%9C%80%E5%A4%A7%E3%83%95%E3%83%AD%E3%83%BC%E6%9C%80%E5%B0%8F%E3%82%AB%E3%83%83%E3%83%88%E5%AE%9A%E7%90%86" target="_blank" rel="noopener"
&gt;最大フロー最小カット定理&lt;/a&gt; などを参照してください．&lt;br&gt;
次節から s-t cut を使って $E(\bold x)$ を最小化する方法を見ていきます．&lt;/p&gt;
&lt;h2 id="2-単純な関数の場合"&gt;2. 単純な関数の場合
&lt;/h2&gt;&lt;p&gt;関数 $E(\bold x)$ を最小化する方法を考えていきます．$x_{p} \in \lbrace 0, 1 \rbrace$ なので，変数の個数が $n$ 個のとき解は $2^n$ 個存在します．この $2^n$ 個の解のなかから最小のものを見つけるのが目標です．&lt;/p&gt;
$$
\begin{equation}
E(\bold x) = \theta_{const} + \sum_{p} \theta_{p}(x_p) + \sum_{p \lt q} \theta_{pq}(x_p, x_q) \tag {1}
\end{equation}
$$&lt;p&gt;単純な関数の場合を考えたいので，$\theta_{pq}(0, 0) = \theta_{pq}(1, 1) = 0$ であり，すべて 0 以上の値を返すと仮定します．&lt;br&gt;
この仮定を満たす関数の場合は $E(\bold x)$ の解と s-t cut の解が 1 対 1 対応するようなグラフを作成することができます．よって，グラフの最小 s-t cut がわかれば $E(\bold x)$ の最小値（= 最適解）を求めることができます．&lt;/p&gt;
&lt;p&gt;グラフは各変数を頂点とし，これに特別な頂点 $s$ と $t$ を加えた $n + 2$ 個の頂点から構成されます．辺は下記のルールにしたがって張ります．&lt;/p&gt;
&lt;div style="display: flex; gap: 20px;"&gt;
&lt;div&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;関数&lt;/th&gt;
&lt;th&gt;辺&lt;/th&gt;
&lt;th&gt;容量&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;$\theta_{p}(0)$&lt;/td&gt;
&lt;td&gt;$p \rightarrow t$&lt;/td&gt;
&lt;td&gt;$\theta_{p}(0)$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$\theta_{p}(1)$&lt;/td&gt;
&lt;td&gt;$s \rightarrow p$&lt;/td&gt;
&lt;td&gt;$\theta_{p}(1)$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$\theta_{pq}(0, 1)$&lt;/td&gt;
&lt;td&gt;$p \rightarrow q$&lt;/td&gt;
&lt;td&gt;$\theta_{pq}(0, 1)$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$\theta_{pq}(1, 0)$&lt;/td&gt;
&lt;td&gt;$q \rightarrow p$&lt;/td&gt;
&lt;td&gt;$\theta_{pq}(1, 0)$&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;具体例として，変数が $a$ と $b$ の 2 つだけの場合を見てみます．&lt;br&gt;
各変数の値に対応する $E(\bold x) = \theta_a(a) + \theta_b(b) + \theta_{ab}(a, b)$ の値は以下のようになります．$\theta_{ab}(0, 0)$ と $\theta_{ab}(1, 1)$ の値は $0$ であり，$\theta_{const}$ は定数のため省略しています．&lt;/p&gt;
&lt;div style="display: flex; gap: 20px;"&gt;
&lt;div&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;b&lt;/th&gt;
&lt;th&gt;$E(\bold x)$&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;$\theta_{a}(0) + \theta_{b}(0)$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;$\theta_{a}(0) + \theta_{b}(1) + \theta_{ab}(0, 1)$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;$\theta_{a}(1) + \theta_{b}(0) + \theta_{ab}(1, 0)$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;$\theta_{a}(1) + \theta_{b}(1)$&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;ルールに従うと下のグラフが構築されます．&lt;br&gt;
このグラフの s-t cut をいくつか見ていきます．&lt;/p&gt;
&lt;img src="images/simple_sample.png" width="25%"&gt;
&lt;p&gt;$S = \lbrace s, a, b \rbrace$ とします．この s-t cut の容量は $\theta_{a}(0) + \theta_{b}(0)$ です．&lt;br&gt;
また，$a = 0$，$b = 0$ としたとき $E(\bold x)$ の値は $\theta_{a}(0) + \theta_{b}(0)$ です．&lt;br&gt;
よって，$S = \lbrace s, a, b \rbrace$ としたときの s-t cut の容量と，$a = 0$，$b = 0$ としたときの $E(\bold x)$ の関数値は一致しています．&lt;/p&gt;
&lt;img src="images/simple_cut1.png" width="25%"&gt;
&lt;p&gt;別の s-t cut の例をみます．&lt;br&gt;
$S = \lbrace s, a \rbrace$ とします．この s-t cut の容量は $\theta_{a}(0) + \theta_{b}(1) + \theta_{ab}(0, 1)$ です．&lt;br&gt;
また，$a = 0$，$b = 1$ としたとき $E(\bold x)$ の値は $\theta_{a}(0) + \theta_{b}(1) + \theta_{ab}(0, 1)$ です．&lt;br&gt;
よって，$S = \lbrace s, a \rbrace$ としたときの s-t cut の容量と，$a = 0$，$b = 1$ としたときの $E(\bold x)$ の関数値は一致しています．&lt;/p&gt;
&lt;img src="images/simple_cut2.png" width="25%"&gt;
&lt;p&gt;変数が 2 つの場合は s-t cut は $2^2$ 通りあります．すべてのパターンは以下の通りです．&lt;/p&gt;
&lt;img src="images/simple_cut_all.png" width="50%"&gt;
&lt;p&gt;このように s-t cut の構成と $E(\bold x) $ の構成が 1 対 1 対応するため，minimum s-t cut を計算することで $E(\bold x)$ の最小値を求めることができます．&lt;br&gt;
minimum s-t cut を計算し，$S$ に属する頂点に対応する変数の値を $0$，$T$ に属する頂点に対応する変数の値を $1$ と設定することで最適な $\bold x$ を構成できます．&lt;/p&gt;
&lt;h2 id="3-劣モジュラ関数の場合"&gt;3. 劣モジュラ関数の場合
&lt;/h2&gt;&lt;p&gt;「&lt;a class="link" href="#2-%e5%8d%98%e7%b4%94%e3%81%aa%e9%96%a2%e6%95%b0%e3%81%ae%e5%a0%b4%e5%90%88" &gt;2. 単純な関数の場合&lt;/a&gt;」では，$\theta_{pq}(0, 0) = \theta_{pq}(1, 1) = 0$ とし，どの関数も $0$ 以上の値を返すことを仮定していました．&lt;br&gt;
この節ではこの仮定を排除し，関数は劣モジュラであることのみを仮定します．今回は 2 値変数を考えているので，$\theta_{pq}(0, 1) + \theta_{pq}(1, 0) \ge \theta_{pq}(0, 0) + \theta_{pq}(1, 1)$ を満たすことになります．&lt;/p&gt;
&lt;p&gt;$\theta_{pq}(0, 0)$ や $\theta_{pq}(1, 1)$ が $0$ 以外の値をとったり関数値が負の値をとる場合があるので，今回はルール通りにグラフを作ることはできません．そこで再パラメータ化という操作を行います．再パラメータ化とは，$E(\bold x)$ の関数値を保ちつつ $\theta_{pq}(1, 0)$ などの各関数値を変化させる操作です．&lt;br&gt;
再パラメータ化を行うと標準形とよばれる以下の条件を満たす形になります&lt;sup id="fnref:3"&gt;&lt;a href="#fn:3" class="footnote-ref" role="doc-noteref"&gt;3&lt;/a&gt;&lt;/sup&gt;．標準形ではどの関数も $0$ 以上の値をとります．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$min \lbrace \theta_{p}(0), \theta_{p}(1) \rbrace = 0$&lt;/li&gt;
&lt;li&gt;$min \lbrace \theta_{pq}(0, 0), \theta_{pq}(1, 0) \rbrace = 0$&lt;/li&gt;
&lt;li&gt;$min \lbrace \theta_{pq}(0, 1), \theta_{pq}(1, 1) \rbrace = 0$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;再パラメータ化をすると，関数 $\theta_{pq}(x_{p}, x_{q})$ が劣モジュラの場合は $\theta_{pq}(0, 0) = \theta_{pq}(1, 1) = 0$ に，関数 $\theta_{pq}(x_{p}, x_{q})$ が優モジュラの場合は $\theta_{pq}(0, 1) = \theta_{pq}(1, 0) = 0$ になります&lt;sup id="fnref:4"&gt;&lt;a href="#fn:4" class="footnote-ref" role="doc-noteref"&gt;4&lt;/a&gt;&lt;/sup&gt;．&lt;br&gt;
よって，すべての $\theta_{pq}(x_{p}, x_{q})$ が劣モジュラ関数の場合は，再パラメータ化をすることで「&lt;a class="link" href="#2-%e5%8d%98%e7%b4%94%e3%81%aa%e9%96%a2%e6%95%b0%e3%81%ae%e5%a0%b4%e5%90%88" &gt;2. 単純な関数の場合&lt;/a&gt;」に帰着することができます．&lt;br&gt;
再パラメータ化の手続きは以下の通りです．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;step1
&lt;ul&gt;
&lt;li&gt;すべての (p, q) の各 $j \in \lbrace 0, 1 \rbrace$ について
&lt;ul&gt;
&lt;li&gt;$\delta = min \lbrace \theta_{pq}(0, j), P_{pq}(1, j) \rbrace$&lt;/li&gt;
&lt;li&gt;$\theta_{pq}(0, j) = \theta_{pq}(0, j) - \delta$&lt;/li&gt;
&lt;li&gt;$\theta_{pq}(1, j) = \theta_{pq}(1, j) - \delta$&lt;/li&gt;
&lt;li&gt;$\theta_{q}(j) = \theta_{q}(j) + \delta$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;step2
&lt;ul&gt;
&lt;li&gt;$\delta = min \lbrace \theta_p(0), \theta_p(1) \rbrace$&lt;/li&gt;
&lt;li&gt;$\theta_{p}(0) = \theta_{p}(0) - \delta$&lt;/li&gt;
&lt;li&gt;$\theta_{p}(1) = \theta_{p}(1) - \delta$&lt;/li&gt;
&lt;li&gt;$\theta_{const} = \theta_{const} + \delta$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;再パラメータ化をしたとき，目的関数値が変化しないことを確認します．&lt;br&gt;
step 1 の $j = 0$ では，$\theta_{pq}(0, 0)$ と $\theta_{pq}(1, 0)$ から $\delta$ を引き，$\theta_{q}(0)$ に $\delta$ を加えます．&lt;br&gt;
この操作を行うと $E(\bold x)$ は以下の表のように変化します．$\delta$ が打ち消し合って，目的関数値が保たれていることが確認できます．&lt;br&gt;
また，$\delta$ として $min \lbrace \theta_{pq}(0, 0), P_{pq}(1, 0) \rbrace$ を選んでいるので，$min \lbrace \theta_{pq;00}, \theta_{pq;10} \rbrace = 0$ を満たすようになります．&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;p&lt;/th&gt;
&lt;th&gt;q&lt;/th&gt;
&lt;th&gt;$E(\bold x)$&lt;/th&gt;
&lt;th&gt;$E^{\prime}(\bold x)$&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;$\theta_{const} + \theta_{p}(0) + \theta_{q}(0) + \theta_{ab}(0, 0)$&lt;/td&gt;
&lt;td&gt;$\theta_{const} + \theta_{p}(0) + (\theta_{q}(0) + \delta) + (\theta_{ab}(0, 0) - \delta)$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;$\theta_{const} + \theta_{p}(0) + \theta_{q}(1) + \theta_{ab}(0, 1)$&lt;/td&gt;
&lt;td&gt;$\theta_{const} + \theta_{p}(0) + \theta_{q}(1) + \theta_{ab}(0, 1)$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;$\theta_{const} + \theta_{p}(1) + \theta_{q}(0) + \theta_{ab}(1, 0)$&lt;/td&gt;
&lt;td&gt;$\theta_{const} + \theta_{p}(1) + (\theta_{q}(0) + \delta) + (\theta_{ab}(1, 0) - \delta)$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;$\theta_{const} + \theta_{p}(1) + \theta_{q}(1) + \theta_{ab}(1, 1)$&lt;/td&gt;
&lt;td&gt;$\theta_{const} + \theta_{p}(1) + \theta_{q}(1) + \theta_{ab}(1, 1)$&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;step 1 の $j = 1$ では，$\theta_{pq}(0, 1)$ と $\theta_{pq}(1, 1)$ から $\delta$ を引き，$\theta_{q}(1)$ に $\delta$ を加えます．&lt;br&gt;
$\delta$ として $min \lbrace \theta_{pq}(0, 1), P_{pq}(1, 1) \rbrace$ を選んでいるので，$min \lbrace \theta_{pq;01}, \theta_{pq;11} \rbrace = 0$ を満たすようになります．&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;p&lt;/th&gt;
&lt;th&gt;q&lt;/th&gt;
&lt;th&gt;$E(\bold x)$&lt;/th&gt;
&lt;th&gt;$E^{\prime}(\bold x)$&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;$\theta_{const} + \theta_{p}(0) + \theta_{q}(0) + \theta_{ab}(0, 0)$&lt;/td&gt;
&lt;td&gt;$\theta_{const} + \theta_{p}(0) + \theta_{q}(0) + \theta_{ab}(0, 0)$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;$\theta_{const} + \theta_{p}(0) + \theta_{q}(1) + \theta_{ab}(0, 1)$&lt;/td&gt;
&lt;td&gt;$\theta_{const} + \theta_{p}(0) + (\theta_{q}(1) + \delta) + (\theta_{ab}(0, 1) - \delta)$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;$\theta_{const} + \theta_{p}(1) + \theta_{q}(0) + \theta_{ab}(1, 0)$&lt;/td&gt;
&lt;td&gt;$\theta_{const} + \theta_{p}(1) + \theta_{q}(0) + \theta_{ab}(1, 0)$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;$\theta_{const} + \theta_{p}(1) + \theta_{q}(1) + \theta_{ab}(1, 1)$&lt;/td&gt;
&lt;td&gt;$\theta_{const} + \theta_{p}(1) + (\theta_{q}(1) + \delta) + (\theta_{ab}(1, 1) - \delta)$&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;step 2 では，$\theta_{p}(0)$ と $\theta_{p}(1)$ から $\delta$ を引き，$\theta_{const}$ に $\delta$ を加えます．&lt;br&gt;
$\delta$ として $min \lbrace \theta_p(0), \theta_p(1) \rbrace$ を選んでいるので，$min \lbrace \theta_{p;0}, \theta_{p;1} \rbrace = 0$ を満たすようになります．&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;p&lt;/th&gt;
&lt;th&gt;q&lt;/th&gt;
&lt;th&gt;$E(\bold x)$&lt;/th&gt;
&lt;th&gt;$E^{\prime}(\bold x)$&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;$\theta_{const} + \theta_{p}(0) + \theta_{q}(0) + \theta_{ab}(0, 0)$&lt;/td&gt;
&lt;td&gt;$(\theta_{const} + \delta) + (\theta_{p}(0) - \delta) + \theta_{q}(0) + \theta_{ab}(0, 0)$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;$\theta_{const} + \theta_{p}(0) + \theta_{q}(1) + \theta_{ab}(0, 1)$&lt;/td&gt;
&lt;td&gt;$(\theta_{const} + \delta) + (\theta_{p}(0) - \delta) + \theta_{q}(1) + \theta_{ab}(0, 1)$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;$\theta_{const} + \theta_{p}(1) + \theta_{q}(0) + \theta_{ab}(1, 0)$&lt;/td&gt;
&lt;td&gt;$(\theta_{const} + \delta) + (\theta_{p}(1) - \delta) + \theta_{q}(0) + \theta_{ab}(1, 0)$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;$\theta_{const} + \theta_{p}(1) + \theta_{q}(1) + \theta_{ab}(1, 1)$&lt;/td&gt;
&lt;td&gt;$(\theta_{const} + \delta) + (\theta_{p}(1) - \delta) + \theta_{q}(1) + \theta_{ab}(1, 1)$&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id="4-一般の関数の場合"&gt;4. 一般の関数の場合
&lt;/h1&gt;&lt;p&gt;関数に何も仮定を置かない場合は $E(\bold x)$ の最小化は NP-hard なので，minimum s-t cut 問題に帰着できない場合があります．&lt;br&gt;
この場合でも最適解はだせなくても問題を解けるだけ解く QPBO 法というアルゴリズムがあります&lt;sup id="fnref:5"&gt;&lt;a href="#fn:5" class="footnote-ref" role="doc-noteref"&gt;5&lt;/a&gt;&lt;/sup&gt;．QPBO 法は解として $x_p = \lbrace 0, 1, \emptyset \rbrace$ のいずれかを与えます．$\emptyset$ は解が不明であることを表します．$x_p$ に $0$ か $1$ の値が与えられたとき，$x_p$ はラベル付けされたといいます．&lt;br&gt;
このアルゴリズムは次のような性質があります．&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;アルゴリズムの出力を $\bold x$ とする．完全にラベル付けされた任意の解 $\bold y$ があるとき，以下のように $\bold z$ を定めると常に $E(\bold z) \le E(\bold y)$ を満たす．&lt;/li&gt;
&lt;/ol&gt;
$$
z_p = \left\{
\begin{array}{ll}
x_p &amp; \text{if} \space x_p \in \lbrace 0, 1 \rbrace \\
y_p &amp; \text{if} \space x_p = \emptyset
\end{array}
\right.
$$&lt;ol start="2"&gt;
&lt;li&gt;関数のすべての項が劣モジュラのとき最適解が求まる．&lt;/li&gt;
&lt;li&gt;アルゴリズムはフリップ操作に対して不変である．&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;性質 1 で $\bold y$ に最適解を選べば $\bold x$ は常に最適解の一部となることがわかります．&lt;br&gt;
競プロで役に立つのは性質 2 と 3 です．この 2 つの性質から，すべての項を劣モジュラにするようなフリップ操作がある場合に QPBO 法は最適解を求めることがわかります．&lt;/p&gt;
&lt;p&gt;QPBO 法を説明します．&lt;br&gt;
以降は表記が煩雑になるのを避けるためこの節では関数値を以下のように表記することがあります．&lt;/p&gt;
&lt;div style="display: flex; gap: 20px;"&gt;
&lt;div&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;$\theta_{p}(0)$&lt;/td&gt;
&lt;td&gt;$\theta_{p;0}$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$\theta_{p}(1)$&lt;/td&gt;
&lt;td&gt;$\theta_{p;1}$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$\theta_{pq}(0,0)$&lt;/td&gt;
&lt;td&gt;$\theta_{pq;00}$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$\theta_{pq}(0,1)$&lt;/td&gt;
&lt;td&gt;$\theta_{pq;01}$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$\theta_{pq}(1,0)$&lt;/td&gt;
&lt;td&gt;$\theta_{pq;10}$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$\theta_{pq}(1,1)$&lt;/td&gt;
&lt;td&gt;$\theta_{pq;11}$&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;各変数 $x_p$ に対して，$x_{\bar{p}} = 1 - x_{p}$ を導入し，$E(\bold x) = \sum \theta_{p}(x_p) + \sum \theta_{pq}(x_p, x_q)$ を変形します．&lt;/p&gt;
$$
\begin{alignedat}{2}
E(\bold x)
&amp;= \theta_{const} + \sum \theta_{p}(x_p)
&amp;&amp;+ \sum \theta_{pq}(x_p, x_q) \\
&amp;= \theta_{const} + \sum \big(
\theta_{p;1} x_{p} + \theta_{p;0}(1 - x_{p})
\big) \\
&amp;\quad &amp;&amp;+
\sum \big(
\theta_{pq;00} (1 - x_{p})(1 - x_{q}) \\
&amp;\quad &amp;&amp;\quad +
\theta_{pq;01} (1 - x_{p}) x_{q} \\
&amp;\quad &amp;&amp;\quad +
\theta_{pq;10} x_{p}(1 - x_{q}) \\
&amp;\quad &amp;&amp;\quad +
\theta_{pq;11} x_{p} x_{q}
\big) \\
&amp;= \theta_{const} + \sum \bigg(
\frac{\theta_{p;1}}{2}(x_p + (1 - x_{\bar{p}})) &amp;&amp;
+ \frac{\theta_{p;0}}{2}(x_{\bar{p}} + (1 - x_p))
\bigg) \\
&amp;\quad &amp;&amp;+
\sum \bigg(
\frac{\theta_{pq;00}}{2} \big(x_{\bar{p}} (1 - x_q) + (1 - x_p) x_{\bar{q}} \big) \\
&amp;\quad &amp;&amp;\quad +
\frac{\theta_{pq;01}}{2} \big((1 - x_p) x_q + x_{\bar{p}} (1 - x_{\bar{q}}) \big) \\
&amp;\quad &amp;&amp;\quad +
\frac{\theta_{pq;11}}{2} \big(x_p (1 - x_{\bar{q}}) + (1 - x_{\bar{p}}) x_q \big) \\
&amp;\quad &amp;&amp;\quad +
\frac{\theta_{pq;10}}{2} \big(x_p (1 - x_q) + (1 - x_{\bar{p}}) x_{\bar{q}} \big)
\bigg)
\end{alignedat}
$$&lt;p&gt;ここで，$x_{\bar{p}} = 1 - x_p$ という制約を緩和し，$x_p$ と $x_{\bar{p}}$ が独立に値をとれる緩和問題を考えます．&lt;br&gt;
各変数の係数を比較すると下の関数に分割できることがわかります．
再パラメータ化をしてから関数を分割することですべての関数値が $0$ 以上であることが保証されます．これらの関数は劣モジュラ関数なので「&lt;a class="link" href="#3-%e5%8a%a3%e3%83%a2%e3%82%b8%e3%83%a5%e3%83%a9%e9%96%a2%e6%95%b0%e3%81%ae%e5%a0%b4%e5%90%88" &gt;3. 劣モジュラ関数の場合&lt;/a&gt;」に帰着することができます．&lt;/p&gt;
&lt;div style="display: flex; gap: 20px;"&gt;
&lt;div&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;$x_p$&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;$\frac{1}{2}\theta_{p;0}$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;$\frac{1}{2}\theta_{p;1}$&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;$x_{\bar{p}}$&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;$\frac{1}{2}\theta_{p;1}$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;$\frac{1}{2}\theta_{p;0}$&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div style="display: flex; gap: 20px;"&gt;
&lt;div&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;$x_p$&lt;/th&gt;
&lt;th&gt;$x_q$&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;$\frac{1}{2}\theta_{pq;01}$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;$\frac{1}{2}\theta_{pq;10}$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;$x_p$&lt;/th&gt;
&lt;th&gt;$x_{\bar{q}}$&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;$\frac{1}{2}\theta_{pq;00}$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;$\frac{1}{2}\theta_{pq;11}$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;$x_{\bar{p}}$&lt;/th&gt;
&lt;th&gt;$x_q$&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;$\frac{1}{2}\theta_{pq;11}$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;$\frac{1}{2}\theta_{pq;00}$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;$x_{\bar{p}}$&lt;/th&gt;
&lt;th&gt;$x_{\bar{q}}$&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;$\frac{1}{2}\theta_{pq;01}$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;$\frac{1}{2}\theta_{pq;10}$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;上記関数について，ルールに従ってグラフを構築します．
整理すると以下のルールに従ってグラフを構築すればいいことがわかります．&lt;/p&gt;
&lt;div style="display: flex; gap: 20px;"&gt;
&lt;div&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;$\theta$&lt;/th&gt;
&lt;th&gt;edge&lt;/th&gt;
&lt;th&gt;capacity&lt;sup id="fnref:6"&gt;&lt;a href="#fn:6" class="footnote-ref" role="doc-noteref"&gt;6&lt;/a&gt;&lt;/sup&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;$\theta_{p;0}$&lt;/td&gt;
&lt;td&gt;$(p \rightarrow t), (s \rightarrow \bar p)$&lt;/td&gt;
&lt;td&gt;$\frac{1}{2} \theta_{p;0}$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$\theta_{p;1}$&lt;/td&gt;
&lt;td&gt;$(s \rightarrow p), (\bar p \rightarrow t)$&lt;/td&gt;
&lt;td&gt;$\frac{1}{2} \theta_{p;1}$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$\theta_{pq;01}$&lt;/td&gt;
&lt;td&gt;$(p \rightarrow q), (\bar q \rightarrow \bar p)$&lt;/td&gt;
&lt;td&gt;$\frac{1}{2} \theta_{pq;01}$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$\theta_{pq;10}$&lt;/td&gt;
&lt;td&gt;$(q \rightarrow p), (\bar p \rightarrow \bar q)$&lt;/td&gt;
&lt;td&gt;$\frac{1}{2} \theta_{pq;10}$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$\theta_{pq;00}$&lt;/td&gt;
&lt;td&gt;$(p \rightarrow \bar q), (q \rightarrow \bar p)$&lt;/td&gt;
&lt;td&gt;$\frac{1}{2} \theta_{pq;00}$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$\theta_{pq;11}$&lt;/td&gt;
&lt;td&gt;$(\bar q \rightarrow p), (\bar p \rightarrow q)$&lt;/td&gt;
&lt;td&gt;$\frac{1}{2} \theta_{pq;11}$&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;このグラフの s-t minimum cut を計算します．各変数の値は，$S$ に属する場合は 0，$T$ に属する場合は 1 をとります．ただし，$x_{\bar{p}} = 1 - x_{p}$ という制約を満たす必要があります．よって，$\bold x$ は次のように構成されます．&lt;/p&gt;
$$
x_{p} = \left\{
\begin{array}{ll}
0 &amp; \text{if} \space p \in S, \bar p \in T \\
1 &amp; \text{if} \space p \in T, \bar p \in S \\
\emptyset &amp; \text{otherwise}
\end{array}
\right.
$$&lt;p&gt;具体例として，変数が $a$ と $b$ の 2 つだけの場合を考えます．&lt;br&gt;
各変数の値に対応する $E(\bold x) = \theta_a(a) + \theta_b(b) + \theta_{ab}(a, b)$ の値は以下のようになります．&lt;/p&gt;
&lt;div style="display: flex; gap: 20px;"&gt;
&lt;div&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;b&lt;/th&gt;
&lt;th&gt;$E(\bold x)$&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;$\theta_{a}(0) + \theta_{b}(0) + \theta_{ab}(0, 0)$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;$\theta_{a}(0) + \theta_{b}(1) + \theta_{ab}(0, 1)$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;$\theta_{a}(1) + \theta_{b}(0) + \theta_{ab}(1, 0)$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;$\theta_{a}(1) + \theta_{b}(1) + \theta_{ab}(1, 1)$&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;対応するグラフは以下のようになります．表記が煩雑になるので図では $\frac{1}{2}$ を除外しています．このグラフの s-t cut の例をいくつか見ていきます．&lt;/p&gt;
&lt;img src="images/general_sample_ab.png" width="50%"&gt;
&lt;p&gt;$S = \lbrace s, a, b \rbrace$ とします．この s-t cut の容量は $\frac{1}{2} (\theta_{a}(0) + \theta_{a}(0) + \theta_{b}(0) + \theta_{b}(0) + \theta_{ab}(0, 0) + \theta_{ab}(0, 0))$ です．&lt;br&gt;
この値は $a = 0$，$b = 0$ としたときの $E(\bold x)$ の目的関数と一致します．&lt;/p&gt;
&lt;img src="images/general_sample_ab_1.png" width="50%"&gt;
&lt;p&gt;$S = \lbrace s, a \rbrace$ とします．この s-t cut の容量は $\frac{1}{2} (\theta_{a}(0) + \theta_{a}(0) + \theta_{b}(1) + \theta_{b}(1) + \theta_{ab}(0, 1) + \theta_{ab}(0, 1))$ です．&lt;br&gt;
この値は $a = 0$，$b = 0$ としたときの $E(\bold x)$ の目的関数と一致します．&lt;/p&gt;
&lt;img src="images/general_sample_ab_2.png" width="50%"&gt;
&lt;p&gt;$S = \lbrace s, a, b, \bar{b} \rbrace$ とします．この場合，$a = 0$，$b = \emptyset$ とし，$b$ のラベルは未定となります．&lt;/p&gt;
&lt;img src="images/general_sample_ab_3.png" width="50%"&gt;
&lt;h1 id="5-問題"&gt;5. 問題
&lt;/h1&gt;&lt;p&gt;QPBO を使って競プロの問題を解いていきます．&lt;/p&gt;
&lt;h2 id="arc085-e---mul"&gt;&lt;a class="link" href="https://atcoder.jp/contests/arc085/tasks/arc085_c" target="_blank" rel="noopener"
&gt;ARC085 E - MUL&lt;/a&gt;
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;宝石が $N$ 個あり，それぞれ $1,2,\cdots,N$ と数が書かれています。&lt;br&gt;
あなたは，以下の操作を好きなだけ行うことが出来ます(一度も行わなくてもよいです)。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;正整数 $x$ を選ぶ。$x$ の倍数が書かれた宝石を全て叩き割る。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;そして，$i$ が書かれていた宝石が割られずに残っていた場合，$a_i$ 円貰います。 ただし，この $a_i$ は負の場合もあり，その場合はお金を払わなくてはいけません。&lt;br&gt;
うまく操作を行った時，あなたは最大で何円お金を貰えるでしょうか？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;まず変数を定義します．&lt;br&gt;
宝石 $i$ が残っているかどうかを $x_i$ で表します．宝石が割る場合 $1$ を，残す場合は $0$ をとります．&lt;/p&gt;
&lt;p&gt;次に関数を定義します．&lt;br&gt;
QPBO は目的関数値の最小化を目指すのでコストがいくらかかるかで表します．&lt;br&gt;
宝石 $i$ が残っている場合 $a_i$ 円貰えます．これは $-a_i$ 円のコストを払うということなので，次のように定義できます．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$\theta_{i}(0) = -a_i$&lt;/li&gt;
&lt;li&gt;$\theta_{i}(1) = 0$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;また，宝石 $i$ を割るにもかかわらず $i$ で割り切れる値が書かれた宝石 $j$ を残すことは許されないので，この場合は無限のコストがかかるとします．よって，次のように定義できます．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$\theta_{ij}(0, 0) = 0$&lt;/li&gt;
&lt;li&gt;$\theta_{ij}(0, 1) = 0$&lt;/li&gt;
&lt;li&gt;$\theta_{ij}(1, 0) = \infty$&lt;/li&gt;
&lt;li&gt;$\theta_{ij}(1, 1) = 0$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;この関数は $\theta_{ij}(0, 1) + \theta_{ij}(1, 0) \ge \theta_{ij}(0, 0) + \theta_{ij}(1, 1)$ を満たしているので劣モジュラ関数です．&lt;br&gt;
あとは，すべての $i$ と $i$ で割り切れる $j$ について上記関数を定義すれば問題を解くことができます．&lt;/p&gt;
&lt;p&gt;&lt;a class="link" href="https://atcoder.jp/contests/arc085/submissions/61474030" target="_blank" rel="noopener"
&gt;提出コード&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="abc193-f---zebraness"&gt;&lt;a class="link" href="https://atcoder.jp/contests/abc193/tasks/abc193_f" target="_blank" rel="noopener"
&gt;ABC193 F - Zebraness&lt;/a&gt;
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;縦 $N$ マス、横 $N$ マスのマス目があります。上から $i$ 行目、左から $j$ 列目のマスをマス $(i,j)$ と表すことにします。 マス $(i,j)$ の色の情報が文字 $c_{i,j}$ により与えられます。&lt;br&gt;
$B$ はマスが黒で塗られていることを、 $W$ はマスが白で塗られていることを、 $?$ はマスにまだ色が塗られていないことを表します。&lt;br&gt;
高橋くんは、まだ色が塗られていないマスをそれぞれ黒または白で塗り、白黒のマス目を作ります。マス目のしまうま度を、辺で接する黒マスと白マスの組の個数と定義します。高橋くんが達成できるしまうま度の最大値を求めてください。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;まず変数を定義します．&lt;br&gt;
マスを $(i, j)$ で表すとすると関数が見にくいので $p = i \times N + j$ で表します．
マス $p$ の色を変数 $x_{p}$ で表します．白の場合 $0$ をとり，黒の場合 $1$ をとります．&lt;/p&gt;
&lt;p&gt;次に関数を定義します．&lt;br&gt;
与えられている色の変更はできないので白から黒や黒から白に変更すると無限のコストがかかるとします．次のように定義できます．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;マス $p$ の色が黒の場合&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$\theta_{p}(0) = \infty$&lt;/li&gt;
&lt;li&gt;$\theta_{p}(1) = 0$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;マス $p$ の色が白の場合&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$\theta_{p}(0) = 0$&lt;/li&gt;
&lt;li&gt;$\theta_{p}(1) = \infty$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;マス $p$ と辺で接するマス $q$ が異なる色だと -1 のコストがかかります．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$\theta_{pq}(0, 0) = 0$&lt;/li&gt;
&lt;li&gt;$\theta_{pq}(0, 1) = -1$&lt;/li&gt;
&lt;li&gt;$\theta_{pq}(1, 0) = -1$&lt;/li&gt;
&lt;li&gt;$\theta_{pq}(1, 1) = 0$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;これは劣モジュラ関数ではないのですが，変数フリップすることで劣モジュラ関数にすることができます．
QPBO 法では変数フリップを考慮しなくていいのでそのまま定義することができます．&lt;/p&gt;
&lt;p&gt;&lt;a class="link" href="https://atcoder.jp/contests/abc193/submissions/61474153" target="_blank" rel="noopener"
&gt;提出コード&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="その他の問題"&gt;その他の問題
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="link" href="https://yukicoder.me/problems/no/2713" target="_blank" rel="noopener"
&gt;No.2713 Just Solitaire&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class="link" href="https://yukicoder.me/submissions/1034571" target="_blank" rel="noopener"
&gt;提出コード&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="link" href="https://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2903" target="_blank" rel="noopener"
&gt;AOJ - Board&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class="link" href="https://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=10082476#1" target="_blank" rel="noopener"
&gt;提出コード&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="link" href="https://onlinejudge.u-aizu.ac.jp/challenges/sources/UOA/UAPC/3058" target="_blank" rel="noopener"
&gt;AOJ - Ghost&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class="link" href="https://onlinejudge.u-aizu.ac.jp/solutions/problem/3058/review/10082488/MitI7/C&amp;#43;&amp;#43;23" target="_blank" rel="noopener"
&gt;提出コード&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="link" href="https://atcoder.jp/contests/typical90/tasks/typical90_an" target="_blank" rel="noopener"
&gt;競プロ典型 90 問 040 - Get More Money（★7）&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class="link" href="https://atcoder.jp/contests/typical90/submissions/61474485" target="_blank" rel="noopener"
&gt;提出コード&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="link" href="https://atcoder.jp/contests/abc259/tasks/abc259_g" target="_blank" rel="noopener"
&gt;ABC259 G - Grid Card Game&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class="link" href="https://atcoder.jp/contests/abc259/submissions/61474556" target="_blank" rel="noopener"
&gt;提出コード&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="参考"&gt;参考
&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="link" href="https://ieeexplore.ieee.org/document/4204169" target="_blank" rel="noopener"
&gt;Minimizing non-submodular functions with graph cuts – a review&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="link" href="https://www.kspub.co.jp/book/detail/1529090.html" target="_blank" rel="noopener"
&gt;劣モジュラ最適化と機械学習&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="link" href="https://en.wikipedia.org/wiki/Graph_cut_optimization" target="_blank" rel="noopener"
&gt;Graph cut optimization&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="link" href="https://en.wikipedia.org/wiki/Quadratic_pseudo-Boolean_optimization" target="_blank" rel="noopener"
&gt;Quadratic pseudo-Boolean optimization&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="footnotes" role="doc-endnotes"&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;たぶんです．できない例があったら教えてください&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink"&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:2"&gt;
&lt;p&gt;この数値例は&lt;a class="link" href="https://ja.wikipedia.org/wiki/%E6%9C%80%E5%A4%A7%E3%83%95%E3%83%AD%E3%83%BC%E6%9C%80%E5%B0%8F%E3%82%AB%E3%83%83%E3%83%88%E5%AE%9A%E7%90%86#/media/%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB:Max_flow.svg" target="_blank" rel="noopener"
&gt;最大フロー最小カット定理&lt;/a&gt;から引用しています&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink"&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:3"&gt;
&lt;p&gt;標準形は一意に定まるとは限りません&amp;#160;&lt;a href="#fnref:3" class="footnote-backref" role="doc-backlink"&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:4"&gt;
&lt;p&gt;単純な関数の場合は劣モジュラ関数を(ほぼ)標準化したものでした．厳密には $min \lbrace \theta_{p;0}, \theta_{p;1} \rbrace = 0$ を満たしていませんが．&amp;#160;&lt;a href="#fnref:4" class="footnote-backref" role="doc-backlink"&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:5"&gt;
&lt;p&gt;Minimizing non-submodular functions with graph cuts – a review&amp;#160;&lt;a href="#fnref:5" class="footnote-backref" role="doc-backlink"&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:6"&gt;
&lt;p&gt;実装では容量に $\frac{1}{2}$ をかけるのではなく，最後に目的関数値に $\frac{1}{2}$ を掛ければいいです&amp;#160;&lt;a href="#fnref:6" class="footnote-backref" role="doc-backlink"&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description></item></channel></rss>