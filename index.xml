<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Eating Your Own Cat Food</title><link>https://miti-7.github.io/</link><description>Recent content on Eating Your Own Cat Food</description><generator>Hugo -- gohugo.io</generator><language>ja</language><lastBuildDate>Fri, 14 Mar 2025 00:00:00 +0900</lastBuildDate><atom:link href="https://miti-7.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Primal Dual Algorithm(厳密解)</title><link>https://miti-7.github.io/post/primal-dual-algorithm%E5%8E%B3%E5%AF%86%E8%A7%A3/</link><pubDate>Fri, 14 Mar 2025 00:00:00 +0900</pubDate><guid>https://miti-7.github.io/post/primal-dual-algorithm%E5%8E%B3%E5%AF%86%E8%A7%A3/</guid><description>&lt;h2 id="はじめに">はじめに
&lt;/h2>&lt;p>厳密解を求める primal dual algorithm の話です．&lt;br>
primal dual algorithm の一般的な説明をしたあと，具体例としてハンガリアン法を導出します．&lt;/p>
&lt;h2 id="準備">準備
&lt;/h2>&lt;p>以下の等式標準形の線形計画問題を考えます．簡単のため $\bold b \ge 0$ を仮定します．&lt;/p>
&lt;ul>
&lt;li>
&lt;p>主問題&lt;/p>
$$
\begin{aligned}
&amp;\text{minimize} &amp;&amp; \bold c^{T} \bold x \\
&amp;\text{subject to}
&amp;&amp; \bold A \bold x = \bold b \\
&amp; &amp;&amp; \bold x \geq 0
\end{aligned}
$$&lt;/li>
&lt;li>
$$
\begin{aligned}
&amp;\text{maxiimize} &amp;&amp; \bold b^{T} \bold y \\
&amp;\text{subject to}
&amp;&amp; \bold A^{T} \bold y \leq \bold c
\end{aligned}
$$&lt;/li>
&lt;/ul>
&lt;p>$\bold x$ と $\bold y$ が主問題と双対問題の最適解であるための必要十分条件は，以下の 2 つの条件をともに満たすことです．&lt;br>
$A_i$ は行列 $\bold A$ の $i$行目を，$A^{j}$ は行列 $\bold A$ の $j$ 列目の転置をとったものを表します．今回は主問題の制約条件に $\bold A \bold x = \bold b$ があるため，双対相補性条件を常に満たします．&lt;/p>
&lt;ul>
&lt;li>
&lt;p>主相補性条件&lt;/p>
$$
\begin{aligned}
&amp;&amp; x_{j} \gt 0 \Rightarrow \bold A^{j} \bold y = c_{j} &amp;&amp;&amp; \forall j \\
\end{aligned}
$$&lt;/li>
&lt;li>
$$
\begin{aligned}
&amp;&amp; y_{i} \gt 0 \Rightarrow \bold A_{i} \bold x = b_{i} &amp;&amp;&amp; \forall i \\
\end{aligned}
$$&lt;/li>
&lt;/ul>
&lt;p>${\bold x}^{\star}$ と ${\bold y}^{\star}$ が主問題と双対問題の最適解であるとき以下が成立します．&lt;/p>
$$
\begin{aligned}
&amp;&amp; \bold c^{T} \bold x^{\star} = \bold b^{T} \bold y^{\star} \\
\end{aligned}
$$&lt;h2 id="primal-dual-algorithm">Primal Dual Algorithm
&lt;/h2>&lt;p>primal dual algorithm は線形計画問題を解くための一般的なアルゴリズムです．&lt;br>
primal dual algorithm を用いて主問題の最適解 ${\bold x}^{\star}$ を求めます．簡単のため，主問題には実行可能解があると仮定します．primal dual algorithm は以下のように実行されます．双対問題の実行可能性が常に維持されていることに注意してください．&lt;/p>
&lt;ol>
&lt;li>双対問題の実行可能解 $\bold y$ を求める&lt;/li>
&lt;li>$\bold y$ をもとに構築した restricted primal problem を解く&lt;/li>
&lt;li>restricted primal problem の最適解の値が $0$ ならば，最適解 $\bold {x}^{\star}$ が判明したということなのでアルゴリズムを終了する&lt;/li>
&lt;li>restricted primal problem の最適解の値が $0$ でないならば，restricted primal problem の双対問題である dual restricted primal の最適解を求める．この解を $\bold z$ とする&lt;/li>
&lt;li>ある $\epsilon$ を求め，${\bold y}^{\prime} = {\bold y} + \epsilon {\bold z}$ を新たな双対問題の実行可能解として採用し，2 に戻る&lt;/li>
&lt;/ol>
&lt;p>順に詳しくみていきます．&lt;/p>
&lt;ol>
&lt;li>
&lt;p>双対問題の実行可能解 $\bold y$ を適当に求めます．$\bold c \ge 0$ を仮定しているため $\bold y = \bold 0$ とおくことができます．&lt;/p>
&lt;/li>
&lt;li>
&lt;p>ある双対問題の解 $\bold y$ が与えられたときに，「主問題の制約の違反」と「相補性条件の違反」を最小にするような主問題の解 $\bold x$ を見 つける問題を考えます．もしこれらの違反量が 0 の $\bold x$ を見つけることができたら，相補性条件よりこの $\bold x$ と $\bold y$ は最適解だということになります．&lt;br>
$J = \lbrace j \mid \bold A^{j} \bold y = c_{j} \rbrace$ とします．これは正になることのできる主問題の変数の index の集合です．すると，この問題は以下のような線形計画問題となります．これを restricted primal(以下 RP)とよびます．&lt;/p>
&lt;ul>
&lt;li>Restricted Primal
$$
\begin{aligned}
&amp;\text{minimize} &amp;&amp; \sum_i s_i \\\
&amp;\text{subject to}
&amp;&amp; \sum_{j \in J} \bold A_{ij} \bold x_j + \bold s_i = \bold b_i &amp;&amp;&amp; \forall i\\\
&amp; &amp;&amp; \bold x \geq \bold 0 &amp;&amp;&amp; j \in J\\\
&amp; &amp;&amp; \bold x = \bold 0 &amp;&amp;&amp; j \notin J\\\
&amp; &amp;&amp; \bold s \geq \bold 0
\end{aligned}
$$&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>もし RP の最適解の値が $0$ なら，この $(\bold x, \bold y)$ が主問題と双対問題の最適解ということになりアルゴリズムは終了します．&lt;/p>
&lt;/li>
&lt;li>
&lt;p>そうでない場合は相補性条件を満たすような実行可能解 $\bold x$ が見つからなかったということなので，$\bold y$ は双対問題の最適解ではなかったということがわかります．&lt;br>
そこで，$\bold y$ よりも良い双対問題の解を探すことにします．&lt;br>
そのために RP の双対問題である Dual Restricted Primal(以下 DRP)を考えます．これは以下のようになります．&lt;/p>
&lt;ul>
&lt;li>Dual Restricted Primal
$$
\begin{aligned}
&amp;\text{maxmize} &amp;&amp; \bold b^{T} \bold z \\\
&amp;\text{subject to}
&amp;&amp; \bold A^{j} \bold z \leq 0 &amp;&amp;&amp; j \in J \\\
&amp; &amp;&amp; z_{i} \leq 1 &amp;&amp;&amp; \forall i \\\
\end{aligned}
$$&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>DRP の最適解を $\bold z^{\star}$ とします．
双対問題の実行可能解 $\bold y$ に $\bold z^{\star}$ を $\epsilon(\epsilon \gt 0)$ 倍して足し合わせた解 ${\bold y}^{\prime} = \bold y + \epsilon \bold z^{\star}$ を考えます．
実はうまく $\epsilon$ を選ぶことで $\bold y^{\prime}$ は元の解 $\bold y$ よりも良い目的関数値をとり，さらに実行可能解となっています．&lt;br>
$\bold y$ よりも良い解 $\bold y^{\prime}$ が手に入れば，これを新たな双対問題の解として採用し，また 2 に戻り RP を考え&amp;hellip;と手順を繰り返していくことで，やがて最適解を得ることができます．&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>最後に，$\bold y^{\prime} = \bold y + \epsilon \bold z^{\star}$ が解 $\bold y$ よりも良い解となることと $\bold y^{\prime}$ が実行可能解となるような $\epsilon$ の選び方を示します．&lt;/p>
&lt;ul>
&lt;li>
&lt;p>$\bold y^{\prime} = \bold y + \epsilon \bold z^{\star}$ が解 $\bold y$ よりも良くなることを示します．&lt;br>
$\bold y^{\prime} = \bold y + \epsilon \bold z$ を双対問題の目的関数に当てはめると $\bold b^{T} \bold y^{\prime} = \bold b^{T} \bold y + \epsilon \bold b^{T} \bold z^{\star}$ となります．&lt;br>
$\epsilon \bold b^{T} \bold z^{\star} \gt 0$ となることを確認します．&lt;br>
$\epsilon$ は $0$ より大きい値をとるため，$\epsilon \gt 0$ となります．&lt;br>
RP の最適解の値は 0 より大きかったため，その双対問題である DRP の最適解の値も 0 より大きいことになります．よって，$\bold b^{T} \bold z^{\star} \gt 0$ といえます．&lt;br>
以上のことから，$\bold y^{\prime}$ が $\bold y$ より良い目的関数値をとることがわかりました．&lt;/p>
&lt;/li>
&lt;li>
&lt;p>$\bold y^{\prime} = \bold y + \epsilon \bold z^{\star}$ が双対問題の実行可能解となるような $\epsilon$ の選び方を示します．&lt;br>
双対問題の実行可能解になるように制約条件 $\bold A^{T} \bold y^{\prime} \leq \bold c$ を満たすような $\epsilon$ を求めます．&lt;br>
まず，双対問題の制約条件より $\bold A^{T} \bold y \le \bold c$ です．&lt;br>
次に，DRP の制約条件より $j \in J$ については $\bold A^{j} \bold z^{\star} \le 0$ となります．
よって，$j \in J$ であるような $j$ については制約条件を満たすため，$j \notin J$ のうち $\bold A^{j} \bold z^{\star} \gt 0$ である $j$ についてのみ考えます．&lt;br>
このような $j$ は $\epsilon \le \min_{j \notin J: A^{j} \bold z^{\star} \gt 0} \frac{c_j - \bold A^{j} \bold y}{\bold A^{j} \bold z^{\star}}$ を満たす必要があります．&lt;br>
$\epsilon$ は大きい方がいいので，この条件を満たす最大の値を $\epsilon$ として選びます．&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="ハンガリアン法">ハンガリアン法
&lt;/h2>&lt;p>Primal Dual Algorighm を使ってハンガリアン法を導出します．
頂点 $a$ と頂点 $b$ を結ぶ辺を $(a, b) \in E$ とし，その容量を $c_{ab}$ とします．簡単のため $\bold c \ge \bold 0$ とし完全マッチングが存在するものとします．&lt;/p>
&lt;p>以下では，有向グラフを接続行列 $\bold A$ で表します．また，ノードの数を $n$，辺の数を $m$ とします．
二部グラフの最小重み完全マッチングを線形緩和した主問題と双対問題を定義します．&lt;/p>
&lt;ul>
&lt;li>主問題&lt;/li>
&lt;/ul>
$$
\begin{aligned}
&amp;\text{minimize} &amp;&amp; \sum_{(a, b) \in E} c_{ab} x_{ab} \\
&amp;\text{subject to}
&amp;&amp; \sum_{b:(a, b) \in E} x_{ab} = 1 &amp;&amp;&amp; a \in A \\
&amp; &amp;&amp; \sum_{a:(a, b) \in E} x_{ab} = 1 &amp;&amp;&amp; b \in B \\
&amp; &amp;&amp; x_{ab} \ge 0 &amp;&amp;&amp; (a, b) \in E\\
\end{aligned}
$$&lt;ul>
&lt;li>双対問題&lt;/li>
&lt;/ul>
$$
\begin{aligned}
&amp;\text{maxiimize} &amp;&amp; \sum_{a \in A} u_{a} + \sum_{b \in B} v_{b} \\
&amp;\text{subject to}
&amp;&amp; u_{a} + v_{b} \le c_{ab} &amp;&amp;&amp; (a, b) in E\\
\end{aligned}
$$&lt;h3 id="ハンガリアン法の導出">ハンガリアン法の導出
&lt;/h3>&lt;ol>
&lt;li>
&lt;p>双対問題の適当な実行可能解を求めます．$C \ge 0$ を仮定しているため，$\bold u = \bold v = \bold 0$ とすることができます．&lt;/p>
&lt;/li>
&lt;li>
&lt;p>restricted primal を考えます．$J = \lbrace(a, b) \in E : u_{a} + v_{b} = c_{ab} \rbrace$ とすると以下のようになります．これは $J$ の辺のみを使って完全マッチングを求める問題です．&lt;/p>
&lt;ul>
&lt;li>Restricted Primal
$$
\begin{aligned}
&amp;\text{minimize} &amp;&amp; \sum_{a \in A} s_{a} + \sum_{b \in B} s_{b} \\\
&amp;\text{subject to}
&amp;&amp; \sum_{b:(a, b) \in E} x_{ab} + s_{a} = 1 &amp;&amp;&amp; a \in A\\\
&amp; &amp;&amp; \sum_{a:(a, b) \in E} x_{ab} + s_{b} = 1 &amp;&amp;&amp; b \in B\\\
&amp; &amp;&amp; x_{ab} >= 0 &amp;&amp;&amp; (a, b) \in J \\\
&amp; &amp;&amp; x_{ab} = 0　&amp;&amp;&amp; (a, b) \in (E - J) \\\
&amp; &amp;&amp; s \ge 0
\end{aligned}
$$&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>$J$ の辺のみをつかって完全マッチングを作ることができれば，RP の目的関数値を 0 にすることができます．
辺の重みを考えなくてよくなったため，2 部グラフの最大マッチングを求めるアルゴリズムを使うことができます．
もし完全マッチングがみつかればアルゴリズムは終了します．&lt;/p>
&lt;/li>
&lt;li>
&lt;p>見つからない場合は dual restricted primal を考えます．DRP は $J$ の辺のみを使ったグラフ上で最小点被覆を求める問題です．これは RP で求めた最大マッチングの解を使って求めることができます ．&lt;/p>
&lt;ul>
&lt;li>Dual Restricted Primal
$$
\begin{aligned}
&amp;\text{maximize} &amp;&amp; \sum_{a \in A} u^{\prime}_{a} + \sum_{b \in B} v^{\prime}_{b} \\\
&amp;\text{subject to}
&amp;&amp; u^{\prime}_{a} + v^{\prime}_{b} \le 0 &amp;&amp;&amp; (a, b) \in J \\\
&amp; &amp;&amp; u^{\prime}_{a} \le 1 &amp;&amp;&amp; a \in A\\\
&amp; &amp;&amp; v^{\prime}_{b} \le 1 &amp;&amp;&amp; b \in B
\end{aligned}
$$&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>DRP の解を求め，$u^{\prime \prime} = u + \epsilon u^{\prime}$，$v^{\prime \prime} = v + \epsilon v^{\prime}$とします．ここで $\epsilon = \min_{(a, b) \in (E - J)}(c_{ab} - u_{a} - v_{b})$ とすることができます．あとは，$u^{\prime}$ と $v^{\prime}$ を新しい双対問題の解として採用し，2 に戻ります．&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="参考文系">参考文系
&lt;/h2>&lt;ul>
&lt;li>&lt;a class="link" href="https://www.amazon.co.jp/dp/B00C8UQZAO/" target="_blank" rel="noopener"
>Combinatorial Optimization: Algorithms and Complexity&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://ocw.mit.edu/courses/18-433-combinatorial-optimization-fall-2003/92c255b407a6ad7d75c9ea55de2fdf33_l15.pdf" target="_blank" rel="noopener"
>18.433 Combinatorial Optimization The Primal-dual Algorithm&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://math.mit.edu/~goemans/PAPERS/book-ch4.pdf" target="_blank" rel="noopener"
>CHAPTER 4 THE PRIMAL-DUAL METHOD FOR APPROXIMATION ALGORITHMS AND ITS APPLICATION TO NETWORK DESIGN PROBLEMS&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>ICLを受けてきた</title><link>https://miti-7.github.io/post/icl%E3%82%92%E5%8F%97%E3%81%91%E3%81%A6%E3%81%8D%E3%81%9F/</link><pubDate>Mon, 24 Feb 2025 00:00:00 +0900</pubDate><guid>https://miti-7.github.io/post/icl%E3%82%92%E5%8F%97%E3%81%91%E3%81%A6%E3%81%8D%E3%81%9F/</guid><description>&lt;h2 id="icl">ICL
&lt;/h2>&lt;p>ICL 手術を &lt;a class="link" href="https://eyeclinic-tokyo.jp/" target="_blank" rel="noopener"
>アイクリニック東京&lt;/a> で受けてきました．&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>日&lt;/th>
&lt;th>event&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>-43&lt;/td>
&lt;td>診察の予約をする&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-31&lt;/td>
&lt;td>初診適応検査をする&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-25&lt;/td>
&lt;td>レンズ度数決定のための検査をする&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-21&lt;/td>
&lt;td>レンズの準備完了の電話がくる．手術日，翌日検査，１週間後検査の予約をする&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-3 ～ -1&lt;/td>
&lt;td>抗菌薬&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>を 1 日 4 回点眼する&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0&lt;/td>
&lt;td>手術日．手術前の抗菌薬点眼は朝と昼の 2 回行う．&lt;br>手術後に 3 種類の目薬&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>の点眼を開始&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>手術翌日検査をする．首から下のシャワーのみ可能&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>2 ～ 6&lt;/td>
&lt;td>目薬&lt;sup id="fnref1:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>を 1 日 4 回点眼する．保護メガネ着用&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>7&lt;/td>
&lt;td>手術 1 週間後検査をする&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>8 ～ 34&lt;/td>
&lt;td>目薬&lt;sup id="fnref:3">&lt;a href="#fn:3" class="footnote-ref" role="doc-noteref">3&lt;/a>&lt;/sup>を 1 日 4 回点眼する．保護メガネは外していい&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="初診適応検査">初診適応検査
&lt;/h2>&lt;ul>
&lt;li>ICL を受けられるかの検査や視力の検査を行う
&lt;ul>
&lt;li>最初の問診票で執刀医の希望を書く欄があるので院長を指定した&lt;/li>
&lt;li>検査結果は問題なかった&lt;/li>
&lt;li>視力，屈折度，角膜曲率半径，眼圧検査の結果が貰える&lt;/li>
&lt;li>全体で 80 分くらいかかった&lt;/li>
&lt;li>レンズ度数のシミュレーションをする．度数の強さと乱視補正をどうするかを次回までに決める
&lt;ul>
&lt;li>乱視付き ICL(トーリック ICL)にすると +5 万かかり，将来的に軸がずれ再手術しなければならない可能性がある&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>検査代として 1 万円支払うが，ICL を受ければ返ってくる&lt;/li>
&lt;/ul>
&lt;h2 id="レンズ度数決定のための検査">レンズ度数決定のための検査
&lt;/h2>&lt;ul>
&lt;li>視力は前回の検査と変わらなかった
&lt;ul>
&lt;li>詳細なデータは貰えなかった&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>レンズ度数の本決定
&lt;ul>
&lt;li>度数
&lt;ul>
&lt;li>PC を使う時間が多いので 2 段階強さを落としてもらった
&lt;ul>
&lt;li>具体的な強さを指定するのではなく，MAX から何段階落とすかを指定する形式だった&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>乱視補正
&lt;ul>
&lt;li>眼鏡では乱視補正をしているのと，軸がずれる可能性は低いということで乱視用のレンズにした&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>前金 30 万を払う&lt;/li>
&lt;/ul>
&lt;h2 id="手術">手術
&lt;/h2>&lt;ul>
&lt;li>病院
&lt;ul>
&lt;li>病院に到着後まず残金を支払い，その後の手術の説明をうける
&lt;ul>
&lt;li>瞳孔を開く目薬をさすので必要な手続きはすべて最初に行う&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>5 分ごとに目薬をする．スタッフが時間を教えてくれるわけではないので自分で時間を測る必要がある&lt;/li>
&lt;li>時々スタッフが来て目の状態を確認する．結局 11 回ほど目薬をしたあとに手術室に呼ばれる&lt;/li>
&lt;li>手術の最中は執刀医がどんな状況か教えてくれる
&lt;ul>
&lt;li>全部あわせて 5 分くらいで終わった&lt;/li>
&lt;li>痛みはないが目に強い圧迫感があり精神的に厳しかった&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>全部で 2 時間くらいで終了した&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>帰宅後
&lt;ul>
&lt;li>目薬を 1 時間ごとにさす&lt;/li>
&lt;li>ハローとグレアがかなりすごい．マウスのカーソルにもハローが見える&lt;/li>
&lt;li>目がゴロゴロする&lt;/li>
&lt;li>ひたすら目をつぶってはやめに寝た&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="翌日検査">翌日検査
&lt;/h2>&lt;ul>
&lt;li>体調
&lt;ul>
&lt;li>ハローとグレアはほぼないが真っ暗な部屋で白いモニターをみるとハローが少しみえる&lt;/li>
&lt;li>目薬をさすときに目の周辺に黒い影がみえる．メガネの縁が見えているような感じ
&lt;ul>
&lt;li>病院で質問したらレンズの影とのこと
&lt;ul>
&lt;li>そのうち脳内補正されて気にならなくなるらしい&lt;/li>
&lt;li>目薬のときくらいしか見えないので日常生活に問題はなさそう&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>病院
&lt;ul>
&lt;li>眼圧検査，視力検査，検診をした&lt;/li>
&lt;li>両目とも 1.5 になっていた
&lt;ul>
&lt;li>予定より視力があがってしまっていた&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="1-週間後検査">1 週間後検査
&lt;/h2>&lt;ul>
&lt;li>眼圧検査，視力検査，検診をした
&lt;ul>
&lt;li>特に問題なし&lt;/li>
&lt;li>両目とも 1.5 のまま&lt;/li>
&lt;li>リンデロン点眼からフルメトロン点眼液 0.1% に変更&lt;/li>
&lt;li>ドライアイがあるのでドライアイ用の目薬&lt;sup id="fnref:4">&lt;a href="#fn:4" class="footnote-ref" role="doc-noteref">4&lt;/a>&lt;/sup>を出してもらう&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="料金">料金
&lt;/h2>&lt;ul>
&lt;li>73 万円 + 5 万円 - 2 万円 = 76 万円
&lt;ul>
&lt;li>基本料金：73 万円&lt;/li>
&lt;li>乱視あり(片側のみ)：5 万円&lt;/li>
&lt;li>平日割：-2 万円&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>料金がはっきりしているのはかなりよかった
&lt;ul>
&lt;li>オプションを進められるみたいな手間が一切なかった&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="懸念したこと">懸念したこと
&lt;/h2>&lt;ul>
&lt;li>レンズの回転（軸ずれ）
&lt;ul>
&lt;li>トーリックレンズの場合はレンズの軸がずれると見え方が悪化してしまう（通常のレンズだと回転しても問題はない）
&lt;ul>
&lt;li>病院で軸がずれたときの見え方をシミュレーションしたがかなりきつい感じだった&lt;/li>
&lt;li>軸ずれが起きる確率は 0.1 % くらいとのことなのでなにもないことに賭けた&lt;/li>
&lt;li>3 年保証がありもし回転しても補正は無料なのと，どうしてもずれてしまうなら通常のレンズを入れ直そうと思っている
&lt;ul>
&lt;li>今のところ問題はない&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="気になったこと">気になったこと
&lt;/h2>&lt;ul>
&lt;li>レンズ度数を決めたとき，どのレンズになるのかの書類が貰えず口約束になってしまっていた．今回は問題なかったけどトラブル防止にもらっておけばよかった．
&lt;ul>
&lt;li>そもそも書類を貰えるのか不明だが&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="todo">TODO
&lt;/h2>&lt;ul>
&lt;li>1 ヶ月後検査&lt;/li>
&lt;li>3 ヶ月後検査&lt;/li>
&lt;li>確定申告&lt;/li>
&lt;/ul>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>ベガモックス点眼液 0.5%&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2">
&lt;p>クラビット点眼液 1.5%，リンデロン点眼・点耳・点鼻液 0.1％，ジクロフェナク Na 点眼液 0.1%&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&amp;#160;&lt;a href="#fnref1:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:3">
&lt;p>クラビット点眼液 1.5%，フルメトロン点眼液 0.1%，ジクロフェナク Na 点眼液 0.1%&amp;#160;&lt;a href="#fnref:3" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:4">
&lt;p>ヒアルロン酸ナトリウム点眼液 0.1％&amp;#160;&lt;a href="#fnref:4" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>Quadratic Pseudo-Boolean Optimization</title><link>https://miti-7.github.io/post/quadratic-pseudo-boolean-optimization/</link><pubDate>Thu, 09 Jan 2025 00:00:00 +0900</pubDate><guid>https://miti-7.github.io/post/quadratic-pseudo-boolean-optimization/</guid><description>&lt;img src="https://miti-7.github.io/post/quadratic-pseudo-boolean-optimization/images/general_sample_ab_1.png" alt="Featured image of post Quadratic Pseudo-Boolean Optimization" />&lt;h2 id="quadratic-pseudo-boolean-optimization">Quadratic Pseudo-Boolean Optimization
&lt;/h2>&lt;p>次の関数 $E(\bold x)$ を最小化する問題を考えます．$x_{p} \in \lbrace 0, 1 \rbrace$ とし，$\theta_{const}$ は定数を表します．この問題を &lt;a class="link" href="https://en.wikipedia.org/wiki/Quadratic_pseudo-Boolean_optimization" target="_blank" rel="noopener"
>Quadratic Pseudo-Boolean Optimization&lt;/a>(以下 QPBO)と呼びます．&lt;/p>
$$
\begin{equation}
E(\bold x) = \theta_{const} + \sum_p \theta_{p}(x_p) + \sum_{p \lt q} \theta_{pq}(x_p, x_q)
\end{equation}
$$&lt;p>競プロ界隈で「燃やす埋める」や「Project Selection Problem」などと言われる問題は QPBO に帰着することができます&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>．&lt;br>
これらの問題は minimum s-t cut に帰着して解くことができますが，どのように辺を張るかなど混乱しがちです．本記事の目的は QPBO を解くアルゴリズムをライブラリ化することで，問題を解くときに辺の張り方や変数のフリップ操作などを考えなくてすむようにすることです．実装は &lt;a class="link" href="https://github.com/MitI-7/CompetitiveProgrammingLibrary/blob/1c8b83e0e54a6729cce7cf2c7eee09d1de0e4c05/library/cpp/optimization/QPBO.hpp" target="_blank" rel="noopener"
>QPBO.hpp&lt;/a> にあります．&lt;/p>
&lt;p>記事の構成は以下の通りです．&lt;br>
&lt;a class="link" href="#1-s-t-cut" >節 1&lt;/a> では s-t cut と minimum s-t cut の説明をします．minimum s-t cut は多項式時間で求めることができます．&lt;/p>
&lt;p>&lt;a class="link" href="#2-%e5%8d%98%e7%b4%94%e3%81%aa%e9%96%a2%e6%95%b0%e3%81%ae%e5%a0%b4%e5%90%88" >節 2&lt;/a> では関数 $E(\bold x)$ が $\theta_{pq}(0, 0) = \theta_{pq}(1, 1) = 0$ であり，どの関数も $0$ 以上の値を返すという単純な関数の場合について考えます．
この場合は minimum s-t cut を見つける問題にそのまま帰着できます．&lt;/p>
&lt;p>&lt;a class="link" href="#3-%e5%8a%a3%e3%83%a2%e3%82%b8%e3%83%a5%e3%83%a9%e9%96%a2%e6%95%b0%e3%81%ae%e5%a0%b4%e5%90%88" >節 3&lt;/a> では節 2 の仮定を排除し，関数 $E(\bold x)$ が劣モジュラ関数であるという仮定のみをおいた場合について考えます．&lt;br>
この場合は再パラメータ化という操作を行うことで単純な関数の場合に帰着させることができます．&lt;/p>
&lt;p>&lt;a class="link" href="#4-%e4%b8%80%e8%88%ac%e3%81%ae%e9%96%a2%e6%95%b0%e3%81%ae%e5%a0%b4%e5%90%88" >節 4&lt;/a> では関数 $E(\bold x)$ が一般の関数の場合について考えます．&lt;br>
$E(\bold x)$ が一般の関数の場合，これを最小化する問題は NP-hard であり，多項式時間で解くことは(今のところ)できそうもありません．この場合は問題を緩和することで劣モジュラ関数の場合に帰着させ近似解を得ることができます．さらに，ここで得られた解は最適解の一部となることが保証されます．&lt;/p>
&lt;p>&lt;a class="link" href="#5-%e5%95%8f%e9%a1%8c" >節 5&lt;/a> では競プロの問題をいくつか解いていきます．&lt;/p>
&lt;h2 id="1-s-t-cut">1. s-t cut
&lt;/h2>&lt;p>頂点集合 $V$ と 有向辺 $E$ からなる有向グラフ $G = (V, E)$ が与えられます．辺 $(i, j)$ には容量 $c_{ij} \ge 0$ が定まっているものとします．&lt;br>
頂点集合 $V$ を 2 つの部分集合 $S$ と $T = V \backslash S$ に分割します．2 つのノード $s$ と $t$ について $s \in S$，$t \in T$ となるような分割を s-t cut と呼びます．&lt;br>
$S$ から出て $T$ に入るような辺の容量の総和を s-t cut の容量と呼び，以下で定義されます．すべての s-t cut のうち最小のものを minimum s-t cut と呼びます．&lt;/p>
$$
\begin{aligned}
c(S) = \sum_{(i, j) \in (S, T)} c_{ij}
\end{aligned}
$$&lt;p>下のグラフの s-t cut の例をいくつか見ていきます &lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>．&lt;/p>
&lt;img src="images/s-t-cut_sample1.png" width="50%">
&lt;p>頂点の部分集合として，$S = \lbrace s, 0, 1 \rbrace$ を選んだとします．&lt;br>
$S$ に属する頂点を赤，$T = V \backslash S$ に属する頂点を青で示します． $S$ から出て $T$ に入るような辺は辺 (0, 2) と辺 (1, 3) です．よって，この s-t cut の容量は 3 + 2 = 5 となります．&lt;br>
すべての s-t cut の中でこのカットより容量の小さい s-t cut は存在しないのでこれは minimum s-t cut です．&lt;/p>
&lt;img src="images/s-t-cut_sample2.png" width="50%">
&lt;p>頂点の部分集合として $S = \lbrace s, 0, 1, 2, 3 \rbrace$ を選んだとします．&lt;br>
この s-t cut の容量は 2 + 3 = 5 となります．&lt;br>
このカットも minimum s-t cut です．このように minimum s-t cut は複数存在することがあります．&lt;/p>
&lt;img src="images/s-t-cut_sample3.png" width="50%">
&lt;p>頂点の部分集合として $S = \lbrace s, 1, 2 \rbrace$ を選んだとします．&lt;br>
この s-t cut の容量は，3 + 2 + 4 + 2 = 11 となります．&lt;br>
辺 (0, 1) や辺 (0, 2) は $T$ から $S$ に入る辺なので含まれません．&lt;/p>
&lt;img src="images/s-t-cut_sample4.png" width="50%">
&lt;p>minimum s-t cut は最大流問題を解き，残余ネットワーク上で頂点 $s$ から到達できる頂点集合を $S$ とすることで求められます．詳しくは &lt;a class="link" href="https://ja.wikipedia.org/wiki/%E6%9C%80%E5%A4%A7%E3%83%95%E3%83%AD%E3%83%BC%E6%9C%80%E5%B0%8F%E3%82%AB%E3%83%83%E3%83%88%E5%AE%9A%E7%90%86" target="_blank" rel="noopener"
>最大フロー最小カット定理&lt;/a> などを参照してください．&lt;br>
次節から s-t cut を使って $E(\bold x)$ を最小化する方法を見ていきます．&lt;/p>
&lt;h2 id="2-単純な関数の場合">2. 単純な関数の場合
&lt;/h2>&lt;p>関数 $E(\bold x)$ を最小化する方法を考えていきます．$x_{p} \in \lbrace 0, 1 \rbrace$ なので，変数の個数が $n$ 個のとき解は $2^n$ 個存在します．この $2^n$ 個の解のなかから最小のものを見つけるのが目標です．&lt;/p>
$$
\begin{equation}
E(\bold x) = \theta_{const} + \sum_{p} \theta_{p}(x_p) + \sum_{p \lt q} \theta_{pq}(x_p, x_q) \tag {1}
\end{equation}
$$&lt;p>単純な関数の場合を考えたいので，$\theta_{pq}(0, 0) = \theta_{pq}(1, 1) = 0$ であり，すべて 0 以上の値を返すと仮定します．&lt;br>
この仮定を満たす関数の場合は $E(\bold x)$ の解と s-t cut の解が 1 対 1 対応するようなグラフを作成することができます．よって，グラフの最小 s-t cut がわかれば $E(\bold x)$ の最小値（= 最適解）を求めることができます．&lt;/p>
&lt;p>グラフは各変数を頂点とし，これに特別な頂点 $s$ と $t$ を加えた $n + 2$ 個の頂点から構成されます．辺は下記のルールにしたがって張ります．&lt;/p>
&lt;div style="display: flex; gap: 20px;">
&lt;div>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>関数&lt;/th>
&lt;th>辺&lt;/th>
&lt;th>容量&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>$\theta_{p}(0)$&lt;/td>
&lt;td>$p \rightarrow t$&lt;/td>
&lt;td>$\theta_{p}(0)$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$\theta_{p}(1)$&lt;/td>
&lt;td>$s \rightarrow p$&lt;/td>
&lt;td>$\theta_{p}(1)$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$\theta_{pq}(0, 1)$&lt;/td>
&lt;td>$p \rightarrow q$&lt;/td>
&lt;td>$\theta_{pq}(0, 1)$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$\theta_{pq}(1, 0)$&lt;/td>
&lt;td>$q \rightarrow p$&lt;/td>
&lt;td>$\theta_{pq}(1, 0)$&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/div>
&lt;/div>
&lt;p>具体例として，変数が $a$ と $b$ の 2 つだけの場合を見てみます．&lt;br>
各変数の値に対応する $E(\bold x) = \theta_a(a) + \theta_b(b) + \theta_{ab}(a, b)$ の値は以下のようになります．$\theta_{ab}(0, 0)$ と $\theta_{ab}(1, 1)$ の値は $0$ であり，$\theta_{const}$ は定数のため省略しています．&lt;/p>
&lt;div style="display: flex; gap: 20px;">
&lt;div>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>a&lt;/th>
&lt;th>b&lt;/th>
&lt;th>$E(\bold x)$&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>0&lt;/td>
&lt;td>0&lt;/td>
&lt;td>$\theta_{a}(0) + \theta_{b}(0)$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0&lt;/td>
&lt;td>1&lt;/td>
&lt;td>$\theta_{a}(0) + \theta_{b}(1) + \theta_{ab}(0, 1)$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>0&lt;/td>
&lt;td>$\theta_{a}(1) + \theta_{b}(0) + \theta_{ab}(1, 0)$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>1&lt;/td>
&lt;td>$\theta_{a}(1) + \theta_{b}(1)$&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/div>
&lt;/div>
&lt;p>ルールに従うと下のグラフが構築されます．&lt;br>
このグラフの s-t cut をいくつか見ていきます．&lt;/p>
&lt;img src="images/simple_sample.png" width="25%">
&lt;p>$S = \lbrace s, a, b \rbrace$ とします．この s-t cut の容量は $\theta_{a}(0) + \theta_{b}(0)$ です．&lt;br>
また，$a = 0$，$b = 0$ としたとき $E(\bold x)$ の値は $\theta_{a}(0) + \theta_{b}(0)$ です．&lt;br>
よって，$S = \lbrace s, a, b \rbrace$ としたときの s-t cut の容量と，$a = 0$，$b = 0$ としたときの $E(\bold x)$ の関数値は一致しています．&lt;/p>
&lt;img src="images/simple_cut1.png" width="25%">
&lt;p>別の s-t cut の例をみます．&lt;br>
$S = \lbrace s, a \rbrace$ とします．この s-t cut の容量は $\theta_{a}(0) + \theta_{b}(1) + \theta_{ab}(0, 1)$ です．&lt;br>
また，$a = 0$，$b = 1$ としたとき $E(\bold x)$ の値は $\theta_{a}(0) + \theta_{b}(1) + \theta_{ab}(0, 1)$ です．&lt;br>
よって，$S = \lbrace s, a \rbrace$ としたときの s-t cut の容量と，$a = 0$，$b = 1$ としたときの $E(\bold x)$ の関数値は一致しています．&lt;/p>
&lt;img src="images/simple_cut2.png" width="25%">
&lt;p>変数が 2 つの場合は s-t cut は $2^2$ 通りあります．すべてのパターンは以下の通りです．&lt;/p>
&lt;img src="images/simple_cut_all.png" width="50%">
&lt;p>このように s-t cut の構成と $E(\bold x) $ の構成が 1 対 1 対応するため，minimum s-t cut を計算することで $E(\bold x)$ の最小値を求めることができます．&lt;br>
minimum s-t cut を計算し，$S$ に属する頂点に対応する変数の値を $0$，$T$ に属する頂点に対応する変数の値を $1$ と設定することで最適な $\bold x$ を構成できます．&lt;/p>
&lt;h2 id="3-劣モジュラ関数の場合">3. 劣モジュラ関数の場合
&lt;/h2>&lt;p>「&lt;a class="link" href="#2-%e5%8d%98%e7%b4%94%e3%81%aa%e9%96%a2%e6%95%b0%e3%81%ae%e5%a0%b4%e5%90%88" >2. 単純な関数の場合&lt;/a>」では，$\theta_{pq}(0, 0) = \theta_{pq}(1, 1) = 0$ とし，どの関数も $0$ 以上の値を返すことを仮定していました．&lt;br>
この節ではこの仮定を排除し，関数は劣モジュラであることのみを仮定します．今回は 2 値変数を考えているので，$\theta_{pq}(0, 1) + \theta_{pq}(1, 0) \ge \theta_{pq}(0, 0) + \theta_{pq}(1, 1)$ を満たすことになります．&lt;/p>
&lt;p>$\theta_{pq}(0, 0)$ や $\theta_{pq}(1, 1)$ が $0$ 以外の値をとったり関数値が負の値をとる場合があるので，今回はルール通りにグラフを作ることはできません．そこで再パラメータ化という操作を行います．再パラメータ化とは，$E(\bold x)$ の関数値を保ちつつ $\theta_{pq}(1, 0)$ などの各関数値を変化させる操作です．&lt;br>
再パラメータ化を行うと標準形とよばれる以下の条件を満たす形になります&lt;sup id="fnref:3">&lt;a href="#fn:3" class="footnote-ref" role="doc-noteref">3&lt;/a>&lt;/sup>．標準形ではどの関数も $0$ 以上の値をとります．&lt;/p>
&lt;ul>
&lt;li>$min \lbrace \theta_{p}(0), \theta_{p}(1) \rbrace = 0$&lt;/li>
&lt;li>$min \lbrace \theta_{pq}(0, 0), \theta_{pq}(1, 0) \rbrace = 0$&lt;/li>
&lt;li>$min \lbrace \theta_{pq}(0, 1), \theta_{pq}(1, 1) \rbrace = 0$&lt;/li>
&lt;/ul>
&lt;p>再パラメータ化をすると，関数 $\theta_{pq}(x_{p}, x_{q})$ が劣モジュラの場合は $\theta_{pq}(0, 0) = \theta_{pq}(1, 1) = 0$ に，関数 $\theta_{pq}(x_{p}, x_{q})$ が優モジュラの場合は $\theta_{pq}(0, 1) = \theta_{pq}(1, 0) = 0$ になります&lt;sup id="fnref:4">&lt;a href="#fn:4" class="footnote-ref" role="doc-noteref">4&lt;/a>&lt;/sup>．&lt;br>
よって，すべての $\theta_{pq}(x_{p}, x_{q})$ が劣モジュラ関数の場合は，再パラメータ化をすることで「&lt;a class="link" href="#2-%e5%8d%98%e7%b4%94%e3%81%aa%e9%96%a2%e6%95%b0%e3%81%ae%e5%a0%b4%e5%90%88" >2. 単純な関数の場合&lt;/a>」に帰着することができます．&lt;br>
再パラメータ化の手続きは以下の通りです．&lt;/p>
&lt;ul>
&lt;li>step1
&lt;ul>
&lt;li>すべての (p, q) の各 $j \in \lbrace 0, 1 \rbrace$ について
&lt;ul>
&lt;li>$\delta = min \lbrace \theta_{pq}(0, j), P_{pq}(1, j) \rbrace$&lt;/li>
&lt;li>$\theta_{pq}(0, j) = \theta_{pq}(0, j) - \delta$&lt;/li>
&lt;li>$\theta_{pq}(1, j) = \theta_{pq}(1, j) - \delta$&lt;/li>
&lt;li>$\theta_{q}(j) = \theta_{q}(j) + \delta$&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>step2
&lt;ul>
&lt;li>$\delta = min \lbrace \theta_p(0), \theta_p(1) \rbrace$&lt;/li>
&lt;li>$\theta_{p}(0) = \theta_{p}(0) - \delta$&lt;/li>
&lt;li>$\theta_{p}(1) = \theta_{p}(1) - \delta$&lt;/li>
&lt;li>$\theta_{const} = \theta_{const} + \delta$&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>再パラメータ化をしたとき，目的関数値が変化しないことを確認します．&lt;br>
step 1 の $j = 0$ では，$\theta_{pq}(0, 0)$ と $\theta_{pq}(1, 0)$ から $\delta$ を引き，$\theta_{q}(0)$ に $\delta$ を加えます．&lt;br>
この操作を行うと $E(\bold x)$ は以下の表のように変化します．$\delta$ が打ち消し合って，目的関数値が保たれていることが確認できます．&lt;br>
また，$\delta$ として $min \lbrace \theta_{pq}(0, 0), P_{pq}(1, 0) \rbrace$ を選んでいるので，$min \lbrace \theta_{pq;00}, \theta_{pq;10} \rbrace = 0$ を満たすようになります．&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>p&lt;/th>
&lt;th>q&lt;/th>
&lt;th>$E(\bold x)$&lt;/th>
&lt;th>$E^{\prime}(\bold x)$&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>0&lt;/td>
&lt;td>0&lt;/td>
&lt;td>$\theta_{const} + \theta_{p}(0) + \theta_{q}(0) + \theta_{ab}(0, 0)$&lt;/td>
&lt;td>$\theta_{const} + \theta_{p}(0) + (\theta_{q}(0) + \delta) + (\theta_{ab}(0, 0) - \delta)$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0&lt;/td>
&lt;td>1&lt;/td>
&lt;td>$\theta_{const} + \theta_{p}(0) + \theta_{q}(1) + \theta_{ab}(0, 1)$&lt;/td>
&lt;td>$\theta_{const} + \theta_{p}(0) + \theta_{q}(1) + \theta_{ab}(0, 1)$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>0&lt;/td>
&lt;td>$\theta_{const} + \theta_{p}(1) + \theta_{q}(0) + \theta_{ab}(1, 0)$&lt;/td>
&lt;td>$\theta_{const} + \theta_{p}(1) + (\theta_{q}(0) + \delta) + (\theta_{ab}(1, 0) - \delta)$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>1&lt;/td>
&lt;td>$\theta_{const} + \theta_{p}(1) + \theta_{q}(1) + \theta_{ab}(1, 1)$&lt;/td>
&lt;td>$\theta_{const} + \theta_{p}(1) + \theta_{q}(1) + \theta_{ab}(1, 1)$&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>step 1 の $j = 1$ では，$\theta_{pq}(0, 1)$ と $\theta_{pq}(1, 1)$ から $\delta$ を引き，$\theta_{q}(1)$ に $\delta$ を加えます．&lt;br>
$\delta$ として $min \lbrace \theta_{pq}(0, 1), P_{pq}(1, 1) \rbrace$ を選んでいるので，$min \lbrace \theta_{pq;01}, \theta_{pq;11} \rbrace = 0$ を満たすようになります．&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>p&lt;/th>
&lt;th>q&lt;/th>
&lt;th>$E(\bold x)$&lt;/th>
&lt;th>$E^{\prime}(\bold x)$&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>0&lt;/td>
&lt;td>0&lt;/td>
&lt;td>$\theta_{const} + \theta_{p}(0) + \theta_{q}(0) + \theta_{ab}(0, 0)$&lt;/td>
&lt;td>$\theta_{const} + \theta_{p}(0) + \theta_{q}(0) + \theta_{ab}(0, 0)$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0&lt;/td>
&lt;td>1&lt;/td>
&lt;td>$\theta_{const} + \theta_{p}(0) + \theta_{q}(1) + \theta_{ab}(0, 1)$&lt;/td>
&lt;td>$\theta_{const} + \theta_{p}(0) + (\theta_{q}(1) + \delta) + (\theta_{ab}(0, 1) - \delta)$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>0&lt;/td>
&lt;td>$\theta_{const} + \theta_{p}(1) + \theta_{q}(0) + \theta_{ab}(1, 0)$&lt;/td>
&lt;td>$\theta_{const} + \theta_{p}(1) + \theta_{q}(0) + \theta_{ab}(1, 0)$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>1&lt;/td>
&lt;td>$\theta_{const} + \theta_{p}(1) + \theta_{q}(1) + \theta_{ab}(1, 1)$&lt;/td>
&lt;td>$\theta_{const} + \theta_{p}(1) + (\theta_{q}(1) + \delta) + (\theta_{ab}(1, 1) - \delta)$&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>step 2 では，$\theta_{p}(0)$ と $\theta_{p}(1)$ から $\delta$ を引き，$\theta_{const}$ に $\delta$ を加えます．&lt;br>
$\delta$ として $min \lbrace \theta_p(0), \theta_p(1) \rbrace$ を選んでいるので，$min \lbrace \theta_{p;0}, \theta_{p;1} \rbrace = 0$ を満たすようになります．&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>p&lt;/th>
&lt;th>q&lt;/th>
&lt;th>$E(\bold x)$&lt;/th>
&lt;th>$E^{\prime}(\bold x)$&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>0&lt;/td>
&lt;td>0&lt;/td>
&lt;td>$\theta_{const} + \theta_{p}(0) + \theta_{q}(0) + \theta_{ab}(0, 0)$&lt;/td>
&lt;td>$(\theta_{const} + \delta) + (\theta_{p}(0) - \delta) + \theta_{q}(0) + \theta_{ab}(0, 0)$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0&lt;/td>
&lt;td>1&lt;/td>
&lt;td>$\theta_{const} + \theta_{p}(0) + \theta_{q}(1) + \theta_{ab}(0, 1)$&lt;/td>
&lt;td>$(\theta_{const} + \delta) + (\theta_{p}(0) - \delta) + \theta_{q}(1) + \theta_{ab}(0, 1)$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>0&lt;/td>
&lt;td>$\theta_{const} + \theta_{p}(1) + \theta_{q}(0) + \theta_{ab}(1, 0)$&lt;/td>
&lt;td>$(\theta_{const} + \delta) + (\theta_{p}(1) - \delta) + \theta_{q}(0) + \theta_{ab}(1, 0)$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>1&lt;/td>
&lt;td>$\theta_{const} + \theta_{p}(1) + \theta_{q}(1) + \theta_{ab}(1, 1)$&lt;/td>
&lt;td>$(\theta_{const} + \delta) + (\theta_{p}(1) - \delta) + \theta_{q}(1) + \theta_{ab}(1, 1)$&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h1 id="4-一般の関数の場合">4. 一般の関数の場合
&lt;/h1>&lt;p>関数に何も仮定を置かない場合は $E(\bold x)$ の最小化は NP-hard なので，minimum s-t cut 問題に帰着できない場合があります．&lt;br>
この場合でも最適解はだせなくても問題を解けるだけ解く QPBO 法というアルゴリズムがあります&lt;sup id="fnref:5">&lt;a href="#fn:5" class="footnote-ref" role="doc-noteref">5&lt;/a>&lt;/sup>．QPBO 法は解として $x_p = \lbrace 0, 1, \emptyset \rbrace$ のいずれかを与えます．$\emptyset$ は解が不明であることを表します．$x_p$ に $0$ か $1$ の値が与えられたとき，$x_p$ はラベル付けされたといいます．&lt;br>
このアルゴリズムは次のような性質があります．&lt;/p>
&lt;ol>
&lt;li>アルゴリズムの出力を $\bold x$ とする．完全にラベル付けされた任意の解 $\bold y$ があるとき，以下のように $\bold z$ を定めると常に $E(\bold z) \le E(\bold y)$ を満たす．&lt;/li>
&lt;/ol>
$$
z_p = \left\{
\begin{array}{ll}
x_p &amp; \text{if} \space x_p \in \lbrace 0, 1 \rbrace \\
y_p &amp; \text{if} \space x_p = \emptyset
\end{array}
\right.
$$&lt;ol start="2">
&lt;li>関数のすべての項が劣モジュラのとき最適解が求まる．&lt;/li>
&lt;li>アルゴリズムはフリップ操作に対して不変である．&lt;/li>
&lt;/ol>
&lt;p>性質 1 で $\bold y$ に最適解を選べば $\bold x$ は常に最適解の一部となることがわかります．&lt;br>
競プロで役に立つのは性質 2 と 3 です．この 2 つの性質から，すべての項を劣モジュラにするようなフリップ操作がある場合に QPBO 法は最適解を求めることがわかります．&lt;/p>
&lt;p>QPBO 法を説明します．&lt;br>
以降は表記が煩雑になるのを避けるためこの節では関数値を以下のように表記することがあります．&lt;/p>
&lt;div style="display: flex; gap: 20px;">
&lt;div>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>$\theta_{p}(0)$&lt;/td>
&lt;td>$\theta_{p;0}$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$\theta_{p}(1)$&lt;/td>
&lt;td>$\theta_{p;1}$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$\theta_{pq}(0,0)$&lt;/td>
&lt;td>$\theta_{pq;00}$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$\theta_{pq}(0,1)$&lt;/td>
&lt;td>$\theta_{pq;01}$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$\theta_{pq}(1,0)$&lt;/td>
&lt;td>$\theta_{pq;10}$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$\theta_{pq}(1,1)$&lt;/td>
&lt;td>$\theta_{pq;11}$&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/div>
&lt;/div>
&lt;p>各変数 $x_p$ に対して，$x_{\bar{p}} = 1 - x_{p}$ を導入し，$E(\bold x) = \sum \theta_{p}(x_p) + \sum \theta_{pq}(x_p, x_q)$ を変形します．&lt;/p>
$$
\begin{alignedat}{2}
E(\bold x)
&amp;= \theta_{const} + \sum \theta_{p}(x_p)
&amp;&amp;+ \sum \theta_{pq}(x_p, x_q) \\
&amp;= \theta_{const} + \sum \big(
\theta_{p;1} x_{p} + \theta_{p;0}(1 - x_{p})
\big) \\
&amp;\quad &amp;&amp;+
\sum \big(
\theta_{pq;00} (1 - x_{p})(1 - x_{q}) \\
&amp;\quad &amp;&amp;\quad +
\theta_{pq;01} (1 - x_{p}) x_{q} \\
&amp;\quad &amp;&amp;\quad +
\theta_{pq;10} x_{p}(1 - x_{q}) \\
&amp;\quad &amp;&amp;\quad +
\theta_{pq;11} x_{p} x_{q}
\big) \\
&amp;= \theta_{const} + \sum \bigg(
\frac{\theta_{p;1}}{2}(x_p + (1 - x_{\bar{p}})) &amp;&amp;
+ \frac{\theta_{p;0}}{2}(x_{\bar{p}} + (1 - x_p))
\bigg) \\
&amp;\quad &amp;&amp;+
\sum \bigg(
\frac{\theta_{pq;00}}{2} \big(x_{\bar{p}} (1 - x_q) + (1 - x_p) x_{\bar{q}} \big) \\
&amp;\quad &amp;&amp;\quad +
\frac{\theta_{pq;01}}{2} \big((1 - x_p) x_q + x_{\bar{p}} (1 - x_{\bar{q}}) \big) \\
&amp;\quad &amp;&amp;\quad +
\frac{\theta_{pq;11}}{2} \big(x_p (1 - x_{\bar{q}}) + (1 - x_{\bar{p}}) x_q \big) \\
&amp;\quad &amp;&amp;\quad +
\frac{\theta_{pq;10}}{2} \big(x_p (1 - x_q) + (1 - x_{\bar{p}}) x_{\bar{q}} \big)
\bigg)
\end{alignedat}
$$&lt;p>ここで，$x_{\bar{p}} = 1 - x_p$ という制約を緩和し，$x_p$ と $x_{\bar{p}}$ が独立に値をとれる緩和問題を考えます．&lt;br>
各変数の係数を比較すると下の関数に分割できることがわかります．
再パラメータ化をしてから関数を分割することですべての関数値が $0$ 以上であることが保証されます．これらの関数は劣モジュラ関数なので「&lt;a class="link" href="#3-%e5%8a%a3%e3%83%a2%e3%82%b8%e3%83%a5%e3%83%a9%e9%96%a2%e6%95%b0%e3%81%ae%e5%a0%b4%e5%90%88" >3. 劣モジュラ関数の場合&lt;/a>」に帰着することができます．&lt;/p>
&lt;div style="display: flex; gap: 20px;">
&lt;div>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>$x_p$&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>0&lt;/td>
&lt;td>$\frac{1}{2}\theta_{p;0}$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>$\frac{1}{2}\theta_{p;1}$&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/div>
&lt;div>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>$x_{\bar{p}}$&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>0&lt;/td>
&lt;td>$\frac{1}{2}\theta_{p;1}$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>$\frac{1}{2}\theta_{p;0}$&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/div>
&lt;/div>
&lt;div style="display: flex; gap: 20px;">
&lt;div>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>$x_p$&lt;/th>
&lt;th>$x_q$&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>0&lt;/td>
&lt;td>0&lt;/td>
&lt;td>0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0&lt;/td>
&lt;td>1&lt;/td>
&lt;td>$\frac{1}{2}\theta_{pq;01}$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>0&lt;/td>
&lt;td>$\frac{1}{2}\theta_{pq;10}$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>1&lt;/td>
&lt;td>0&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/div>
&lt;div>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>$x_p$&lt;/th>
&lt;th>$x_{\bar{q}}$&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>0&lt;/td>
&lt;td>0&lt;/td>
&lt;td>0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0&lt;/td>
&lt;td>1&lt;/td>
&lt;td>$\frac{1}{2}\theta_{pq;00}$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>0&lt;/td>
&lt;td>$\frac{1}{2}\theta_{pq;11}$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>1&lt;/td>
&lt;td>0&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/div>
&lt;div>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>$x_{\bar{p}}$&lt;/th>
&lt;th>$x_q$&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>0&lt;/td>
&lt;td>0&lt;/td>
&lt;td>0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0&lt;/td>
&lt;td>1&lt;/td>
&lt;td>$\frac{1}{2}\theta_{pq;11}$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>0&lt;/td>
&lt;td>$\frac{1}{2}\theta_{pq;00}$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>1&lt;/td>
&lt;td>0&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/div>
&lt;div>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>$x_{\bar{p}}$&lt;/th>
&lt;th>$x_{\bar{q}}$&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>0&lt;/td>
&lt;td>0&lt;/td>
&lt;td>0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0&lt;/td>
&lt;td>1&lt;/td>
&lt;td>$\frac{1}{2}\theta_{pq;01}$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>0&lt;/td>
&lt;td>$\frac{1}{2}\theta_{pq;10}$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>1&lt;/td>
&lt;td>0&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/div>
&lt;/div>
&lt;p>上記関数について，ルールに従ってグラフを構築します．
整理すると以下のルールに従ってグラフを構築すればいいことがわかります．&lt;/p>
&lt;div style="display: flex; gap: 20px;">
&lt;div>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>$\theta$&lt;/th>
&lt;th>edge&lt;/th>
&lt;th>capacity&lt;sup id="fnref:6">&lt;a href="#fn:6" class="footnote-ref" role="doc-noteref">6&lt;/a>&lt;/sup>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>$\theta_{p;0}$&lt;/td>
&lt;td>$(p \rightarrow t), (s \rightarrow \bar p)$&lt;/td>
&lt;td>$\frac{1}{2} \theta_{p;0}$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$\theta_{p;1}$&lt;/td>
&lt;td>$(s \rightarrow p), (\bar p \rightarrow t)$&lt;/td>
&lt;td>$\frac{1}{2} \theta_{p;1}$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$\theta_{pq;01}$&lt;/td>
&lt;td>$(p \rightarrow q), (\bar q \rightarrow \bar p)$&lt;/td>
&lt;td>$\frac{1}{2} \theta_{pq;01}$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$\theta_{pq;10}$&lt;/td>
&lt;td>$(q \rightarrow p), (\bar p \rightarrow \bar q)$&lt;/td>
&lt;td>$\frac{1}{2} \theta_{pq;10}$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$\theta_{pq;00}$&lt;/td>
&lt;td>$(p \rightarrow \bar q), (q \rightarrow \bar p)$&lt;/td>
&lt;td>$\frac{1}{2} \theta_{pq;00}$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$\theta_{pq;11}$&lt;/td>
&lt;td>$(\bar q \rightarrow p), (\bar p \rightarrow q)$&lt;/td>
&lt;td>$\frac{1}{2} \theta_{pq;11}$&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/div>
&lt;/div>
&lt;p>このグラフの s-t minimum cut を計算します．各変数の値は，$S$ に属する場合は 0，$T$ に属する場合は 1 をとります．ただし，$x_{\bar{p}} = 1 - x_{p}$ という制約を満たす必要があります．よって，$\bold x$ は次のように構成されます．&lt;/p>
$$
x_{p} = \left\{
\begin{array}{ll}
0 &amp; \text{if} \space p \in S, \bar p \in T \\
1 &amp; \text{if} \space p \in T, \bar p \in S \\
\emptyset &amp; \text{otherwise}
\end{array}
\right.
$$&lt;p>具体例として，変数が $a$ と $b$ の 2 つだけの場合を考えます．&lt;br>
各変数の値に対応する $E(\bold x) = \theta_a(a) + \theta_b(b) + \theta_{ab}(a, b)$ の値は以下のようになります．&lt;/p>
&lt;div style="display: flex; gap: 20px;">
&lt;div>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>a&lt;/th>
&lt;th>b&lt;/th>
&lt;th>$E(\bold x)$&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>0&lt;/td>
&lt;td>0&lt;/td>
&lt;td>$\theta_{a}(0) + \theta_{b}(0) + \theta_{ab}(0, 0)$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0&lt;/td>
&lt;td>1&lt;/td>
&lt;td>$\theta_{a}(0) + \theta_{b}(1) + \theta_{ab}(0, 1)$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>0&lt;/td>
&lt;td>$\theta_{a}(1) + \theta_{b}(0) + \theta_{ab}(1, 0)$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>1&lt;/td>
&lt;td>$\theta_{a}(1) + \theta_{b}(1) + \theta_{ab}(1, 1)$&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/div>
&lt;/div>
&lt;p>対応するグラフは以下のようになります．表記が煩雑になるので図では $\frac{1}{2}$ を除外しています．このグラフの s-t cut の例をいくつか見ていきます．&lt;/p>
&lt;img src="images/general_sample_ab.png" width="50%">
&lt;p>$S = \lbrace s, a, b \rbrace$ とします．この s-t cut の容量は $\frac{1}{2} (\theta_{a}(0) + \theta_{a}(0) + \theta_{b}(0) + \theta_{b}(0) + \theta_{ab}(0, 0) + \theta_{ab}(0, 0))$ です．&lt;br>
この値は $a = 0$，$b = 0$ としたときの $E(\bold x)$ の目的関数と一致します．&lt;/p>
&lt;img src="images/general_sample_ab_1.png" width="50%">
&lt;p>$S = \lbrace s, a \rbrace$ とします．この s-t cut の容量は $\frac{1}{2} (\theta_{a}(0) + \theta_{a}(0) + \theta_{b}(1) + \theta_{b}(1) + \theta_{ab}(0, 1) + \theta_{ab}(0, 1))$ です．&lt;br>
この値は $a = 0$，$b = 0$ としたときの $E(\bold x)$ の目的関数と一致します．&lt;/p>
&lt;img src="images/general_sample_ab_2.png" width="50%">
&lt;p>$S = \lbrace s, a, b, \bar{b} \rbrace$ とします．この場合，$a = 0$，$b = \emptyset$ とし，$b$ のラベルは未定となります．&lt;/p>
&lt;img src="images/general_sample_ab_3.png" width="50%">
&lt;h1 id="5-問題">5. 問題
&lt;/h1>&lt;p>QPBO を使って競プロの問題を解いていきます．&lt;/p>
&lt;h2 id="arc085-e---mul">&lt;a class="link" href="https://atcoder.jp/contests/arc085/tasks/arc085_c" target="_blank" rel="noopener"
>ARC085 E - MUL&lt;/a>
&lt;/h2>&lt;blockquote>
&lt;p>宝石が $N$ 個あり，それぞれ $1,2,\cdots,N$ と数が書かれています。&lt;br>
あなたは，以下の操作を好きなだけ行うことが出来ます(一度も行わなくてもよいです)。&lt;/p>
&lt;ul>
&lt;li>正整数 $x$ を選ぶ。$x$ の倍数が書かれた宝石を全て叩き割る。&lt;/li>
&lt;/ul>
&lt;p>そして，$i$ が書かれていた宝石が割られずに残っていた場合，$a_i$ 円貰います。 ただし，この $a_i$ は負の場合もあり，その場合はお金を払わなくてはいけません。&lt;br>
うまく操作を行った時，あなたは最大で何円お金を貰えるでしょうか？&lt;/p>&lt;/blockquote>
&lt;p>まず変数を定義します．&lt;br>
宝石 $i$ が残っているかどうかを $x_i$ で表します．宝石が割る場合 $1$ を，残す場合は $0$ をとります．&lt;/p>
&lt;p>次に関数を定義します．&lt;br>
QPBO は目的関数値の最小化を目指すのでコストがいくらかかるかで表します．&lt;br>
宝石 $i$ が残っている場合 $a_i$ 円貰えます．これは $-a_i$ 円のコストを払うということなので，次のように定義できます．&lt;/p>
&lt;ul>
&lt;li>$\theta_{i}(0) = -a_i$&lt;/li>
&lt;li>$\theta_{i}(1) = 0$&lt;/li>
&lt;/ul>
&lt;p>また，宝石 $i$ を割るにもかかわらず $i$ で割り切れる値が書かれた宝石 $j$ を残すことは許されないので，この場合は無限のコストがかかるとします．よって，次のように定義できます．&lt;/p>
&lt;ul>
&lt;li>$\theta_{ij}(0, 0) = 0$&lt;/li>
&lt;li>$\theta_{ij}(0, 1) = 0$&lt;/li>
&lt;li>$\theta_{ij}(1, 0) = \infty$&lt;/li>
&lt;li>$\theta_{ij}(1, 1) = 0$&lt;/li>
&lt;/ul>
&lt;p>この関数は $\theta_{ij}(0, 1) + \theta_{ij}(1, 0) \ge \theta_{ij}(0, 0) + \theta_{ij}(1, 1)$ を満たしているので劣モジュラ関数です．&lt;br>
あとは，すべての $i$ と $i$ で割り切れる $j$ について上記関数を定義すれば問題を解くことができます．&lt;/p>
&lt;p>&lt;a class="link" href="https://atcoder.jp/contests/arc085/submissions/61474030" target="_blank" rel="noopener"
>提出コード&lt;/a>&lt;/p>
&lt;h2 id="abc193-f---zebraness">&lt;a class="link" href="https://atcoder.jp/contests/abc193/tasks/abc193_f" target="_blank" rel="noopener"
>ABC193 F - Zebraness&lt;/a>
&lt;/h2>&lt;blockquote>
&lt;p>縦 $N$ マス、横 $N$ マスのマス目があります。上から $i$ 行目、左から $j$ 列目のマスをマス $(i,j)$ と表すことにします。 マス $(i,j)$ の色の情報が文字 $c_{i,j}$ により与えられます。&lt;br>
$B$ はマスが黒で塗られていることを、 $W$ はマスが白で塗られていることを、 $?$ はマスにまだ色が塗られていないことを表します。&lt;br>
高橋くんは、まだ色が塗られていないマスをそれぞれ黒または白で塗り、白黒のマス目を作ります。マス目のしまうま度を、辺で接する黒マスと白マスの組の個数と定義します。高橋くんが達成できるしまうま度の最大値を求めてください。&lt;/p>&lt;/blockquote>
&lt;p>まず変数を定義します．&lt;br>
マスを $(i, j)$ で表すとすると関数が見にくいので $p = i \times N + j$ で表します．
マス $p$ の色を変数 $x_{p}$ で表します．白の場合 $0$ をとり，黒の場合 $1$ をとります．&lt;/p>
&lt;p>次に関数を定義します．&lt;br>
与えられている色の変更はできないので白から黒や黒から白に変更すると無限のコストがかかるとします．次のように定義できます．&lt;/p>
&lt;ul>
&lt;li>
&lt;p>マス $p$ の色が黒の場合&lt;/p>
&lt;ul>
&lt;li>$\theta_{p}(0) = \infty$&lt;/li>
&lt;li>$\theta_{p}(1) = 0$&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>マス $p$ の色が白の場合&lt;/p>
&lt;ul>
&lt;li>$\theta_{p}(0) = 0$&lt;/li>
&lt;li>$\theta_{p}(1) = \infty$&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>マス $p$ と辺で接するマス $q$ が異なる色だと -1 のコストがかかります．&lt;/p>
&lt;ul>
&lt;li>$\theta_{pq}(0, 0) = 0$&lt;/li>
&lt;li>$\theta_{pq}(0, 1) = -1$&lt;/li>
&lt;li>$\theta_{pq}(1, 0) = -1$&lt;/li>
&lt;li>$\theta_{pq}(1, 1) = 0$&lt;/li>
&lt;/ul>
&lt;p>これは劣モジュラ関数ではないのですが，変数フリップすることで劣モジュラ関数にすることができます．
QPBO 法では変数フリップを考慮しなくていいのでそのまま定義することができます．&lt;/p>
&lt;p>&lt;a class="link" href="https://atcoder.jp/contests/abc193/submissions/61474153" target="_blank" rel="noopener"
>提出コード&lt;/a>&lt;/p>
&lt;h2 id="その他の問題">その他の問題
&lt;/h2>&lt;ul>
&lt;li>&lt;a class="link" href="https://yukicoder.me/problems/no/2713" target="_blank" rel="noopener"
>No.2713 Just Solitaire&lt;/a>
&lt;ul>
&lt;li>&lt;a class="link" href="https://yukicoder.me/submissions/1034571" target="_blank" rel="noopener"
>提出コード&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a class="link" href="https://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2903" target="_blank" rel="noopener"
>AOJ - Board&lt;/a>
&lt;ul>
&lt;li>&lt;a class="link" href="https://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=10082476#1" target="_blank" rel="noopener"
>提出コード&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a class="link" href="https://onlinejudge.u-aizu.ac.jp/challenges/sources/UOA/UAPC/3058" target="_blank" rel="noopener"
>AOJ - Ghost&lt;/a>
&lt;ul>
&lt;li>&lt;a class="link" href="https://onlinejudge.u-aizu.ac.jp/solutions/problem/3058/review/10082488/MitI7/C&amp;#43;&amp;#43;23" target="_blank" rel="noopener"
>提出コード&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a class="link" href="https://atcoder.jp/contests/typical90/tasks/typical90_an" target="_blank" rel="noopener"
>競プロ典型 90 問 040 - Get More Money（★7）&lt;/a>
&lt;ul>
&lt;li>&lt;a class="link" href="https://atcoder.jp/contests/typical90/submissions/61474485" target="_blank" rel="noopener"
>提出コード&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a class="link" href="https://atcoder.jp/contests/abc259/tasks/abc259_g" target="_blank" rel="noopener"
>ABC259 G - Grid Card Game&lt;/a>
&lt;ul>
&lt;li>&lt;a class="link" href="https://atcoder.jp/contests/abc259/submissions/61474556" target="_blank" rel="noopener"
>提出コード&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="参考">参考
&lt;/h1>&lt;ul>
&lt;li>&lt;a class="link" href="https://ieeexplore.ieee.org/document/4204169" target="_blank" rel="noopener"
>Minimizing non-submodular functions with graph cuts – a review&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://www.kspub.co.jp/book/detail/1529090.html" target="_blank" rel="noopener"
>劣モジュラ最適化と機械学習&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://en.wikipedia.org/wiki/Graph_cut_optimization" target="_blank" rel="noopener"
>Graph cut optimization&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://en.wikipedia.org/wiki/Quadratic_pseudo-Boolean_optimization" target="_blank" rel="noopener"
>Quadratic pseudo-Boolean optimization&lt;/a>&lt;/li>
&lt;/ul>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>たぶんです．できない例があったら教えてください&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2">
&lt;p>この数値例は&lt;a class="link" href="https://ja.wikipedia.org/wiki/%E6%9C%80%E5%A4%A7%E3%83%95%E3%83%AD%E3%83%BC%E6%9C%80%E5%B0%8F%E3%82%AB%E3%83%83%E3%83%88%E5%AE%9A%E7%90%86#/media/%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB:Max_flow.svg" target="_blank" rel="noopener"
>最大フロー最小カット定理&lt;/a>から引用しています&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:3">
&lt;p>標準形は一意に定まるとは限りません&amp;#160;&lt;a href="#fnref:3" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:4">
&lt;p>単純な関数の場合は劣モジュラ関数を(ほぼ)標準化したものでした．厳密には $min \lbrace \theta_{p;0}, \theta_{p;1} \rbrace = 0$ を満たしていませんが．&amp;#160;&lt;a href="#fnref:4" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:5">
&lt;p>Minimizing non-submodular functions with graph cuts – a review&amp;#160;&lt;a href="#fnref:5" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:6">
&lt;p>実装では容量に $\frac{1}{2}$ をかけるのではなく，最後に目的関数値に $\frac{1}{2}$ を掛ければいいです&amp;#160;&lt;a href="#fnref:6" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>Kinesis Advantage 360 Pro の設定</title><link>https://miti-7.github.io/post/kinesis-advantage-360-pro-%E3%81%AE%E8%A8%AD%E5%AE%9A/</link><pubDate>Sat, 26 Oct 2024 00:00:00 +0900</pubDate><guid>https://miti-7.github.io/post/kinesis-advantage-360-pro-%E3%81%AE%E8%A8%AD%E5%AE%9A/</guid><description>&lt;h2 id="設定">設定
&lt;/h2>&lt;p>Kinesis Advantage 360 Pro の設定をメモしておきます&lt;/p>
&lt;h2 id="バックライト">バックライト
&lt;/h2>&lt;p>デフォルトだと「Mod + Enter」で on/off，「Mod + ↑/↓」で明るさの調整ができる&lt;br>
バックライトをつけておくとすぐにバッテリーがなくなるらしいので off にした&lt;/p>
&lt;h2 id="keymap">Keymap
&lt;/h2>&lt;p>&lt;a class="link" href="https://kinesiscorporation.github.io/Adv360-Pro-GUI/" target="_blank" rel="noopener"
>Kinesis ADV360 Pro Keymap Editor&lt;/a> で設定できる．&lt;/p>
&lt;img src="images/Layer1.png" width="100%">
&lt;ul>
&lt;li>Windows キーはあまりつかわないので ALT を配置
&lt;ul>
&lt;li>代わりに Caps を Windwos キーにした&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>PgUp を ESC に，PgDn を 「CTRL + PG_DN」 にした
&lt;ul>
&lt;li>「CTRL + PG_DN」 で IME の切り替えをしているので&lt;/li>
&lt;li>「LC」を選ぶと，LCTRL + PG_DN を選択できる&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>① と ② は迷い中&lt;/li>
&lt;li>③ と ④ に PG_UP と PG_DN を配置&lt;/li>
&lt;/ul>
&lt;img src="images/Layer2.png" width="100%">
&lt;ul>
&lt;li>キーキャップの数字とファンクションキーがずれていて迷うので数字と同じになるようにひとつずらした
&lt;ul>
&lt;li>F12 と F13 の位置がひどいことになった&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="バッテリー">バッテリー
&lt;/h2>&lt;ul>
&lt;li>バックライトをオフにしていると 数ヶ月はもつらしい&lt;/li>
&lt;li>「Mod + ④」で充電レベルを確認できる
&lt;ul>
&lt;li>Green: 80% 以上&lt;/li>
&lt;li>Yellow: 51% - 79%&lt;/li>
&lt;li>Orange: 21% - 50%&lt;/li>
&lt;li>Red: 20% 以下&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="高さ">高さ
&lt;/h2>&lt;p>LOW/MEDIUM/HIGH の 3 段階に調整できる&lt;br>
今は MEDIUM を使っている&lt;/p>
&lt;h2 id="bluetooth-の接続や遅延">Bluetooth の接続や遅延
&lt;/h2>&lt;p>特に問題なく使えている&lt;/p>
&lt;h2 id="参考">参考
&lt;/h2>&lt;ul>
&lt;li>&lt;a class="link" href="https://kinesis-ergo.com/support/kb360pro/" target="_blank" rel="noopener"
>Advantage 360 Professional (ZMK Bluetooth) Support Resources&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>最小費用流問題の最短路繰り返し法</title><link>https://miti-7.github.io/post/%E6%9C%80%E5%B0%8F%E8%B2%BB%E7%94%A8%E6%B5%81%E5%95%8F%E9%A1%8C%E3%81%AE%E6%9C%80%E7%9F%AD%E8%B7%AF%E7%B9%B0%E3%82%8A%E8%BF%94%E3%81%97%E6%B3%95/</link><pubDate>Mon, 21 Oct 2024 00:00:00 +0900</pubDate><guid>https://miti-7.github.io/post/%E6%9C%80%E5%B0%8F%E8%B2%BB%E7%94%A8%E6%B5%81%E5%95%8F%E9%A1%8C%E3%81%AE%E6%9C%80%E7%9F%AD%E8%B7%AF%E7%B9%B0%E3%82%8A%E8%BF%94%E3%81%97%E6%B3%95/</guid><description>&lt;h2 id="最小費用流問題minimum-cost-flow-problem">最小費用流問題(Minimum Cost Flow Problem)
&lt;/h2>&lt;p>$N$ を頂点の集合，$A$ を辺の集合，$c_{ij}$ を辺 $(i, j)$ の単位流量あたりのコスト，$x_{ij}$ を辺 $(i, j)$ の流量，$b_i$ を頂点 i の需要/供給量，$l$ を辺の下限容量，$u$ を辺の上限容量としたとき，最小費用流問題（以下 MCFP）は以下のように定式化されます．&lt;br>
1 つめの制約を流量保存則と呼び，第一項は頂点 i から出る流量，第二項は頂点 i に入る流量を表します．
2 つめの制約を容量制約と呼びます．&lt;/p>
$$
\begin{aligned}
&amp;\text{minimize} &amp;&amp; \sum_{(i, j) \in A} c_{ij} x_{ij} \\
&amp;\text{subject to}
&amp;&amp; \sum_{j:(i, j) \in A} x_{ij} - \sum_{j:(j,i) \in A} x_{ji} = b_i &amp;&amp; \forall i \in N \\
&amp; &amp;&amp; l_{ij} \le x_{ij} \leq u_{ij} &amp;&amp; \forall (i, j) \in A
\end{aligned}
$$&lt;p>以下ではコスト，流量，需要/供給，下限容量，上限容量はすべて整数とします．また，$\sum_{i \in N} b_i = 0$，コストを非負，下限容量を 0 とします．&lt;/p>
&lt;h2 id="用語定義">用語・定義
&lt;/h2>&lt;ul>
&lt;li>
&lt;p>pseudoflow&lt;/p>
&lt;ul>
&lt;li>容量制約を満たす flow を pseudoflow と呼びます．流量保存則には違反していてもかまいません．&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>残余容量&lt;/p>
&lt;ul>
&lt;li>$r_{ij} = u_{ij} - x_{ij}$ を辺 (i, j) の残余容量と呼びます．&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>imbalance&lt;/p>
&lt;ul>
&lt;li>pseudoflow x に対し，頂点 i の imbalance を次のように定義します．&lt;br>
$e(i) = b(i) + \sum_{j:(j, i) \in A} x_{ji} - \sum_{j:(i,j) \in A} x_{ij}$&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>reduced cost&lt;/p>
&lt;ul>
&lt;li>各頂点のポテンシャル $\pi$ が与えられたとき，$c_{ij}^{\pi} = c_{ij} - \pi(i) + \pi(j)$ を辺 (i, j) の reduced cost と呼びます．&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="reduced-cost-最適性">Reduced Cost 最適性
&lt;/h2>&lt;p>最小費用流問題の実行可能な flow $x$ が最適であるための必要十分条件は，残余ネットワークのすべての辺 (i, j) に対して$c^{\pi}_{ij} \ge 0$ となるポテンシャル $\pi$ が存在することです．&lt;/p>
&lt;h2 id="最短路繰り返し法successive-shortest-path-algorithm">最短路繰り返し法(Successive Shortest Path Algorithm)
&lt;/h2>&lt;p>最短路繰り返し法は容量制約を満たすが流量保存則に違反する pseudoflow x から開始します．&lt;br>
アルゴリズムの各ステップでは reduced cost 最適性を維持しつつ，主問題の実行不能解 x を実行可能解に近づけます．&lt;br>
具体的には，残余ネットワーク上で$e(k) \gt 0$ である頂点 k から $e(l) \lt 0$ である頂点 l へ，最短路に沿って flow を流すことで実行可能性を高めていきます．&lt;br>
実行可能解が得られたときアルゴリズムは終了します．&lt;/p>
&lt;p>最短路繰り返し法の流れは以下のようになります&lt;/p>
&lt;ul>
&lt;li>初期解の構築
&lt;ul>
&lt;li>$x = 0$，$\pi = 0$ とする&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>実行可能解が得られるまで以下を繰り返す
&lt;ul>
&lt;li>reduced cost を距離とする残余ネットワーク上で，$e(k) \gt 0$ である頂点 k から各頂点への最短路を求める
&lt;ul>
&lt;li>$P$ を k から各頂点への最短路，$d$ を最短距離とする&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>ポテンシャルの更新
&lt;ul>
&lt;li>$\pi^{\prime} = \pi - d$&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>flow と imbalance の更新
&lt;ul>
&lt;li>$\delta = min[e(k), min(r_{ij} : (i,j) \in P)]$とし，$P$ に沿って辺の flow を $\delta$ 増加する&lt;/li>
&lt;li>$e(k) = e(k) - \delta$，$e(l) = e(l) + \delta$ と更新する&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>次節からアルゴリズムの各ステップで常に reduced cost 最適性を維持することを確認していきます．&lt;/p>
&lt;h2 id="初期解の構築">初期解の構築
&lt;/h2>&lt;p>初期解が容量制約と reduced cost 最適性を満たすことを確認します．&lt;br>
仮定より，下限容量は 0 のため $x = 0$ は容量制約を満たします．&lt;br>
$\pi = 0$ のため $c_{ij}^{\pi} = c_{ij}$ です．辺のコストはすべて非負を仮定しているため $c_{ij}^{\pi} \ge 0$ となり reduced cost 最適性を満たします．&lt;/p>
&lt;h2 id="ポテンシャルの更新">ポテンシャルの更新
&lt;/h2>&lt;p>ある $x$ に対し $\pi$ が reduced cost 最適性を満たしているとき，ポテンシャルを $\pi^{\prime} = \pi - d$ と更新しても reduced cost 最適性を満たすことを示します&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>．&lt;/p>
&lt;p>$d$ は reduced cost を距離とした残余ネットワーク上での頂点 k から各頂点への最短距離であるため，各辺 (i, j) は $d(j) \le d(i) + c_{ij}^{\pi}$ を満たします．&lt;/p>
&lt;p>上の式に $c_{ij}^{\pi} = c_{ij} - \pi(i) + \pi(j)$ を代入します．&lt;br>
$d(j) \le d(i) + c_{ij} - \pi(i) + \pi(j)$&lt;/p>
&lt;p>$d(j)$を移項し，頂点ごとにまとめます．&lt;br>
$c_{ij} - (\pi(i) - d(i)) + (\pi(j) - d(j)) \ge 0$&lt;/p>
&lt;p>ポテンシャルの更新の仕方から以下が成り立ちます．&lt;br>
$c_{ij} - \pi^{\prime}(i) + \pi^{\prime}(j) = c^{\pi_{ij}^{\prime}} \ge 0$&lt;/p>
&lt;p>よって，ポテンシャルを $\pi^{\prime} = \pi - d$ と更新しても reduced cost 最適性を満たすことがわかりました．&lt;/p>
&lt;h2 id="flow-の更新">flow の更新
&lt;/h2>&lt;p>最短路に沿って flow を更新したとき reduced cost 最適性を満たすことを確認します．&lt;/p>
&lt;p>まず，ポテンシャルを $\pi^{\prime} = \pi - d$ と更新したとき，頂点 k から各頂点への最短路の辺の reduced cost が 0 となることを確認します．&lt;br>
頂点 k から頂点 l の最短路を考えます．最短路であるため，この経路の各辺は $d(j) = d(i) + c_{ij}^{\pi}$ を満たします．&lt;/p>
&lt;p>上の式に $c_{ij}^{\pi} = c_{ij} - \pi(i) + \pi(j)$ を代入します．&lt;br>
$d(j) = d(i) + c_{ij} - \pi(i) + \pi(j)$&lt;/p>
&lt;p>$d(j)$ を移項し，頂点ごとにまとめます．&lt;br>
$c_{ij} - (\pi(i) - d(i)) + (\pi(j) - d(j)) = 0$&lt;/p>
&lt;p>ポテンシャルの更新の仕方から以下が成り立ちます．&lt;br>
$c_{ij} - \pi^{\prime}(i) + \pi^{\prime}(j) = c^{\pi_{ij}^{\prime}} = 0$&lt;/p>
&lt;p>よって，頂点 k から各頂点への最短路の辺の reduced cost は 0 となることがわかりました．&lt;/p>
&lt;p>次に，flow を更新したとき reduced cost 最適性を満たすことを確認します．&lt;br>
$\delta = min[e(s), min(r_{ij} : (i,j) \in P)]$ とし，最短路に沿って辺の flow を更新します．&lt;br>
$\delta$ 選び方から，このように flow を更新しても容量制約を満たします．また，reduced cost が 0 であるため，辺に flow を流すことで残余ネットワーク上に逆辺が生じたとしても reduced cost 最適性には違反しません．&lt;br>
よって，最短路に沿って flow を更新したとき reduced cost 最適性を満たすことがわかりました．&lt;/p>
&lt;h2 id="計算量">計算量
&lt;/h2>&lt;p>$U$ を最大の供給量，$C$ をコストの最大値とします．&lt;br>
アルゴリズムは各イテレーションで最短路問題を解き，供給量は厳密に減少します．
よって，$nU$ 回のイテレーションでアルゴリズムは終了します．最短路問題に 2 分ヒープを使った dijkstra 法を使うとすると $O((m + n) \log n)$ となります．&lt;br>
よって，全体で $O(nU (m + n) \log n)$ となります．&lt;/p>
&lt;h2 id="補足ポテンシャルの更新の改善">補足：ポテンシャルの更新の改善
&lt;/h2>&lt;p>dijkstra 法で最短距離を求めているとします．&lt;br>
上記のアルゴリズムの説明では頂点 k からすべての頂点に対する最短路を求めましたが，$e(l) \lt 0$ のような頂点を見つけたとき探索を終了したとします．最短距離が確定した頂点を permanently labeled node，まだ確定していない頂点を temporarily labeled node と呼びます．&lt;br>
このとき，ポテンシャルは以下のように更新することができます．&lt;/p>
$$
\pi^{\prime} = \left\{
\begin{array}{ll}
\pi_{i} - d_{i} &amp; \text{node i is permanently labeled}\\
\pi_{i} - d_{l} &amp; \text{node i is temporarily labeled}
\end{array}
\right.
$$&lt;details>
&lt;summary>証明&lt;/summary>
$S$ を permanently labeled node の集合，$\bar{S}$ を temporarily labeled node の集合とします．
頂点 i と頂点 j が S と T のどちらに属するかの 4 つ場合について，ポテンシャルが $\pi$ から $\pi^{\prime}$ に変更されたときを考えます．
&lt;h3 id="1-i-in-s-j-in-s-の場合">1. $i \in S, j \in S$ の場合
&lt;/h3>&lt;p>「ポテンシャルの更新」の節と同じです．&lt;/p>
&lt;h3 id="2-i-in-s-j-in-bars-の場合">2. $i \in S, j \in \bar{S}$ の場合
&lt;/h3>&lt;p>$c^{\pi^{\prime}} = c_{ij}^{\pi} + d(i) - d(l)$ と更新されます．&lt;br>
頂点 j は最短距離と確定していないため，$d(l) \le d(j)$ です．&lt;br>
また，頂点 i は最短距離と確定しているため，dijkstra 法のアルゴリズムから $d(j) \le d(i) + c_{ij}^{\pi}$ が成り立ちます．&lt;br>
よって，$d(l) \le d(i) + c_{ij}^{\pi}$ であるため $c_{ij}^{\pi^{\prime}} \ge 0$ を満たします．&lt;/p>
&lt;h3 id="3-i-in-bars-j-in-s-の場合">3. $i \in \bar{S}, j \in S$ の場合
&lt;/h3>&lt;p>$c^{\pi^{\prime}} = c_{ij}^{\pi} + d(l) - d(j)$ と更新されます．&lt;br>
頂点 j は最短距離と確定しているため，$d(j) \le d(l)$ です．&lt;br>
よって，$c_{ij}^{\pi^{\prime}} \ge 0$ を満たします．&lt;/p>
&lt;h3 id="4-i-in-bars-j-in-bars-の場合">4. $i \in \bar{S}, j \in \bar{S}$ の場合
&lt;/h3>&lt;p>$c^{\pi^{\prime}} = c_{ij}^{\pi} + d(l) - d(l)$ と更新されます．&lt;br>
よって，$c_{ij}^{\pi} \ge 0$ を満たします．&lt;/p>
&lt;/details>
&lt;p>また，すべてのポテンシャルに定数を加算しても reduced cost 最適性に影響はないため，全体に $d(l)$ を加算することで以下のように更新することもできます．&lt;/p>
$$
\pi^{\prime} = \left\{
\begin{array}{ll}
\pi_{i} - d_{i} + d_{l} &amp; \text{node i is permanently labeled}\\
\pi_{i} &amp; \text{node i is temporarily labeled}
\end{array}
\right.
$$&lt;h2 id="参考">参考
&lt;/h2>&lt;ul>
&lt;li>&lt;a class="link" href="https://www.amazon.co.jp/dp/1292042702" target="_blank" rel="noopener"
>Network Flows: Pearson New International Edition&lt;/a>&lt;/li>
&lt;/ul>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>すべての頂点の距離が定まることを仮定しています．&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>最短路問題の最適性条件と reduced arc length</title><link>https://miti-7.github.io/post/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%95%8F%E9%A1%8C%E3%81%AE%E6%9C%80%E9%81%A9%E6%80%A7%E6%9D%A1%E4%BB%B6%E3%81%A8-reduced-arc-length/</link><pubDate>Tue, 17 Sep 2024 00:00:00 +0900</pubDate><guid>https://miti-7.github.io/post/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%95%8F%E9%A1%8C%E3%81%AE%E6%9C%80%E9%81%A9%E6%80%A7%E6%9D%A1%E4%BB%B6%E3%81%A8-reduced-arc-length/</guid><description>&lt;h2 id="最短路問題">最短路問題
&lt;/h2>&lt;p>有向グラフが与えられたとき，始点 s から各頂点への最短路を求める問題を単一始点最短路問題といいます．以下では，頂点数を $n$，辺数を $m$，各辺 (u, v) のコストを $c_{uv}$ で表します．また，グラフは強連結を仮定します．&lt;/p>
&lt;h2 id="最短路問題の最適性条件">最短路問題の最適性条件
&lt;/h2>&lt;p>頂点集合を $N$，辺集合を $A$，辺 (u, v) のコストを $c_{uv}$ とします．始点 s から各頂点 v への有向パスの距離の上界を $d(v)$ で表し，これを距離ラベルと呼びます．特に，$d(s) = 0$ です．各頂点 $v \in N$ について，$d(v)$ が始点 s から頂点 v の最短路の長さであるための必要十分条件は以下が成り立つことです．&lt;/p>
$$
\begin{equation}
d(v) \le d(u) + c_{uv} \quad \forall (u, v) \in A
\end{equation}
$$&lt;p>不等式 (1) は，各辺 $(u, v) \in A$ について，頂点 v への距離は頂点 u への距離 + $c_{uv}$ 以下であることを表しています．&lt;/p>
&lt;details>&lt;summary>証明&lt;/summary>
&lt;p>まず，必要条件であることを示します．&lt;br>
対偶をとり，$d(v) \gt d(u) + c_{uv}$ ならば，距離ラベルが最短路の長さではないことを示します．&lt;br>
$d(v) \gt d(u) + c_{uv}$ であるような辺があれば，頂点 u を経由することで頂点 v への距離を改善することができます．&lt;br>
したがって，距離ラベル $d$ は最短路の長さではありません．&lt;/p>
&lt;p>次に，十分条件であることを示します．&lt;br>
頂点 s から頂点 v への任意の有向パスが $s = i_1 \rightarrow i_2 \rightarrow &amp;hellip; \rightarrow i_{k-1} \rightarrow i_k = v$ であったとします．&lt;br>
不等式 (1) から以下の式がそれぞれ成り立ちます．&lt;/p>
$$
\begin{aligned}
d(v) =\; &amp; d(i_k) &amp;&amp; \le\; d(i_{k - 1}) &amp;&amp; +\; c_{i_{k - 1}i_{k}}, \\
&amp; d(i_{k - 1}) &amp;&amp; \le\; d(i_{k - 2}) &amp;&amp; +\; c_{i_{k - 2} i_{k - 1}}, \\
&amp; \vdots \\
&amp; d(i_{2}) &amp;&amp; \le\; d(i_{1}) &amp;&amp; +\; c_{i_{1}i_{2}} = c_{i_{1}i_{2}}.
\end{aligned}
$$&lt;p>式をそれぞれ代入すると&lt;/p>
$$
d(v) = d(i_{k}) \le c_{i_{k-1}i_{k}} + c_{i_{k-2}i_{k-1}} + \dots + c_{i_{1}i_{2}} = \sum_{(u, v) \in P} c_{uv}
$$&lt;p>となり，$d(v)$ は，始点 s から頂点 v への任意の有向パスのコストの合計の下界になります．
$d(v)$ は始点 s から頂点 v への任意の有向パスの下界かつ上界なので，距離ラベル $d(v)$ は最短路の長さです．&lt;/p>
&lt;p>以上のことから，「各頂点 $v \in N$ について距離ラベル $d(v)$ が最短路の長さである」の必要十分条件は，「各辺 $(u, v) \in A$ について $d(v) \le d(u) + c_{uv}$ を満たす」であることがわかりました．&lt;/p>
&lt;/details>
&lt;h2 id="reduced-arc-length-の性質">reduced arc length の性質
&lt;/h2>&lt;p>ある距離ラベル $d$ に対し，$c_{uv}^{d} = c_{uv} + d(u) - d(v)$ を reduced arc length と呼びます．reduced arc length には次の性質があります．&lt;/p>
&lt;ol>
&lt;li>任意の閉路 $W$ について，$\sum_{(u, v) \in W} c_{uv}^{d} = \sum_{(u, v) \in W} c_{uv}$&lt;/li>
&lt;li>頂点 k から頂点 l への任意の有向パス $P$ について，$\sum_{(u, v) \in P} c_{uv}^{d} = \sum_{(u, v) \in P} c_{uv} + d(k) - d(l)$&lt;/li>
&lt;li>距離ラベル $d$ が最適ならば，すべての辺 (u, v) について $c_{uv}^{d} \ge 0$ が成り立つ&lt;/li>
&lt;/ol>
&lt;details>&lt;summary>性質 1 の証明&lt;/summary>
$$
\begin{aligned}
\sum_{(u, v) \in W} c_{uv}^{d} &amp;= \sum_{(u, v) \in W} (c_{uv} + d(u) - d(v)) \\
&amp;= \sum_{(u, v) \in W} c_{uv} + \sum_{(u, v) \in W} (d(u) - d(v)) \\
&amp;= \sum_{(u, v) \in W} c_{uv} \\
\end{aligned}
$$&lt;p>任意の有向閉路 $W$ において，頂点 u は $+d(u)$としてちょうど 1 回，$-d(u)$ としてちょうど 1 回出現するため，$\sum_{(u, v) \in W} (d(u) - d(v)) = 0$ が成り立ちます．&lt;/p>
&lt;/details>
&lt;details>&lt;summary>性質 2 の証明&lt;/summary>
$$
\begin{aligned}
\sum_{(u, v) \in P} c_{uv}^{d} &amp;= \sum_{(u, v) \in P} (c_{uv} + d(u) - d(v)) \\
&amp;= \sum_{(u, v) \in P} c_{uv} + \sum_{(u, v) \in P} (d(u) - d(v)) \\
&amp;= \sum_{(u, v) \in P} c_{uv} + d(k) - d(l) \\
\end{aligned}
$$&lt;p>頂点 k と頂点 l 以外の頂点は，$+d(u)$ としてちょうど 1 回，$-d(u)$ としてちょうど 1 回出現するため互いに打ち消し合います．&lt;br>
頂点 k は $+d(k)$ として，頂点 $l$ は $-d(l)$ としてちょうど 1 回出現します．&lt;/p>
&lt;/details>
&lt;details>&lt;summary>性質 3 の証明&lt;/summary>
最適性条件から直ちに言えます
&lt;/details>
&lt;p>次節からは，reduced arc length の性質を使ったアルゴリズムと問題を見ていきます．&lt;/p>
&lt;h2 id="johnsons-algorithm">Johnson&amp;rsquo;s algorithm
&lt;/h2>&lt;p>任意の 2 頂点の組 (u, v) に対して頂点 u から頂点 v の最短路を求める問題を全点対最短路問題と呼びます．&lt;br>
Johnson&amp;rsquo;s algorithm は全点対最短路問題を解くアルゴリズムです．&lt;/p>
&lt;p>頂点数が $n$ のとき，単一始点最短路問題を n 回解くことによって全点対最短路を求めることができます．&lt;br>
ただし，グラフにコストが負の辺があると，単一始点最路問題を解くのに Dijkstra 法を使うことができません．そこで，グラフのコストを reduced arc length に変換したグラフ上で最短路を求めることにします．reduced arc length の性質 3 から，最適距離ラベル $d$ に対する reduced arc length のコストはすべて 0 以上であるため Dijkstra 法を使うことができます．&lt;br>
変換したグラフ上で最短距離を求めたあと，性質 2 を使って元のグラフの距離に変換します．&lt;br>
最適距離ラベルは Bellman–Ford 法を使い求めることができます．負閉路が見つかった場合はアルゴリズムを終了します．&lt;/p>
&lt;p>Dijkstra 法に二分ヒープを使うとき，Bellman–Ford 法に $O(nm)$，Dijkstra 法に $O((n + m) \log n)$ かかるため，計算量は全体として $O(nm + n ((n + m) \log n))$ となります．&lt;/p>
&lt;p>例として，&lt;a class="link" href="https://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_1_C&amp;amp;lang=ja" target="_blank" rel="noopener"
>AOJ - All Pairs Shortest Path&lt;/a> を解きます．&lt;br>
与えられるグラフは強連結ではないため，人工頂点 s を追加し，s から他のすべての頂点に重さ 0 の辺を張ります．この s を始点として Bellman-Ford 法を使うことで最適距離ラベルを求めることができます．&lt;br>
実装では人工頂点を追加するのではなく， Bellman-Ford の初期解をすべて 0 とすることで対応しています．&lt;br>
&lt;a class="link" href="https://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=9647270#1" target="_blank" rel="noopener"
>提出コード&lt;/a>&lt;/p>
&lt;h2 id="abc237-e---skiing">&lt;a class="link" href="https://atcoder.jp/contests/abc237/tasks/abc237_e" target="_blank" rel="noopener"
>ABC237 E - Skiing&lt;/a>
&lt;/h2>&lt;p>問題概要&lt;br>
$N$ 頂点，$M$ 辺の強連結の有向グラフと各頂点 u の高さ $H(u)$ が与えられる．$H(u) \ge H(v)$ としたとき，頂点 u から頂点 v にはコスト $H(v) - H(u)$ の辺が，頂点 v から頂点 u にはコスト $2(H(u) - H(v))$ の辺が張られている．頂点 1 から各頂点への最短距離の中で最も小さいものを求めよ．&lt;/p>
&lt;p>負辺のあるグラフの最短路問題なので Bellman–Ford 法を使えば答えが求まりますが，Bellman–Ford 法の計算量は $O(nm)$ なので TLE になってしまいます．
そこで，グラフのコストを reduced arc length に変換したグラフ上で最短路を求めることにします．&lt;/p>
&lt;p>まず，不等式 (1) を満たすような距離ラベルを考えます．&lt;br>
ある距離ラベル $d$ に対して，$H(u) \ge H(v)$ のとき，$c_{uv}^{d}$ と $c_{vu}^{d}$ は以下のように表せます．&lt;/p>
$$
\begin{aligned}
c_{uv}^{d} &amp;= c_{uv} + d(u) - d(v) = H(v) - H(u) + d(u) - d(v) \\
c_{vu}^{d} &amp;= c_{vu} + d(v) - d(u) = 2(H(u)- H(v)) + d(v) - d(u) \\
\end{aligned}
$$&lt;p>u と v についてまとめて式を整理します．&lt;/p>
$$
\begin{aligned}
c_{uv}^{d} &amp;= (H(v) - d(v)) - (H(u) - d(u)) \\
c_{vu}^{d} &amp;= (2H(u) - d(u)) - (2H(v) - d(v)) \\
\end{aligned}
$$&lt;p>$c_{uv}^{d} \ge 0$ かつ $c_{vu}^{d} \ge 0$ にしたいので，各頂点 u について $d(u) = H(u)$ とすると以下のようになります．&lt;/p>
$$
\begin{aligned}
c_{uv}^{d} &amp;= (H(v) - H(v)) - (H(u) - H(u)) = 0 \\
c_{vu}^{d} &amp;= (2H(u) - H(u)) - (2H(v) - H(v)) = H(u) - H(v)\\
\end{aligned}
$$&lt;p>以上のことから，次のように問題を言い換えることができます．&lt;br>
$N$ 頂点，$M$ 辺の強連結の有向グラフと各頂点 u の高さ $H(u)$ が与えられる．$H(u) \ge H(v)$ のとき，頂点 u から頂点 v にはコスト 0 の辺が，頂点 v から頂点 u にはコスト $H(u) - H(v)$ の辺が張られている．頂点 1 から各頂点への最短距離の中で最も小さいものを求めよ．&lt;/p>
&lt;p>すべての辺のコストは 0 以上なので Dijkstra 法で求めることができます．&lt;br>
求まる値は変換したグラフ上での値なので，$distance[u] - H[0] + H[u]$ として元のグラフ上での値に戻します．&lt;/p>
&lt;p>&lt;a class="link" href="https://atcoder.jp/contests/abc237/submissions/57838602" target="_blank" rel="noopener"
>提出コード&lt;/a>&lt;/p>
&lt;h2 id="参考">参考
&lt;/h2>&lt;ul>
&lt;li>&lt;a class="link" href="https://www.amazon.co.jp/dp/1292042702" target="_blank" rel="noopener"
>Network Flows: Pearson New International Edition&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://en.wikipedia.org/wiki/Johnson%27s_algorithm" target="_blank" rel="noopener"
>Johnson&amp;rsquo;s algorithm&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://atcoder.jp/contests/abc237/editorial/3339" target="_blank" rel="noopener"
>E - Skiing 解説&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>HUGO でファイル変更が検出されないときの対処</title><link>https://miti-7.github.io/post/hugo-%E3%81%A7%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E5%A4%89%E6%9B%B4%E3%81%8C%E6%A4%9C%E5%87%BA%E3%81%95%E3%82%8C%E3%81%AA%E3%81%84%E3%81%A8%E3%81%8D%E3%81%AE%E5%AF%BE%E5%87%A6/</link><pubDate>Sun, 15 Sep 2024 00:00:00 +0900</pubDate><guid>https://miti-7.github.io/post/hugo-%E3%81%A7%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E5%A4%89%E6%9B%B4%E3%81%8C%E6%A4%9C%E5%87%BA%E3%81%95%E3%82%8C%E3%81%AA%E3%81%84%E3%81%A8%E3%81%8D%E3%81%AE%E5%AF%BE%E5%87%A6/</guid><description>&lt;p>hugo ではサーバーの実行中にファイルが変更されるとサイトを再構築し自動的にブラウザを更新してくれる機能があるのですが
，&lt;a class="link" href="https://gohugo.io/troubleshooting/faq/#why-isnt-hugos-development-server-detecting-file-changes" target="_blank" rel="noopener"
>Frequently asked questions&lt;/a> によると WSL で実行しているときはうまく動作しないことがあるらしいです．&lt;br>
このようなときは server を起動するときに，&lt;a class="link" href="https://gohugo.io/commands/hugo_server/" target="_blank" rel="noopener"
>poll オプション&lt;/a>を指定すると定期的にポーリングしてくれます．&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">hugo server --poll &amp;#34;700ms&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div></description></item><item><title>最小費用流問題の Primal Network Simplex 法</title><link>https://miti-7.github.io/post/%E6%9C%80%E5%B0%8F%E8%B2%BB%E7%94%A8%E6%B5%81%E5%95%8F%E9%A1%8C%E3%81%AE-primal-network-simplex-%E6%B3%95/</link><pubDate>Wed, 11 Sep 2024 00:00:00 +0900</pubDate><guid>https://miti-7.github.io/post/%E6%9C%80%E5%B0%8F%E8%B2%BB%E7%94%A8%E6%B5%81%E5%95%8F%E9%A1%8C%E3%81%AE-primal-network-simplex-%E6%B3%95/</guid><description>&lt;img src="https://miti-7.github.io/post/%E6%9C%80%E5%B0%8F%E8%B2%BB%E7%94%A8%E6%B5%81%E5%95%8F%E9%A1%8C%E3%81%AE-primal-network-simplex-%E6%B3%95/images/%E3%83%9D%E3%83%86%E3%83%B3%E3%82%B7%E3%83%A3%E3%83%AB%E3%81%AE%E6%9B%B4%E6%96%B0.png" alt="Featured image of post 最小費用流問題の Primal Network Simplex 法" />&lt;h2 id="最小費用流問題minimum-cost-flow-problem">最小費用流問題(Minimum Cost Flow Problem)
&lt;/h2>&lt;p>$N$ を頂点の集合，$A$ を辺の集合，$c_{ij}$ を辺 $(i, j)$ の単位流量あたりのコスト，$x_{ij}$ を辺 $(i, j)$ の流量，$b_i$ を頂点 i の需要/供給量，$l$ を辺の下限容量，$u$ を辺の上限容量としたとき，最小費用流問題（以下 MCFP）は以下のように定式化されます．&lt;br>
1 つめの制約を流量保存則と呼び，第一項は頂点 i から出る流量，第二項は頂点 i に入る流量を表します．
2 つめの制約を容量制約と呼びます．&lt;/p>
$$
\begin{aligned}
&amp;\text{minimize} &amp;&amp; \sum_{(i, j) \in A} c_{ij} x_{ij} \\
&amp;\text{subject to}
&amp;&amp; \sum_{j:(i, j) \in A} x_{ij} - \sum_{j:(j,i) \in A} x_{ji} = b_i &amp;&amp; \forall i \in N \\
&amp; &amp;&amp; l_{ij} \le x_{ij} \leq u_{ij} &amp;&amp; \forall (i, j) \in A
\end{aligned}
$$&lt;p>以下ではコスト，流量，需要/供給，下限容量，上限容量はすべて整数とします．また，$\sum_{i \in N} b_i = 0$ を仮定します．&lt;/p>
&lt;h2 id="primal-network-simplex-法">Primal Network Simplex 法
&lt;/h2>&lt;p>primal network simplex 法は，ネットワーク構造を利用することで simplex 法を効率化させたアルゴリズムです．今回は primal network simplex 法で MCFP を解いていきます．&lt;br>
MCFP が必ず 最適 spanning tree solution という解を持つことを利用し，spanning tree solution のみを探索することで効率的に最適解を見つけることができます&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>．&lt;/p>
&lt;p>primal network simplex 法は，simplex 法の観点と負閉路除去法の観点から説明することができますが，今回は負閉路除去法の観点で説明します．
節 1 で spanning tree solution の定義をします．節 2 で spanning tree solution は spanning tree structure として表せることと，spanning tree structure が最適解となる条件について示します．節 3 で primal network simplex 法の流れについて説明し，節 4 から 節 8 でアルゴリズムの各段階の詳細について述べます．節 9 から節 11 で退化について説明します．&lt;/p>
&lt;h2 id="1-spanning-tree-solution">1. spanning tree solution
&lt;/h2>&lt;p>ある実行可能解 $x$ に対して， $l_{ij} &amp;lt; x_{ij} &amp;lt; u_{ij}$ を満たす辺を free arc，$x_{ij} = l_{ij}$ か $x_{ij} = u_{ij}$ を満たす辺を restricted arc と呼びます．
解 $x$ とそれに関連する全域木が以下の条件を満たすとき，spanning tree solution と呼びます．特に，$x$ が 最適解であるとき最適 spanning tree solution と呼びます．&lt;/p>
&lt;ul>
&lt;li>$x$ が実行可能解である&lt;/li>
&lt;li>全域木に含まれない辺（non-tree arc）がすべて restricted arc である&lt;/li>
&lt;/ul>
&lt;p>具体例を示します．簡単のため，辺容量の下限はすべて 0 としコストは省略します．$b(0) = 2$，$b(3) = -2$ とします．&lt;br>
下の図のグラフでは辺 (0, 1)，(2, 3) が free arc，辺 (0, 2)，(1, 2)，(1, 3) が restricted arc です．&lt;br>
解 $x$ は流量保存則と容量制約を満たすため実行可能解です．全域木として，青色の辺 (0, 1)，(0, 2)，(2, 3) を選ぶ&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>と，non-tree arc は (1, 2) と (1, 3) となり，すべて restricted arc であるため spanning tree solution となります．&lt;/p>
&lt;img src="images/spanning_tree_solutionの例1.png" width="50%">
&lt;p>また，全域木として，青色の辺 (0, 1)，(1, 2)，(2, 3) を選んでも spanning tree solution となります．
このように，1 つの実行可能解に複数の spanning tree solution が対応することがあります．&lt;/p>
&lt;img src="images/spanning_tree_solutionの例2.png" width="50%">
&lt;h2 id="2-spanning-tree-structure-と最適性条件">2. spanning tree structure と最適性条件
&lt;/h2>&lt;p>spanning tree solution は辺集合を次の 3 つに分割します．&lt;/p>
&lt;ul>
&lt;li>T: 全域木の辺&lt;/li>
&lt;li>L: non-tree arc のうち，flow が下限の辺&lt;/li>
&lt;li>U: non-tree arc のうち，flow が上限の辺&lt;/li>
&lt;/ul>
&lt;p>この 3 つ組 (T, L, U) を spanning tree structure と呼びます．spanning tree structure は spanning tree solution から一意に構築されます．&lt;/p>
&lt;p>頂点 i のポテンシャルを $\pi(i)$，辺 (i, j) の reduced cost を $c_{ij}^{\pi} = c_{ij} - \pi(i) + \pi(j)$ で表します．spanning tree structure が次の条件を満たすとき，spanning tree structure に対応する spanning tree solution は最適 spanning solution となります．このような，spanning tree structure を最適 spanning tree structure と呼びます．&lt;/p>
$$
\begin{aligned}
c^{\pi}_{ij} = 0 &amp;&amp; \forall (i, j) \in T \\
c^{\pi}_{ij} \ge 0 &amp;&amp; \forall (i, j) \in L \\
c^{\pi}_{ij} \le 0 &amp;&amp; \forall (i, j) \in U \\
\end{aligned}
$$&lt;p>全域木の根のポテンシャルを 0 と固定すると $T$ に属する辺 (i, j) が $c^{\pi}_{ij} = 0$ を満たすように各頂点のポテンシャル $\pi$ を定めることができます．このとき，$-\pi(i)$ は根から頂点 i への木のパスの長さとみなすことができます．
具体例として，下の図の全域木について各頂点のポテンシャルを求めていきます．頂点 0 を根とします．&lt;/p>
&lt;p>頂点 1 のポテンシャルを求めます．
辺 (i, j) の reduced cost は $c_{ij}^{\pi} = c_{ij} - \pi(i) + \pi(j)$ です．全域木の辺の reduced cost は 0，辺 (0, 1) のコストは 1，頂点 0 のポテンシャルは 0 であることから，$0 = 1 - 0 + \pi(1)$ となり，$\pi(1) = -1$と求められます．&lt;/p>
&lt;p>頂点 2 のポテンシャルを求めます．
辺 (2, 1) のコストは 5 ，頂点 1 のポテンシャルは -1 なので，$0 = 5 - \pi(2) + (-1)$ となり，$\pi(2) = 4$ と求められます．&lt;/p>
&lt;p>同様の計算を行うことで，全頂点のポテンシャルを計算することができます．&lt;/p>
&lt;img src="images/ポテンシャルの計算.png" width="50%">
&lt;p>全頂点のポテンシャルを求めると，$L$ と $U$ に属する辺の reduced cost を計算することができます．すべての辺が最適性条件を満たすならば，最適 spanning tree structure と判定できます．&lt;/p>
&lt;h2 id="3-network-simplex-法のアルゴリズムの流れ">3. Network Simplex 法のアルゴリズムの流れ
&lt;/h2>&lt;p>spanning tree structure が与えられたとき，全域木の reduced cost が 0 となるように各頂点のポテンシャルを計算し，各辺の reduced cost を求めることで最適 spanning structure かどうか判定することができました．
最適 spanning tree structure でない場合， $L$ に属する $c_{ij}^{\pi} \lt 0$ である辺か，$U$ に属する $c_{ij}^{\pi} \gt 0$ である辺が 1 つ以上存在することになります．
これらの辺を $T$ に追加したときを考えます．&lt;/p>
&lt;h3 id="l-に属する-cpi_ij-lt-0-である辺を-t-に追加">$L$ に属する $c^{\pi}_{ij} \lt 0$ である辺を $T$ に追加
&lt;/h3>&lt;p>$L$ に属する $c_{ij}^{\pi} \lt 0$ である辺 (i, j) を $T$ に追加したとします．&lt;br>
このとき，根から i，i から j，j から根をたどるパスの flow を 1 増加すると，目的関数値は $c^{\pi}_{ij}$ 増加します．&lt;/p>
&lt;p>具体例を見てみます．下の図の全域木にコスト -8 の辺 (2, 4) を追加したとします．この辺の reduced cost は $-8 - 4 + (-3) = -15$ です．&lt;br>
辺 (0, 1)，(2, 1)，(2, 4)，(3, 4)，(3, 0) の順に flow を 1 単位流すと，全体のコストの合計は，1 + (-5) + (-8) + (-5) + 2 = -15 となり，目的関数値が 15 減少する（-15 増加する）ことがわかります&lt;sup id="fnref:3">&lt;a href="#fn:3" class="footnote-ref" role="doc-noteref">3&lt;/a>&lt;/sup>．&lt;/p>
&lt;img src="images/全域木にLの辺を追加.png" width="50%">
&lt;h3 id="u-に属する-cpi_ij-gt-0-である辺を-t-に追加">$U$ に属する $c^{\pi}_{ij} \gt 0$ である辺を $T$ に追加
&lt;/h3>&lt;p>$U$ に属する $c_{ij}^{\pi} \gt 0$ である辺 (i, j) を $T$ に追加したとします．&lt;br>
このとき，根から j， j から i，i から根をたどるパスの flow を 1 増加すると，目的関数値は $c^{\pi}_{ij}$ 減少します．&lt;/p>
&lt;p>下の図の全域木にコスト -5 の辺 (6, 4) を追加したとします．この辺の reduced cost は $(-5) - (-11) + (-3) = 3$ です．&lt;br>
辺 (3, 0)，(3, 4)，(6, 4)，(5, 6)，(3, 5)，(3, 0) の順に flow を 1 単位流すと，全体のコストの合計は，-2 + 5 + (-(-5)) + (-7) + (-6) + 2 = -3 となり，目的関数値が 3 減少することがわかります．&lt;br>
また，辺 (0, 3) に対し，頂点 0 から 頂点 3 に flow を流し，頂点 3 から頂点 0 に flow を流すと flow は打ち消し合うため，追加した辺によって生じる閉路のみを考慮すればいいこともわかります．&lt;/p>
&lt;img src="images/全域木にUの辺を追加.png" width="50%">
&lt;p>以上のことから，spanning tree structure が最適でないとき，最適性条件に違反する辺を全域木に追加したことによって生じる閉路の flow を更新することで目的関数値を減少できることがわかりました．&lt;br>
閉路の flow を限界まで増加させると，1 本以上の辺の flow が下限容量か上限容量に達するため，その辺を取り除くことによって新しい spanning tree solution を生成することができます．&lt;br>
primal network simplex 法は これらの処理を最適性条件を満たすまで繰り返すことで最適解を求めます．&lt;/p>
&lt;p>primal network simplex 法の流れは以下のようになります&lt;/p>
&lt;ul>
&lt;li>初期 spanning tree structure を構築する&lt;/li>
&lt;li>spanning tree structure が最適性条件を満たさない間，以下を繰り返す
&lt;ul>
&lt;li>最適性条件に違反する辺を $U$ か $L$ から選び，全域木に追加する&lt;/li>
&lt;li>閉路の flow を更新する&lt;/li>
&lt;li>flow が下限容量か上限容量に達した辺を閉路から 1 つ取り除き新しく全域木を作成する&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>次節からアルゴリズムの各段階の詳細について説明していきます．&lt;/p>
&lt;h2 id="4-初期-spanning-tree-structre-の構築">4. 初期 spanning tree structre の構築
&lt;/h2>&lt;p>初期 spanning tree structre (T, L, U) を構築します．&lt;br>
まず，人工頂点 $s$ を作り，$s$ と既存の各頂点 $u$ の間に以下のように辺をはります．&lt;/p>
&lt;ul>
&lt;li>$b(u) \ge 0$ の場合，流量 $b(u)$ の辺 $(u, s)$ を加える&lt;/li>
&lt;li>$b(u) \lt 0$ の場合，流量 $-b(u)$ の辺 $(s, u)$ を加える&lt;/li>
&lt;/ul>
&lt;p>いずれの人工辺も容量とコストは十分大きい値とします．人工辺は $T$ に，もとからある辺は $L$ に，$U$ は空とします.&lt;br>
このように作られた spanning tree structure は実行可能解です．今後はこの拡張された network 上で問題を解いていきます．人工辺のコストは十分大きいため最適解が得られたとき人工辺に flow は流れていません．&lt;/p>
&lt;p>例として下のグラフの初期 spanning tree structure を構築します．&lt;br>
$b(0) = 2$，$b(3) = -2$，他の頂点の需要/供給は 0 とします．また，すべての辺の下限容量は 0 とします&lt;sup id="fnref:4">&lt;a href="#fn:4" class="footnote-ref" role="doc-noteref">4&lt;/a>&lt;/sup>．&lt;/p>
&lt;img src="images/初期解の問題例.png" width="50%">
&lt;p>まず，人工頂点として，$s$ を追加します．&lt;br>
$b(u) \ge 0$ である頂点 0, 1, 2 から s に向けて辺を追加します．$b(0) = 2$ であるため，辺 (0, s)の flow は 2 とします．&lt;br>
s から $b(u) \lt 0$ である頂点 3 に向けて辺を追加します．$b(3) = -2$ であるため，辺 (s, 3)の flow は 2 とします．&lt;/p>
&lt;img src="images/初期解の構築.png" width="50%">
&lt;p>初期 spanning tree structure は以下のようになります．&lt;/p>
&lt;ul>
&lt;li>$T$ に属する辺：(0, s)，(1, s)，(2, s)，(s, 3)&lt;/li>
&lt;li>$L$ に属する辺：(0, 1)，(0, 2)，(1, 2)，(1, 3)，(2, 3)&lt;/li>
&lt;li>$U$ に属する辺：なし&lt;/li>
&lt;/ul>
&lt;h2 id="5-entring-arc-の選択">5. entring arc の選択
&lt;/h2>&lt;p>$T$ に追加する辺（entring arc）を $U$ か $L$ から選びます．&lt;br>
このとき，以下のような最適性条件を満たさない辺（eligible arc）を選びます．また，$|c^{\pi}_{ij}|$ を violation と呼びます．&lt;/p>
$$
\begin{aligned}
c^{\pi}_{ij} \lt 0 &amp;&amp; \forall (i, j) \in L \\
c^{\pi}_{ij} \gt 0 &amp;&amp; \forall (i, j) \in U
\end{aligned}
$$&lt;p>代表的な辺の選択方法は以下の 3 つです．&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Best eligible arc pivot rule(Dantzig&amp;rsquo;s pivot rule)&lt;/p>
&lt;ul>
&lt;li>violation の最も大きい eligible arc を entring arc とする&lt;/li>
&lt;li>1 flow 単位の改善が最も大きいため，イテレーションの回数は少なくなる&lt;/li>
&lt;li>すべての non-tree arc を調べる必要があるため，1 回のイテレーションのコストが大きい&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>First eligible arc pivot rule&lt;/p>
&lt;ul>
&lt;li>最初に見つけた eligible arc を entring arc とする．次のイテレーションでは，前回選択した辺の次から探索を開始する．最後の辺まで探索をしたら先頭に戻る&lt;/li>
&lt;li>1 回のイテレーションのコストが小さい&lt;/li>
&lt;li>1 flow 単位の改善が小さくなるので，イテレーションの回数が多くなる&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Block search pivot rule&lt;/p>
&lt;ul>
&lt;li>辺をブロックに分割し，ブロックの中で violation の最も大きい eligible arc を entring arc とする．ブロック内で見つからなかった場合，次のブロックを探索する&lt;/li>
&lt;li>すべての辺を同じブロックにしたとき，Best eligible arc pivot rule と同じ挙動になる&lt;/li>
&lt;li>すべての辺を違うブロックにしたとき，First eligible arc pivot rule と同じ挙動になる&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="6-flow-の更新">6. flow の更新
&lt;/h2>&lt;p>全域木に辺を追加すると閉路 $W$ がちょうど 1 つできます．この閉路の flow を 1 単位増加するごとに，MCFP の目的関数値は $|c^{\pi}_{ij}|$ 減少するため，$W$ の flow を容量制約を満たす限界まで増加します．&lt;br>
閉路 $W$ の向きを次のように定めます．&lt;/p>
&lt;ul>
&lt;li>$(k, l) \in L$ のとき，辺 (k, l) と同じ方向&lt;/li>
&lt;li>$(k, l) \in U$ のとき，辺 (k, l) と逆方向&lt;/li>
&lt;/ul>
&lt;p>閉路 $W$ の順辺の集合を $\bar W$，逆辺の集合を $\underbar W$ で表したとき，$W$ の各辺の flow の増加できる量は以下のようになります．&lt;/p>
$$
\delta_{ij} = \left\{
\begin{array}{ll}
u_{ij} - x_{ij} &amp; (i, j) \in \bar{W}\\
x_{ij} - l_{ij} &amp; (i, j) \in \underbar{W}
\end{array}
\right.
$$&lt;p>$\delta = min \lbrace \delta_{ij} : (i, j) \in W \rbrace$ とし，$W$ の各辺の flow を以下のように更新します．&lt;/p>
$$
x_{ij} = \left\{
\begin{array}{ll}
x_{ij} + \delta &amp; (i, j) \in \bar{W}\\
x_{ij} - \delta &amp; (i, j) \in \underbar{W}
\end{array}
\right.
$$&lt;p>具体例を見ます．すべての辺の下限は 0 とします．&lt;br>
$U$ に属する辺 (6, 4) を $T$ に追加すると，辺 (6, 4)，(5, 6)，(3, 5)，(3, 4) からなる閉路ができます．&lt;br>
辺 (6, 4) は $U$ に属するので，(6, 4) と逆方向である反時計回りを $W$ の向きとします．$\bar W$ に属する辺は，(3, 4)，$\underbar W$ に属する辺は，(6, 4)，(5, 6)，(3, 5) です．&lt;br>
各辺の $\delta_{ij}$ と $\delta$ は以下の通りです．&lt;/p>
&lt;ul>
&lt;li>$\delta_{64} = 6 - 0 = 6$&lt;/li>
&lt;li>$\delta_{56} = 2 - 0 = 2$&lt;/li>
&lt;li>$\delta_{35} = 4 - 0 = 4$&lt;/li>
&lt;li>$\delta_{34} = 3 - 1 = 2$&lt;/li>
&lt;li>$\delta = min \lbrace 6, 2, 4, 2 \rbrace = 2$&lt;/li>
&lt;/ul>
&lt;img src="images/閉路のflowの更新.png" width="50%">
&lt;p>閉路 $W$ の flow を 2 増加すると以下のようになります．&lt;/p>
&lt;img src="images/閉路のflowの更新結果.png" width="50%">
&lt;p>別の例をみます．
辺 (3, 4) の flow が 3 のとき，各辺の $\delta_{ij}$は以下のようになります．&lt;/p>
&lt;ul>
&lt;li>$\delta_{64} = 6 - 0 = 6$&lt;/li>
&lt;li>$\delta_{56} = 2 - 0 = 2$&lt;/li>
&lt;li>$\delta_{35} = 4 - 0 = 4$&lt;/li>
&lt;li>$\delta_{34} = 3 - 3 = 0$&lt;/li>
&lt;li>$\delta = min \lbrace 6, 2, 4, 0 \rbrace = 0$&lt;/li>
&lt;/ul>
&lt;p>このように全域木に $x_{ij} = l_{ij}$ や $x_{ij} = u_{ij}$ の辺があると flow が更新できないことがあります．&lt;/p>
&lt;img src="images/閉路のflowを更新できない例.png" width="50%">
&lt;h2 id="7-leaving-arc-の選択">7. leaving arc の選択
&lt;/h2>&lt;p>閉路の flow を限界まで増加したとき 1 本以上の辺が $\delta = \delta_{ij}$ となります．この辺を blocking arc と呼びます．&lt;br>
blocking arc を取り除く辺（leaving arc）として選びます（複数ある場合は任意の辺を選びます）．&lt;br>
辺 (i, j) が $x_{ij}$ = $l_{ij}$ になったときは $L$ に，$x_{ij} = u_{ij}$ になったときは $U$ に入ります．&lt;/p>
&lt;p>閉路 $W$ の flow を更新した結果，辺 (5, 6) の flow が下限容量に，辺 (3, 4) の flow が上限容量になった場合を考えます．&lt;/p>
&lt;img src="images/閉路のflowの更新結果.png" width="50%">
&lt;p>辺 (5, 6) と辺 (3, 4) のどちらかを取り除くことができます．辺 (5, 6) を取り除き $L$ に追加すると下の全域木 $T$ が得られます．&lt;/p>
&lt;img src="images/閉路の辺の削除.png" width="50%">
&lt;h2 id="8-ポテンシャルの更新">8. ポテンシャルの更新
&lt;/h2>&lt;p>辺 (p, q) を削除したとき，木は 2 つの部分木に分割されます．根がある方の部分木を $T_1$，ない方の部分木を $T_2$ とします．&lt;br>
木の根のポテンシャルを 0 に固定し， 辺の reduced cost が 0 になるようにポテンシャルを算出していたことを考えると，$T_1$ に含まれる頂点のポテンシャルは変化せず，$T_2$ に含まれる頂点のポテンシャルのみ変化することがわかります．&lt;/p>
&lt;p>全域木に辺 (k, l) が追加され，頂点 k が $T_1$ に，頂点 l が $T_2$ に含まれる場合を考えます．&lt;br>
$T_2$ は頂点 q を根とする部分木から頂点 l を根とする部分木に変化するため，$T_2$ に属する頂点のポテンシャルを更新する必要があります．&lt;br>
木のすべての頂点のポテンシャルに定数を加算しても reduced cost は保たれるため，新しい $\pi(l)$ と現在の $\pi(l)$ の差分 $d$ が求められれば，$T_2$ に属するすべての頂点に $d$ を加算することでポテンシャルを正しい値に更新できます．&lt;br>
頂点 k のポテンシャルは変化しないことから，頂点 l の新しいポテンシャル $\pi^{\prime}(l)$ は $0 - c_{kl} + \pi(k)$ となります．&lt;br>
よって，頂点 l の新しいポテンシャルとの現在のポテンシャルの差は $\pi^{\prime}(l) - \pi(l) = 0 - c_{kl} + \pi(k) - \pi(l) = -(c_{kl} - \pi(k) + \pi(l))$ となり，これは $-c_{kl}^{\pi}$ です．&lt;br>
以上のことから，$T_2$ に属するすべての頂点に $-c_{kl}^{\pi}$ を加算することでポテンシャルを正しい値に更新できることがわかりました．&lt;br>
頂点 l が $T_1$ に，頂点 k が $T_2$ に含まれる場合も同様の議論により，$c_{kl}^{\pi}$ 増加することが示せます．&lt;/p>
&lt;p>まとめると，辺 (k, l)を追加したとき $T_2$ に含まれる頂点のポテンシャルは以下のように更新されます．&lt;/p>
&lt;ul>
&lt;li>頂点 k が $T_1$ に，頂点 l が $T_2$ に含まれる場合
&lt;ul>
&lt;li>$T_2$ に含まれる頂点のポテンシャルは $-c^{\pi}_{kl}$ 増加&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>頂点 l が $T_1$ に，頂点 k が $T_2$ に含まれる場合
&lt;ul>
&lt;li>$T_2$ に含まれる頂点のポテンシャルは $c^{\pi}_{kl}$ 増加&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;img src="images/ポテンシャルの更新.png" width="75%">
&lt;h2 id="9-strongly-feasible-spanning-tree">9. Strongly Feasible Spanning Tree
&lt;/h2>&lt;p>primal network simplex 法が有限回で終了するのかを考えます．&lt;br>
アルゴリズムの各イテレーションでは，全域木に辺を追加するこことで閉路を作り，この閉路の flow を更新することで目的関数値を減少させます．&lt;br>
目的関数値は flow 1 単位あたり $|c^{\pi}_{ij}|$ 減少するため，常に正の量の flow を流せるならアルゴリズムは有限回で終了します．&lt;br>
しかし，節 6 の最後の例のように閉路に restricted arc があると flow が増加できないイテレーションが発生することがあります．このイテレーションを degenerate iteration といいます．&lt;br>
実は primal network simplex 法は entring arc と leaving arc を任意に選ぶと degenerate iteration が無限に発生しアルゴリズムが有限回で終了しないことがあります．&lt;/p>
&lt;p>そこで，strongly feasible spanning tree という概念を導入します．&lt;br>
常に strongly feasible spanning tree を維持することによって，アルゴリズムが有限回で終了することが保証できます．&lt;/p>
&lt;h3 id="strongly-feasible-spanning-tree">strongly feasible spanning tree
&lt;/h3>&lt;p>次の条件を満たす spanning tree を strongly feasible spanning tree と呼びます．&lt;/p>
&lt;ul>
&lt;li>任意の頂点から正の量の flow を容量制約に違反することなく木に沿って根に送ることができる&lt;/li>
&lt;/ul>
&lt;p>下の図は strongly feasible spanning tree の例です．&lt;br>
すべての頂点から頂点 0 に向かって 1 以上の flow を送ることができます．&lt;br>
strongly feasible spanning tree は flow が下限の辺のは根に向いていて，flow が上限の辺は根と反対を向いている全域木とみなすこともできます．&lt;/p>
&lt;img src="images/strongly_feasible_spanning_treeの例.png" width="50%">
&lt;p>下の図は strongly feasible spanning tree ではない例です．&lt;br>
辺 (2, 1) の flow は上限容量であるため，頂点 2 から根に flow を送ることはできません．また，辺 (3, 4) の flow は下限容量であるため，頂点 4 から根に flow を送ることはできません．&lt;/p>
&lt;img src="images/strongly_feasible_spanning_treeではない例.png" width="50%">
&lt;p>節 4 の「初期 spanning tree structure の構築」は strongly feasible spanning tree を構築します．次の節で leaving arc をどのように選べば strongly feasible spanning tree を維持できるのか見ていきます．&lt;/p>
&lt;h2 id="10-strongly-feasible-spanning-tree-を保つ-leaving-arc-の選び方">10. Strongly Feasible Spanning Tree を保つ leaving arc の選び方
&lt;/h2>&lt;p>辺 (k, l) を entring arc とします．頂点 k と l の最小共通祖先を頂点 w とします．&lt;br>
このとき閉路 $W$ に沿って，頂点 w から開始して最後に見つけた blocking arc を leaving arc とすると，spanning tree は strongly feasible を維持できます．&lt;/p>
&lt;p>具体例をみます．&lt;br>
$L$ に属する辺 (k, l) が追加され閉路 $W$ が生成されたとします．閉路の向きは辺 (k, l) と同じ向きです．&lt;br>
この閉路には flow を流すことができず，辺 (w, 1) と辺 (p, q) が blocking arc になります．&lt;br>
頂点 w から閉路の向きに沿って探索し，最後に見つかる blocking arc は辺 (p, q) であるため，この辺を leaving arc とします．&lt;/p>
&lt;img src="images/strongly_feasible_spanning_treeを維持するようなleaving_arcの選び方.png" width="30%">
&lt;p>strongly feasible spanning tree から上記の方法で leaving arc を選んだとき，strongly feasible spanning tree が維持されることを示します．pivot 操作の直前は strongly feasible spanning tree であるという前提を利用します．&lt;/p>
&lt;p>頂点 w から頂点 q のパスを $W_1$，頂点 p から頂点 w のパスを $W_2$ とします．&lt;br>
「$W_1$」，「$W_2$」，「閉路以外の頂点」の 3 つについて，「任意の頂点から正の量の flow を容量制約に違反することなく木に沿って根に送ることができる」という条件を満たすか確認します．&lt;/p>
&lt;ul>
&lt;li>
&lt;p>$W_1$ 内の頂点&lt;/p>
&lt;ul>
&lt;li>直前が non-degenerate pivot&lt;sup id="fnref:5">&lt;a href="#fn:5" class="footnote-ref" role="doc-noteref">5&lt;/a>&lt;/sup> の場合
&lt;ul>
&lt;li>$\delta \gt 0$ であるため，頂点 w から$W_1$ 内の頂点に flow が送られている．$W_1$ の各頂点からは頂点 w まで $\delta$ の flow を押し戻すことができるため条件を満たす&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>直前が degenerate pivot&lt;sup id="fnref:6">&lt;a href="#fn:6" class="footnote-ref" role="doc-noteref">6&lt;/a>&lt;/sup> の場合
&lt;ul>
&lt;li>前提から，pivot の直前では頂点 l から頂点 w のパスで flow を送れていたため，このパス内に blocking arc は存在しない．よって $W_1$ は頂点 w と頂点 k の間にある&lt;/li>
&lt;li>$\delta = 0$ であり，頂点 w から頂点 k のどの辺の flow にも変化はないため条件を満たす&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>$W_2$ 内の頂点&lt;/p>
&lt;ul>
&lt;li>leaving arc の選び方を考えると，$W_2$ 内に blocking arc はないため条件を満たす&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>$W$ 以外の頂点&lt;/p>
&lt;ul>
&lt;li>頂点 u から根へのパスに閉路 $W$ が含まれないとき
&lt;ul>
&lt;li>前提から，閉路以外の flow に変化はないため，条件を満たす&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>頂点 u から根へのパスに閉路 $W$ が含まれるとき
&lt;ul>
&lt;li>u から閉路までのパスは，flow に変化がないため条件を満たす．閉路に到達したとき閉路から根まで条件を満たすので全体として条件を満たす&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>以上のことから，leaving arc に $W$ に沿って最後に見つけた blocking arc を選ぶことで，常に strongly feasible spanning tree を維持できることがわかりました．&lt;/p>
&lt;h2 id="11-アルゴリズムが有限回で終了することの証明">11. アルゴリズムが有限回で終了することの証明
&lt;/h2>&lt;p>2 つの non-degenerate pivot の間の連続する degenerate pivot が有限回であることを示します．&lt;/p>
&lt;p>degenerate pivot が発生したとき，ノードのポテンシャルが単調減少することを示します．$n$ を頂点の数，$C$ をコストの絶対値の最大値としたとき，ノードのポテンシャルの下界は $-nC$ であるため連続する degenerate pivot は有限回で終了します．&lt;/p>
&lt;ul>
&lt;li>
&lt;p>entring arc (k, l) が $L$ に属していた場合&lt;/p>
&lt;ul>
&lt;li>辺 (k, l) は $L$ に属し，最適性条件に違反するため，reduced cost は $c^{\pi}_{kl} \lt 0$ です．&lt;/li>
&lt;li>全域木は常に strongly feasible spanning tree を維持していることを考えると，degenerate pivot の場合は頂点 l から頂点 w の間に blocking arc は存在しないため，新しく作成される木は頂点 l に 頂点 k がぶら下がる形になります．&lt;/li>
&lt;li>頂点 k を根とする部分木のポテンシャルは $c^{\pi}_{kl} \lt 0$ 増加するため，ノードのポテンシャルは単調減少します&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>entring arc (k, l) が $U$ に属していた場合&lt;/p>
&lt;ul>
&lt;li>辺 (k, l) は $U$ に属し，最適性条件に違反するため，reduced cost は $c^{\pi}_{kl} \gt 0$ です．&lt;/li>
&lt;li>新しく作成される木は頂点 k に 頂点 l がぶら下がる形になります．&lt;/li>
&lt;li>頂点 l を根とする部分木のポテンシャルは $c^{\pi}_{kl} \gt 0$ 減少するため，ノードのポテンシャルは単調減少します&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>以上のことから 2 つの non-degenerate pivot の間の連続する degenerate pivot が有限回であることがわかりました．
non-degenerate pivot は目的関数値を厳密に減少させるため，アルゴリズムは有限回で終了します．&lt;/p>
&lt;h2 id="補足-1-最適-spanning-tree-solution-が必ず存在することについて">補足 1. 最適 spanning tree solution が必ず存在することについて
&lt;/h2>&lt;h3 id="cycle-free-solution">cycle free solution
&lt;/h3>&lt;p>free arc のみからなる閉路を持たないような実行可能解 $x$ を cycle free solution といいます．&lt;/p>
&lt;p>下の図は cycle free solution の例です．辺の上に (流量，コスト) を示し，下限容量は 0，上限容量は無限とします．&lt;br>
青色の辺 (0, 1)，(1, 3)，(3, 4) が free arc です．free arc のみからなる閉路がないため cycle free solution です．この解の目的関数値は $(2 \times 0) + (2 \times 1) + (2 \times 0) = 2$ です．&lt;/p>
&lt;img src="images/cycle_free_solutionの例.png" width="50%">
&lt;p>下の図は cycle free solution ではない例です．&lt;br>
青色の辺 (0, 1)，(1, 2)，(1, 3)，(2, 4)，(3, 4) が free arc です．free arc のみからなる閉路があるため cycle free solution ではありません．この解の目的関数値は $(2 \times 0) + (1 \times 3) + (1 \times 1) + (1 \times -1) + (1 \times 0) = 3$ です．&lt;/p>
&lt;img src="images/cycle_free_solutionではない例.png" width="50%">
&lt;p>cycle free solution でない解が与えられたとき，閉路の flow を操作することで，目的関数値が大きくならないように cycle free solution にすることができます．&lt;br>
この解の場合，時計回りに flow を 1 増加すると，辺 (2, 4)，(1, 2) の flow が 1 減り，辺(1, 3)，(3, 4) の flow が 1 増えます．結果，この解の目的関数値は $(2 \times 0) + (0 \times 3) + (2 \times 1) + (0 \times -1) + (2 \times 0) = 2$ と 1 小さくなり，さらに cycle free solution になりました．&lt;/p>
&lt;img src="images/cycle_free_solutionに変形.png" width="50%">
&lt;p>このように，cycle free でない解は閉路の flow を操作することで目的関数値が大きくならないように cycle free solution にできるため，MCFP に最適解があるとき，常に同じ目的関数値である cycle free solution を持つことがわかります．&lt;/p>
&lt;h3 id="cycle-free-solution-から-spanning-tree-solution-を求める">cycle free solution から spanning tree solution を求める
&lt;/h3>&lt;p>cycle free solution は辺を適切に選ぶことで spanning tree solution を求めるとができます．&lt;br>
下の図では，青色の辺(0, 1)，(1, 2)，(1, 3)，(3, 4) を全域木として選んでいます．&lt;/p>
&lt;img src="images/cycle_free_solutionをspanning_tree_solutionに.png" width="50%">
&lt;p>以上のことから，MCFP に最適解があるとき，常に同じ目的関数値である最適 spanning tree solution を持つことがわかりました．&lt;/p>
&lt;h2 id="補足-2-spanning-tree-structure-の最適性条件">補足 2. Spanning Tree Structure の最適性条件
&lt;/h2>&lt;p>spanning tree structure が次の条件を満たすとき，spanning tree structure に対応する spanning tree solution は最適 spanning solution となることを示します．&lt;/p>
$$
\begin{aligned}
c^{\pi}_{ij} = 0 &amp;&amp; \forall (i, j) \in T \\
c^{\pi}_{ij} \ge 0 &amp;&amp; \forall (i, j) \in L \\
c^{\pi}_{ij} \le 0 &amp;&amp; \forall (i, j) \in U \\
\end{aligned}
$$&lt;p>まず，$\sum_{(i, j) \in A} c_{ij} x_{ij}$ を最小化することは $\sum_{(i, j) \in A} c_{ij}^{\pi} x_{ij}$ を最小化することと等しいことを示します．&lt;/p>
&lt;p>$z(\pi) = \sum_{(i, j) \in A} c_{ij}^{\pi} x_{ij}$ とします．$c_{ij}^{\pi} = c_{ij} - \pi(i) + \pi(j)$ なので，$z(0) = \sum_{(i, j) \in A} c_{ij} x_{ij}$ です．&lt;br>
頂点 k のポテンシャルを $0$ から $\pi(k)$ まで増加したとします．&lt;br>
$c_{ij}^{\pi} = c_{ij} - \pi(i) + \pi(j)$ なので，reduced cost は頂点 k から流出する flow 1 単位あたり $\pi(k)$ 減少し，頂点 k に流入する flow 1 単位あたり $\pi(k)$ 増加します．よって，全体の reduced cost は $ - \pi(k) \times k$ からの流出量 + $\pi(k) \times k$ への流入量だけ変化します．&lt;/p>
&lt;p>MCFP の制約条件から，各頂点 i の流出量と流入量の関係は $\sum_{j:(i, j) \in A} x_{ij} - \sum_{j:(j,i) \in A} x_{ji} = b_i$ です．&lt;br>
よって，頂点 k のポテンシャルを $\pi(k)$ 増加すると，目的関数値は $\pi(k)b(k)$ 減少することになります．&lt;br>
すべての頂点に同様のことがいえるので，$z(0) - z(\pi) = \sum_{i \in N} \pi(i)b(i) = \pi b$ となります．&lt;br>
$\pi b$ は定数のため，$z(\pi)$ を最小化する flow は $z(0)$ を最小化することがわかりました．&lt;/p>
&lt;p>次に，$x^{\ast}$ を上の最適性条件を満たす (T, L, U) に対応する解としたとき，これが最適解であることを示します．&lt;br>
最適性条件を満たすポテンシャルを $\pi$ としたとき，$\sum_{(i, j) \in A} c_{ij}^{\pi} x_{ij}$ の最小化を考えます．&lt;br>
$\sum_{(i, j) \in A} c_{ij}^{\pi} x_{ij}$ を最小化することは $\sum_{(i, j) \in L} c_{ij}^{\pi} x_{ij} - \sum_{(i, j) \in U} |c_{ij}^{\pi}| x_{ij}$ を最小化すること等しいです．&lt;/p>
&lt;p>$\forall (i, j) \in L$ に対して $x_{ij} \ge x_{ij}^{\ast} = l_{ij}$ であり，$\forall (i, j) \in U$ に対して $x_{ij} \le x_{ij}^{\ast} = u_{ij}$ であるため，$x^{\ast}$ の目的関数値は $x$ の目的関数値以下となります．&lt;br>
以上のことから，最適性条件を満たす spanning tree structure は最適解となることがわかりました．&lt;/p>
&lt;h2 id="参考">参考
&lt;/h2>&lt;ul>
&lt;li>&lt;a class="link" href="https://www.amazon.co.jp/dp/1292042702" target="_blank" rel="noopener"
>Network Flows: Pearson New International Edition&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://homes.di.unimi.it/righini/Didattica/OttimizzazioneCombinatoria/MaterialeOC/9b%20-%20NetworkSimplex.pdf" target="_blank" rel="noopener"
>The network simplex algorithm&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://coral.ise.lehigh.edu/~ted/teaching/ie411/" target="_blank" rel="noopener"
>IE 411: Graphs and Network Flows (Python)&lt;/a>&lt;/li>
&lt;/ul>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>正確には，実行可能領域に下界が存在するならば最適 spanning tree solution が少なくとも 1 つ存在します．&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2">
&lt;p>全域木の辺として restricted arc を選ぶこともできます&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:3">
&lt;p>辺 (i, j) に対し頂点 j から頂点 i に flow を流すと，辺 (i, j) の flow を減らすことになります．例えば，辺 (2, 1) に対して頂点 1 から頂点 2 に flow を流すと，辺 (2, 1) の flow は 1 減り，コストは 5 下がります．&amp;#160;&lt;a href="#fnref:3" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:4">
&lt;p>辺の lower が 0 でない場合，先に lower 分の flow を流しておきます．&amp;#160;&lt;a href="#fnref:4" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:5">
&lt;p>$\delta \gt 0$ である pivot&amp;#160;&lt;a href="#fnref:5" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:6">
&lt;p>$\delta = 0$ である pivot&amp;#160;&lt;a href="#fnref:6" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>Green Hackenbush の木のグランディ数</title><link>https://miti-7.github.io/post/green-hackenbush-%E3%81%AE%E6%9C%A8%E3%81%AE%E3%82%B0%E3%83%A9%E3%83%B3%E3%83%87%E3%82%A3%E6%95%B0/</link><pubDate>Tue, 10 Sep 2024 00:00:00 +0900</pubDate><guid>https://miti-7.github.io/post/green-hackenbush-%E3%81%AE%E6%9C%A8%E3%81%AE%E3%82%B0%E3%83%A9%E3%83%B3%E3%83%87%E3%82%A3%E6%95%B0/</guid><description>&lt;img src="https://miti-7.github.io/post/green-hackenbush-%E3%81%AE%E6%9C%A8%E3%81%AE%E3%82%B0%E3%83%A9%E3%83%B3%E3%83%87%E3%82%A3%E6%95%B0/images/%E3%82%B3%E3%83%AD%E3%83%B3%E5%8E%9F%E7%90%86%E3%81%AE%E4%BE%8B.png" alt="Featured image of post Green Hackenbush の木のグランディ数" />&lt;h2 id="1-はじめに">1. はじめに
&lt;/h2>&lt;p>Green Hackenbush は以下のルールをもつ有限型不偏ゲームです．&lt;/p>
&lt;ul>
&lt;li>点線で表された地面，点，点と点を結ぶ有限個の辺からなる図形がある&lt;/li>
&lt;li>どの図形のどの部分も辺をたどると地面につながる&lt;/li>
&lt;li>2 人のプレーヤーは交互に図形から 1 つの辺を選んで取り除く．選んだ辺を取り除くことで地面とつながらなくなってしまう部分は辺と同時に取り除かれる&lt;/li>
&lt;li>最後の辺をとったプレーヤーの勝ち&lt;/li>
&lt;/ul>
&lt;p>Green Hackenbush は有限型不偏ゲームなので各図形のグランディ数を求めることができます．今回は木と呼ばれる図形のグランディ数を求めていきます．&lt;br>
節 2 と 節 3 では Green Hackenbush で一般に適用できる性質を確認します．節 4 と 節 5 ではこの性質を利用し具体的な図形のグランディ数を求める方法を示します．&lt;br>
最後に節 6 で Green Hackenbush の木のグランディ数を求める問題を紹介します．&lt;/p>
&lt;h2 id="2-地面の点の移動">2. 地面の点の移動
&lt;/h2>&lt;p>地面上にある点を移動してもゲームのグランディ数は変わらないので，自由に移動させることができます．&lt;/p>
&lt;img src="images/地面の点の移動.png" width="50%">
&lt;h2 id="3-コロン原理colon-principle">3. コロン原理(Colon Principle)
&lt;/h2>&lt;p>コロン原理&lt;br>
図形 A のグランディ数を $g(A)$ とする．地面についている図形 $G$ と宙に浮いている図形 $H$ が 1 つの点 $a$ のみを共有してできる図形を $H \cup_a G$ と表す．このとき，宙に浮いている図形 $H$，$K$ が $g(H) = g(K)$ を満たすならば，$g(H \cup_a G) = g(K \cup_a G)$ となる．&lt;/p>
&lt;img src="images/コロン原理.png" width="50%">
&lt;details>&lt;summary>証明&lt;/summary>
&lt;p>$g(H \cup_a G) = g(K \cup_a G)$ ということは，$g(H \cup_a G) \ xor \ g(K \cup_a G) = 0$ なので，$H \cup_a G と K \cup_a G$ の直和ゲームは後手必勝と言い換えることができます．よって，「$g(H) = g(K)$ を満たすならば後手必勝」を示します．
また，$H \cup_a G$ と $K \cup_a G$ は対称なので，$H \cup_a G$ から辺を取り除く場合のみ考えます．&lt;/p>
&lt;p>先手の手は，「1. $G$ から辺を取り除く」，「2. $H$ から辺を取り除く」の 2 通りです．先手の各手について後手の必勝手を考えます．
グランディ数の定義より，グランディ数 g の局面からはグランディ数 g 未満の局面に遷移できることを利用します．&lt;/p>
&lt;ol>
&lt;li>
&lt;p>先手が $H \cup_a G$ の $G$ から辺を取り除く場合&lt;/p>
&lt;ul>
&lt;li>後手は $K \cup_a G$ の $G$ から同じ辺を取り除けばいい&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>先手が $H ∪_a G$ の $H$ から辺を取り除き，$H^\prime $ にした場合&lt;/p>
&lt;ul>
&lt;li>
&lt;p>$g(H^\prime) &amp;lt; g(H)$ の場合&lt;/p>
&lt;ul>
&lt;li>仮定より $g(H) = g(K)$ なので，$K$ から辺を取り除いて移行できる $K^\prime$ で，$g(K^\prime) = g(H^\prime)$ となるものがある．後手は $K → K^\prime$ となる辺を取り除けばいい．&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>$g(H^\prime) &amp;gt; g(H)$ の場合&lt;/p>
&lt;ul>
&lt;li>$H^\prime$ から辺を取り除いて移行できる $H^{\prime \prime}$ で， $g(H^{\prime \prime}) = g(H) = g(K)$ となるものがある．後手は $H^\prime → H^{\prime \prime}$ となる辺を取り除けばいい．&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;/details>
&lt;p>コロン原理を使うことで，ある 1 つの点のみを共有している宙に浮いている図形は，同じグランディ数を持つより単純な図形に置き換えることができます．&lt;/p>
&lt;img src="images/コロン原理の例.png" width="50%">
&lt;h2 id="4-棒のグランディ数">4. 棒のグランディ数
&lt;/h2>&lt;p>まず，1 つの棒のみからなるゲームのグランディ数について考えます．&lt;br>
長さ m の棒からは，長さ m 未満の棒に遷移できるため，長さ m の棒のグランディ数は m となります．&lt;/p>
&lt;img src="images/棒のグランディ数.png" width="50%">
&lt;p>次に，複数の棒からなるゲームのグランディ数を考えます．&lt;br>
各棒は独立したゲームの局面とみなすことができるので，複数の棒からなるゲームのグランディ数は各棒のグランディ数の xor で求めることができます．&lt;br>
例えば，長さ 1, 1, 2 の棒からなるゲームのグランディ数は $1 \ xor \ 1 \ xor \ 2 = 2$ となります．&lt;/p>
&lt;img src="images/複数の棒のグランディ数.png" width="50%">
&lt;p>最後に，地面のある一点から複数の棒が伸びる図形のグランディ数を考えます．&lt;br>
地面の点は自由に移動することができるため，地面のある一点から複数の棒が伸びる図形は，複数の棒からなるゲームに帰着することができます．&lt;br>
よって，地面のある一点から複数の棒が伸びる図形のグランディ数は，各棒の長さの xor で求めることができます．&lt;/p>
&lt;img src="images/地上の点から複数の棒.png" width="75%">
&lt;h2 id="5-木のグランディ数">5. 木のグランディ数
&lt;/h2>&lt;p>コロン原理を順次適用していくことによって，木のグランディ数を求めることができます．&lt;br>
地面のある一点から複数の棒が伸びている図形のグランディ数は，各棒の長さの xor で求めることができました．コロン原理により，ある一点から複数の棒が伸びているような木の点は，各棒の長さの xor をとった値の長さの棒に変換することができます．この操作を繰り返すことで木のグランディ数を求めることができます．&lt;/p>
&lt;img src="images/コロン原理_木.png" width="50%">
&lt;p>以下に例を示します．&lt;br>
点 a からは，長さ 1 の棒と長さ 3 の棒が伸びています．よって，長さ 1 xor 3 = 2 の棒に置き換えることができます．&lt;br>
点 b からは，長さ 1 の棒と長さ 3 の棒が伸びています．よって，長さ 1 xor 3 = 2 の棒に置き換えることができます．&lt;br>
点 c からは，長さ 2 の棒と長さ 3 の棒と長さ 1 の棒が伸びています．よって，長さ 2 xor 3 xor 1 = 0 の棒に置き換えることができます．&lt;br>
以上のことからこの木のグランディ数は 0 と求めることができました．&lt;/p>
&lt;img src="images/木のグランディ数の例.png" width="75%">
&lt;h2 id="6-agc017-d---game-on-tree">6. AGC017 D - Game on Tree
&lt;/h2>&lt;p>Green Hackenbush の木のグランディ数を求める問題として，&lt;a class="link" href="https://atcoder.jp/contests/agc017/tasks/agc017_d" target="_blank" rel="noopener"
>D - Game on Tree&lt;/a> があります．&lt;br>
ある頂点のグランディ数は，「自分の子のグランディ数 + 1」 の xor を使って求めことができるので，根から深さ優先探索をすることで木のグランディ数を求めることができます．&lt;br>
&lt;a class="link" href="https://atcoder.jp/contests/agc017/submissions/56666314" target="_blank" rel="noopener"
>提出コード&lt;/a>&lt;/p>
&lt;h2 id="参考">参考
&lt;/h2>&lt;ul>
&lt;li>&lt;a class="link" href="https://www.sugakushobo.co.jp/903342_76_mae.html" target="_blank" rel="noopener"
>石取りゲームの数学&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://en.wikipedia.org/wiki/Hackenbush" target="_blank" rel="noopener"
>Hackenbush&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Archives</title><link>https://miti-7.github.io/archives/</link><pubDate>Tue, 28 May 2019 00:00:00 +0000</pubDate><guid>https://miti-7.github.io/archives/</guid><description/></item><item><title>Links</title><link>https://miti-7.github.io/links/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://miti-7.github.io/links/</guid><description/></item><item><title>Search</title><link>https://miti-7.github.io/search/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://miti-7.github.io/search/</guid><description/></item></channel></rss>