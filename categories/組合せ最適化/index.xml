<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>組合せ最適化 on Eating Your Own Cat Food</title><link>https://miti-7.github.io/categories/%E7%B5%84%E5%90%88%E3%81%9B%E6%9C%80%E9%81%A9%E5%8C%96/</link><description>Recent content in 組合せ最適化 on Eating Your Own Cat Food</description><generator>Hugo -- gohugo.io</generator><language>ja</language><lastBuildDate>Thu, 09 Jan 2025 00:00:00 +0900</lastBuildDate><atom:link href="https://miti-7.github.io/categories/%E7%B5%84%E5%90%88%E3%81%9B%E6%9C%80%E9%81%A9%E5%8C%96/index.xml" rel="self" type="application/rss+xml"/><item><title>Quadratic Pseudo-Boolean Optimization</title><link>https://miti-7.github.io/post/quadratic-pseudo-boolean-optimization/</link><pubDate>Thu, 09 Jan 2025 00:00:00 +0900</pubDate><guid>https://miti-7.github.io/post/quadratic-pseudo-boolean-optimization/</guid><description>&lt;img src="https://miti-7.github.io/post/quadratic-pseudo-boolean-optimization/images/general_sample_ab_1.png" alt="Featured image of post Quadratic Pseudo-Boolean Optimization" />&lt;h2 id="quadratic-pseudo-boolean-optimization">Quadratic Pseudo-Boolean Optimization
&lt;/h2>&lt;p>次の関数 $E(\bold x)$ を最小化する問題を考えます．$x_{p} \in \lbrace 0, 1 \rbrace$ とします．この問題を &lt;a class="link" href="https://en.wikipedia.org/wiki/Quadratic_pseudo-Boolean_optimization" target="_blank" rel="noopener"
>Quadratic Pseudo-Boolean Optimization&lt;/a>(以下 QPBO)と呼びます．&lt;/p>
$$
\begin{aligned}
E(\bold x) = \theta_{const} + \sum_p \theta_{p}(x_p) + \sum_{p \lt q} \theta_{pq}(x_p, x_q)
\end{aligned}
$$&lt;p>競プロ界隈で「燃やす埋める」や「Project Selection Problem」などと言われる問題は QPBO に帰着することができます&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>．&lt;br>
これらの問題は minimum s-t cut に帰着して解くことができますが，どのように辺を張るかなど混乱しがちです．本記事の目的は QPBO を解くアルゴリズムをライブラリ化することで，問題を解くときに辺の張り方や変数のフリップ操作などを考えなくてすむようにすることです．実装は &lt;a class="link" href="https://github.com/MitI-7/CompetitiveProgrammingLibrary/blob/1c8b83e0e54a6729cce7cf2c7eee09d1de0e4c05/library/cpp/optimization/QPBO.hpp" target="_blank" rel="noopener"
>QPBO.hpp&lt;/a> にあります．&lt;/p>
&lt;p>記事の構成は以下の通りです．&lt;br>
&lt;a class="link" href="#1-s-t-cut" >節 1&lt;/a> では s-t cut と minimum s-t cut の説明をします．minimum s-t cut は多項式時間で求めることができます．&lt;/p>
&lt;p>&lt;a class="link" href="#2-%e5%8d%98%e7%b4%94%e3%81%aa%e9%96%a2%e6%95%b0%e3%81%ae%e5%a0%b4%e5%90%88" >節 2&lt;/a> では関数 $E(\bold x)$ が $\theta_{pq}(0, 0) = \theta_{pq}(1, 1) = 0$ であり，どの関数も $0$ 以上の値を返すという単純な関数の場合について考えます．
この場合は minimum s-t cut を見つける問題にそのまま帰着できます．&lt;/p>
&lt;p>&lt;a class="link" href="#3-%e5%8a%a3%e3%83%a2%e3%82%b8%e3%83%a5%e3%83%a9%e9%96%a2%e6%95%b0%e3%81%ae%e5%a0%b4%e5%90%88" >節 3&lt;/a> では関数 $E(\bold x)$ が劣モジュラ関数の場合について考えます．&lt;br>
この場合は再パラメータ化という操作を行うことで単純な関数の場合に帰着させることができます．&lt;/p>
&lt;p>&lt;a class="link" href="#4-%e4%b8%80%e8%88%ac%e3%81%ae%e9%96%a2%e6%95%b0%e3%81%ae%e5%a0%b4%e5%90%88" >節 4&lt;/a> では関数 $E(\bold x)$ が一般の関数の場合について考えます．&lt;br>
$E(\bold x)$ が一般の関数の場合，これを最小化する問題は NP-hard であり，多項式時間で解くことは(今のところ)できそうもありません．この場合は問題を緩和することで劣モジュラ関数の場合に帰着させることができます．さらに，ここで得られた解は最適解の一部となることが保証されます．&lt;/p>
&lt;p>&lt;a class="link" href="#5-%e5%95%8f%e9%a1%8c" >節 5&lt;/a> では競プロの問題をいくつか解いていきます．&lt;/p>
&lt;p>表記が煩雑になるのを避けるため以降は関数値を以下のように表記することがあります．&lt;/p>
&lt;div style="display: flex; gap: 20px;">
&lt;div>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>$\theta_{p}(0)$&lt;/td>
&lt;td>$\theta_{p;0}$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$\theta_{p}(1)$&lt;/td>
&lt;td>$\theta_{p;1}$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$\theta_{pq}(0,0)$&lt;/td>
&lt;td>$\theta_{pq;00}$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$\theta_{pq}(0,1)$&lt;/td>
&lt;td>$\theta_{pq;01}$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$\theta_{pq}(1,0)$&lt;/td>
&lt;td>$\theta_{pq;10}$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$\theta_{pq}(1,1)$&lt;/td>
&lt;td>$\theta_{pq;11}$&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/div>
&lt;/div>
&lt;h2 id="1-s-t-cut">1. s-t cut
&lt;/h2>&lt;p>頂点集合 $V$ と 有向辺 $E$ からなる有向グラフ $G = (V, E)$ が与えられます．辺 (i, j) には容量 $c_{i, j} \ge 0$ が定まっているものとします．&lt;br>
頂点集合 $V$ を 2 つの部分集合 $S$ と $T = V \backslash S$ に分割します．2 つのノード $s$ と $t$ について $s \in S$，$t \in T$ となるようなカットを s-t cut と呼びます．&lt;br>
$S$ から出て $T$ に入るような辺の容量の総和を s-t cut の容量と呼び，以下で定義されます．すべての s-t cut のうち最小のものを minimum s-t cut と呼びます．&lt;/p>
$$
\begin{aligned}
c(S) = \sum_{(i, j) \in (S, T)} c_{ij}
\end{aligned}
$$&lt;p>下のグラフの s-t cut の例をいくつか見ていきます &lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>．&lt;/p>
&lt;img src="images/s-t-cut_sample1.png" width="50%">
&lt;p>頂点の部分集合として，$S = \lbrace s, 0, 1 \rbrace$ を選んだとします．&lt;br>
$S$ に属する頂点を赤，$T = V \backslash S$ に属する頂点を青で示します． $S$ から出て $T$ に入るような辺は辺 (0, 2) と辺 (1, 3) です．よって，この s-t cut の容量は 3 + 2 = 5 となります．&lt;br>
すべての s-t cut の中でこのカットより容量の小さい s-t cut は存在しないのでこれは minimum s-t cut です．&lt;/p>
&lt;img src="images/s-t-cut_sample2.png" width="50%">
&lt;p>頂点の部分集合として $S = \lbrace s, 0, 1, 2, 3 \rbrace$ を選んだとします．&lt;br>
この s-t cut の容量は 2 + 3 = 5 となります．&lt;br>
このカットも minimum s-t cut です．このように minimum s-t cut は複数存在することがあります．&lt;/p>
&lt;img src="images/s-t-cut_sample3.png" width="50%">
&lt;p>頂点の部分集合として $S = \lbrace s, 1, 2 \rbrace$ を選んだとします．&lt;br>
この s-t cut の容量は，3 + 2 + 4 + 2 = 11 となります．&lt;br>
辺 (0, 1) や辺 (0, 2) は $T$ から $S$ に入る辺なので含まれません．&lt;/p>
&lt;img src="images/s-t-cut_sample4.png" width="50%">
&lt;p>minimum s-t cut は最大流問題を解き，残余ネットワーク上で頂点 $s$ から到達できる頂点集合を $S$ とすることで求められます．詳しくは &lt;a class="link" href="https://ja.wikipedia.org/wiki/%E6%9C%80%E5%A4%A7%E3%83%95%E3%83%AD%E3%83%BC%E6%9C%80%E5%B0%8F%E3%82%AB%E3%83%83%E3%83%88%E5%AE%9A%E7%90%86" target="_blank" rel="noopener"
>最大フロー最小カット定理&lt;/a> などを参照してください．&lt;br>
次節から s-t cut を使って $E(\bold x)$ を最小化する方法を見ていきます．&lt;/p>
&lt;h2 id="2-単純な関数の場合">2. 単純な関数の場合
&lt;/h2>&lt;p>関数 $E(\bold x)$ を最小化する方法を考えていきます．&lt;br>
単純な関数の場合を考えたいので，この関数は $\theta_{pq}(0, 0) = \theta_{pq}(1, 1) = 0$ であり，どの関数も 0 以上の値を返すと仮定します．&lt;/p>
$$
\begin{aligned}
E(\bold x) = \theta_{const} + \sum_{p} \theta_{p}(x_p) + \sum_{p \lt q} \theta_{pq}(x_p, x_q)
\end{aligned}
$$&lt;p>上記仮定を満たす関数の場合は下の表のルールに従ってグラフを構築することができます．このグラフの s-t cut は $E(\bold x)$ の解と 1 対 1 対応します．&lt;br>
よって，グラフの minimum s-t cut がわかれば $E(\bold x)$ の最小解を求めることができます．&lt;/p>
&lt;div style="display: flex; gap: 20px;">
&lt;div>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>$\theta$&lt;/th>
&lt;th>edge&lt;/th>
&lt;th>capacity&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>$\theta_{p;0}$&lt;/td>
&lt;td>$p \rightarrow t$&lt;/td>
&lt;td>$\theta_{p;0}$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$\theta_{p;1}$&lt;/td>
&lt;td>$s \rightarrow p$&lt;/td>
&lt;td>$\theta_{p;1}$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$\theta_{pq;01}$&lt;/td>
&lt;td>$p \rightarrow q$&lt;/td>
&lt;td>$\theta_{pq;01}$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$\theta_{pq;10}$&lt;/td>
&lt;td>$q \rightarrow p$&lt;/td>
&lt;td>$\theta_{pq;10}$&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/div>
&lt;/div>
&lt;p>具体例として，変数が $a$ と $b$ の 2 つだけの場合を見てみます．&lt;br>
各変数の値に対応する $E(\bold x) = \theta_a(a) + \theta_b(b) + \theta_{ab}(a, b)$ の値は以下のようになります．$\theta_{ab}(0, 0)$ と $\theta_{ab}(1, 1)$ は $0$ なので省略しています．&lt;/p>
&lt;div style="display: flex; gap: 20px;">
&lt;div>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>a&lt;/th>
&lt;th>b&lt;/th>
&lt;th>$E(\bold x)$&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>0&lt;/td>
&lt;td>0&lt;/td>
&lt;td>$\theta_{a}(0) + \theta_{b}(0)$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0&lt;/td>
&lt;td>1&lt;/td>
&lt;td>$\theta_{a}(0) + \theta_{b}(1) + \theta_{ab}(0, 1)$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>0&lt;/td>
&lt;td>$\theta_{a}(1) + \theta_{b}(0) + \theta_{ab}(1, 0)$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>1&lt;/td>
&lt;td>$\theta_{a}(1) + \theta_{b}(1)$&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/div>
&lt;/div>
&lt;p>ルールに従うと下のグラフが構築されます．&lt;br>
このグラフの s-t cut をいくつか見ていきます．&lt;/p>
&lt;img src="images/simple_graph.png" width="25%">
&lt;p>$S = \lbrace s, a, b \rbrace$ とします．この s-t cut の容量は $\theta_{a}(0) + \theta_{b}(0)$ です．&lt;br>
この s-t cut の容量は $a = 0$，$b = 0$ としたときの $E(\bold x)$ の目的関数と一致します．&lt;/p>
&lt;img src="images/simple_cut1.png" width="25%">
&lt;p>別の s-t cut の例をみます．&lt;br>
$S = \lbrace s, a \rbrace$ とします．この s-t cut の容量は $\theta_{a}(0) + \theta_{b}(1) + \theta_{ab}(0, 1)$ です．&lt;br>
この s-t cut の容量は $a = 0$，$b = 1$ としたときの $E(\bold x)$ の目的関数値と一致します．&lt;/p>
&lt;img src="images/simple_cut2.png" width="25%">
&lt;p>変数が 2 つの場合は s-t cut は $2^2$ 通りあります．すべてのパターンは以下の通りです．&lt;/p>
&lt;img src="images/simple_cut_all.png" width="50%">
&lt;p>s-t cut の構成と $E(\bold x) $ の構成が 1 対 1 対応するため，minimum s-t cut を計算することで $E(\bold x)$ の最小値を求めることができます．&lt;br>
minimum s-t cut を計算し，$S$ に属する頂点に対応する変数の値を $0$，$T$ に属する頂点に対応する変数の値を $1$ と設定することで $\bold x$ を構成できます．&lt;/p>
&lt;h2 id="3-劣モジュラ関数の場合">3. 劣モジュラ関数の場合
&lt;/h2>&lt;p>「&lt;a class="link" href="#2-%e5%8d%98%e7%b4%94%e3%81%aa%e9%96%a2%e6%95%b0%e3%81%ae%e5%a0%b4%e5%90%88" >2. 単純な関数の場合&lt;/a>」では，$\theta_{pq}(0, 0) = \theta_{pq}(1, 1) = 0$ とし，どの関数も $0$ 以上の値を返すことを仮定していました．&lt;br>
この節では関数は劣モジュラを仮定します．今回は 2 値変数を考えているので，$\theta_{pq}(0, 1) + \theta_{pq}(1, 0) \ge \theta_{pq}(0, 0) + \theta_{pq}(1, 1)$ を満たすものとします．&lt;br>
「&lt;a class="link" href="#2-%e5%8d%98%e7%b4%94%e3%81%aa%e9%96%a2%e6%95%b0%e3%81%ae%e5%a0%b4%e5%90%88" >2. 単純な関数の場合&lt;/a>」は劣モジュラ関数の特殊な場合だったといえます．&lt;/p>
&lt;p>$\theta_{pq}(0, 0)$ や $\theta_{pq}(1, 1)$ が $0$ 以外の値をとったり関数値が負の値をとる場合があるので，今回はルール通りにグラフを作ることはできません．そこで再パラメータ化という操作を行います．再パラメータ化によって関数を標準形に変形します．以下の条件を満たす関数を標準形(normal form)と呼びます&lt;sup id="fnref:3">&lt;a href="#fn:3" class="footnote-ref" role="doc-noteref">3&lt;/a>&lt;/sup>．標準形ではどの関数も $0$ 以上の値をとります．&lt;/p>
&lt;ul>
&lt;li>$min \lbrace \theta_{p;0}, \theta_{p;1} \rbrace = 0$&lt;/li>
&lt;li>$min \lbrace \theta_{pq;00}, \theta_{pq;10} \rbrace = 0$&lt;/li>
&lt;li>$min \lbrace \theta_{pq;01}, \theta_{pq;11} \rbrace = 0$&lt;/li>
&lt;/ul>
&lt;p>再パラメータ化をすると，関数 $\theta_{pq}(x_{p}, x_{q})$ が劣モジュラの場合は $\theta_{pq}(0, 0) = \theta_{pq}(1, 1) = 0$ に，関数 $\theta_{pq}(x_{p}, x_{q})$ が優モジュラの場合は $\theta_{pq}(0, 1) = \theta_{pq}(1, 0) = 0$ になります&lt;sup id="fnref:4">&lt;a href="#fn:4" class="footnote-ref" role="doc-noteref">4&lt;/a>&lt;/sup>．&lt;br>
よって，すべての $\theta_{pq}(x_{p}, x_{q})$ が劣モジュラ関数の場合は「&lt;a class="link" href="#2-%e5%8d%98%e7%b4%94%e3%81%aa%e9%96%a2%e6%95%b0%e3%81%ae%e5%a0%b4%e5%90%88" >2. 単純な関数の場合&lt;/a>」に帰着することができます．&lt;br>
再パラメータ化の手続きは以下の通りです．&lt;/p>
&lt;ul>
&lt;li>step1
&lt;ul>
&lt;li>すべての (p, q) の各 $j \in \lbrace 0, 1 \rbrace$ について
&lt;ul>
&lt;li>$\delta = min \lbrace \theta_{pq}(0, j), P_{pq}(1, j) \rbrace$&lt;/li>
&lt;li>$\theta_{pq}(0, j) = \theta_{pq}(0, j) - \delta$&lt;/li>
&lt;li>$\theta_{pq}(1, j) = \theta_{pq}(1, j) - \delta$&lt;/li>
&lt;li>$\theta_{q}(j) = \theta_{q}(j) - \delta$&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>step2
&lt;ul>
&lt;li>$\delta = min \lbrace \theta_p(0), \theta_p(1) \rbrace$&lt;/li>
&lt;li>$\theta_{p}(0) = \theta_{p}(0) - \delta$&lt;/li>
&lt;li>$\theta_{p}(1) = \theta_{p}(1) - \delta$&lt;/li>
&lt;li>$\theta_{const} = \theta_{const} + \delta$&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;details>&lt;summary>再パラメータ化の具体例&lt;/summary>
&lt;p>$a$ と $b$ の 2 変数があり，各関数は以下の値をとるとします．&lt;/p>
&lt;div style="display: flex; gap: 20px;">
&lt;div>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>$\theta$&lt;/th>
&lt;th>関数値&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>$\theta_{const}$&lt;/td>
&lt;td>0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$\theta_a(0)$&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$\theta_a(1)$&lt;/td>
&lt;td>2&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$\theta_b(0)$&lt;/td>
&lt;td>-7&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$\theta_b(1)$&lt;/td>
&lt;td>10&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$\theta_{ab}(0, 0)$&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$\theta_{ab}(0, 1)$&lt;/td>
&lt;td>2&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$\theta_{ab}(1, 0)$&lt;/td>
&lt;td>3&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$\theta_{ab}(1, 1)$&lt;/td>
&lt;td>-4&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/div>
&lt;/div>
&lt;p>step1&lt;/p>
&lt;ul>
&lt;li>$j = 0$ について
&lt;ul>
&lt;li>$\delta = min \lbrace \theta_{ab}(0, 0), P_{ab}(1, 0) \rbrace = min \lbrace 1, 3 \rbrace = 1$&lt;/li>
&lt;li>$\theta_{ab}(0, 0) = \theta_{ab}(0, 0) - 1$&lt;/li>
&lt;li>$\theta_{ab}(1, 0) = \theta_{ab}(1, 0) - 1$&lt;/li>
&lt;li>$\theta_{b}(0) = \theta_{b}(0) - 1$&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>$j = 1$ について
&lt;ul>
&lt;li>$\delta = min \lbrace \theta_{ab}(0, 1), P_{ab}(1, 1) \rbrace = min \lbrace 2, -4 \rbrace = -4$&lt;/li>
&lt;li>$\theta_{ab}(0, 1) = \theta_{ab}(0, 1) - (-4)$&lt;/li>
&lt;li>$\theta_{ab}(1, 1) = \theta_{ab}(1, 1) - (-4)$&lt;/li>
&lt;li>$\theta_{b}(1) = \theta_{b}(1) - (-4)$&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>step 2&lt;/p>
&lt;ul>
&lt;li>
&lt;p>$p = a$ について&lt;/p>
&lt;ul>
&lt;li>$\delta = min \lbrace \theta_a(0), \theta_a(1) \rbrace = min \lbrace 1, 2 \rbrace = 1$&lt;/li>
&lt;li>$\theta_{a}(0) = \theta_{a}(0) - 1$&lt;/li>
&lt;li>$\theta_{a}(1) = \theta_{a}(1) - 1$&lt;/li>
&lt;li>$\theta_{const} = \theta_{const} + 1$&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>$p = b$ について&lt;/p>
&lt;ul>
&lt;li>$\delta = min \lbrace \theta_b(0), \theta_b(1) \rbrace = min \lbrace -8, 14 \rbrace = -8$&lt;/li>
&lt;li>$\theta_{b}(0) = \theta_{b}(0) - (-8)$&lt;/li>
&lt;li>$\theta_{b}(1) = \theta_{b}(1) - (-8)$&lt;/li>
&lt;li>$\theta_{const} = \theta_{const} + (-8)$&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>各処理後の関数値の値は以下の通りです．最終的に標準形になっていることがわかります．&lt;/p>
&lt;div style="display: flex; gap: 20px;">
&lt;div>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>$\theta$&lt;/th>
&lt;th>&lt;/th>
&lt;th>step1(j = 0)&lt;/th>
&lt;th>step1(j = 1)&lt;/th>
&lt;th>step 2(p = a)&lt;/th>
&lt;th>step2(p = b)&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>$\theta_{const}$&lt;/td>
&lt;td>0&lt;/td>
&lt;td>0&lt;/td>
&lt;td>0&lt;/td>
&lt;td>&lt;strong>1&lt;/strong>&lt;/td>
&lt;td>&lt;strong>9&lt;/strong>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$\theta_a(0)$&lt;/td>
&lt;td>1&lt;/td>
&lt;td>1&lt;/td>
&lt;td>1&lt;/td>
&lt;td>&lt;strong>0&lt;/strong>&lt;/td>
&lt;td>0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$\theta_a(1)$&lt;/td>
&lt;td>2&lt;/td>
&lt;td>2&lt;/td>
&lt;td>2&lt;/td>
&lt;td>&lt;strong>1&lt;/strong>&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$\theta_b(0)$&lt;/td>
&lt;td>-7&lt;/td>
&lt;td>&lt;strong>-8&lt;/strong>&lt;/td>
&lt;td>-8&lt;/td>
&lt;td>-8&lt;/td>
&lt;td>&lt;strong>0&lt;/strong>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$\theta_b(1)$&lt;/td>
&lt;td>10&lt;/td>
&lt;td>10&lt;/td>
&lt;td>&lt;strong>14&lt;/strong>&lt;/td>
&lt;td>14&lt;/td>
&lt;td>&lt;strong>22&lt;/strong>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$\theta_{ab}(0, 0)$&lt;/td>
&lt;td>1&lt;/td>
&lt;td>&lt;strong>0&lt;/strong>&lt;/td>
&lt;td>0&lt;/td>
&lt;td>0&lt;/td>
&lt;td>0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$\theta_{ab}(0, 1)$&lt;/td>
&lt;td>2&lt;/td>
&lt;td>2&lt;/td>
&lt;td>&lt;strong>6&lt;/strong>&lt;/td>
&lt;td>6&lt;/td>
&lt;td>6&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$\theta_{ab}(1, 0)$&lt;/td>
&lt;td>3&lt;/td>
&lt;td>&lt;strong>2&lt;/strong>&lt;/td>
&lt;td>2&lt;/td>
&lt;td>2&lt;/td>
&lt;td>2&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$\theta_{ab}(1, 1)$&lt;/td>
&lt;td>-4&lt;/td>
&lt;td>-4&lt;/td>
&lt;td>&lt;strong>0&lt;/strong>&lt;/td>
&lt;td>0&lt;/td>
&lt;td>0&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/div>
&lt;/div>
&lt;/details>
&lt;h1 id="4-一般の関数の場合">4. 一般の関数の場合
&lt;/h1>&lt;p>一般の関数の場合を考えます．&lt;br>
関数に何も仮定を置かない場合は $E(\bold x)$ の最小化は NP-hard なので，minimum s-t cut 問題に帰着できない場合があります．&lt;br>
この場合でも最適解はだせなくても問題を解けるだけ解く QPBO 法というアルゴリズムがあります&lt;sup id="fnref:5">&lt;a href="#fn:5" class="footnote-ref" role="doc-noteref">5&lt;/a>&lt;/sup>．QPBO 法は解として $x_p = \lbrace 0, 1, \emptyset \rbrace$ のいずれかを与えます．$\emptyset$ は解が不明であることを表します．$0$ か $1$ の値が与えられたとき，ラベル付けされたといいます．&lt;br>
このアルゴリズムは次のような性質があります．&lt;/p>
&lt;ol>
&lt;li>アルゴリズムの出力を $\bold x$ とする．完全にラベル付けされた任意の解 $\bold y$ があるとき，以下のように $\bold z$ を定めると常に $E(\bold z) \le E(\bold y)$ を満たす．&lt;/li>
&lt;/ol>
$$
z_p = \left\{
\begin{array}{ll}
x_p &amp; \text{if} \space x_p \in \lbrace 0, 1 \rbrace \\
y_p &amp; \text{if} \space x_p = \emptyset
\end{array}
\right.
$$&lt;ol start="2">
&lt;li>関数のすべての項が劣モジュラのとき最適解が求まる．&lt;/li>
&lt;li>アルゴリズムはフリップ操作に対して不変である．&lt;/li>
&lt;/ol>
&lt;p>性質 1 で $\bold y$ に最適解を選べば $\bold x$ は常に最適解の一部となることがわかります．&lt;br>
競プロで役に立つのは性質 3，4 です．この 2 つの性質から，すべての項を劣モジュラにするようなフリップ操作がある場合に QPBO 法は最適解を求めることができます．&lt;/p>
&lt;p>QPBO 法を説明します．&lt;br>
各変数 $x_p$ に対して，$x_{\bar{p}} = 1 - x_{p}$ を導入し，$E(\bold x) = \sum \theta_{p}(x_p) + \sum \theta_{pq}(x_p, x_q)$ を変形します．&lt;/p>
$$
\begin{alignedat}{2}
E(\bold x)
&amp;= \theta_{const} + \sum \theta_{p}(x_p)
&amp;&amp;+ \sum \theta_{pq}(x_p, x_q) \\
&amp;= \theta_{const} + \sum \big(
\theta_{p;1} x_{p} + \theta_{p;0}(1 - x_{p})
\big) \\
&amp;\quad &amp;&amp;+
\sum \big(
\theta_{pq;00} (1 - x_{p})(1 - x_{q}) \\
&amp;\quad &amp;&amp;\quad +
\theta_{pq;01} (1 - x_{p}) x_{q} \\
&amp;\quad &amp;&amp;\quad +
\theta_{pq;10} x_{p}(1 - x_{q}) \\
&amp;\quad &amp;&amp;\quad +
\theta_{pq;11} x_{p} x_{q}
\big) \\
&amp;= \theta_{const} + \sum \bigg(
\frac{\theta_{p;1}}{2}(x_p + (1 - x_{\bar{p}})) &amp;&amp;
+ \frac{\theta_{p;0}}{2}(x_{\bar{p}} + (1 - x_p))
\bigg) \\
&amp;\quad &amp;&amp;+
\sum \bigg(
\frac{\theta_{pq;00}}{2} \big(x_{\bar{p}} (1 - x_q) + (1 - x_p) x_{\bar{q}} \big) \\
&amp;\quad &amp;&amp;\quad +
\frac{\theta_{pq;01}}{2} \big((1 - x_p) x_q + x_{\bar{p}} (1 - x_{\bar{q}}) \big) \\
&amp;\quad &amp;&amp;\quad +
\frac{\theta_{pq;11}}{2} \big(x_p (1 - x_{\bar{q}}) + (1 - x_{\bar{p}}) x_q \big) \\
&amp;\quad &amp;&amp;\quad +
\frac{\theta_{pq;10}}{2} \big(x_p (1 - x_q) + (1 - x_{\bar{p}}) x_{\bar{q}} \big)
\bigg)
\end{alignedat}
$$&lt;p>ここで，$x_{\bar{p}} = 1 - x_p$ という制約を緩和し，$x_p$ と $x_{\bar{p}}$ が独立に値をとれる緩和問題を考えます．&lt;br>
各変数の係数を比較すると下の関数に分割できることがわかります．
再パラメータ化をしてから関数を分割することですべての関数値が $0$ 以上であることが保証されます．これらの関数は劣モジュラ関数なので「&lt;a class="link" href="#3-%e5%8a%a3%e3%83%a2%e3%82%b8%e3%83%a5%e3%83%a9%e9%96%a2%e6%95%b0%e3%81%ae%e5%a0%b4%e5%90%88" >3. 劣モジュラ関数の場合&lt;/a>」に帰着することができます．&lt;/p>
&lt;div style="display: flex; gap: 20px;">
&lt;div>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>$x_p$&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>0&lt;/td>
&lt;td>$\frac{1}{2}\theta_{p;0}$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>$\frac{1}{2}\theta_{p;1}$&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/div>
&lt;div>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>$x_{\bar{p}}$&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>0&lt;/td>
&lt;td>$\frac{1}{2}\theta_{p;1}$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>$\frac{1}{2}\theta_{p;0}$&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/div>
&lt;/div>
&lt;div style="display: flex; gap: 20px;">
&lt;div>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>$x_p$&lt;/th>
&lt;th>$x_q$&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>0&lt;/td>
&lt;td>0&lt;/td>
&lt;td>0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0&lt;/td>
&lt;td>1&lt;/td>
&lt;td>$\frac{1}{2}\theta_{pq;01}$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>0&lt;/td>
&lt;td>$\frac{1}{2}\theta_{pq;10}$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>1&lt;/td>
&lt;td>0&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/div>
&lt;div>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>$x_p$&lt;/th>
&lt;th>$x_{\bar{q}}$&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>0&lt;/td>
&lt;td>0&lt;/td>
&lt;td>0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0&lt;/td>
&lt;td>1&lt;/td>
&lt;td>$\frac{1}{2}\theta_{pq;00}$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>0&lt;/td>
&lt;td>$\frac{1}{2}\theta_{pq;11}$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>1&lt;/td>
&lt;td>0&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/div>
&lt;div>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>$x_{\bar{p}}$&lt;/th>
&lt;th>$x_q$&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>0&lt;/td>
&lt;td>0&lt;/td>
&lt;td>0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0&lt;/td>
&lt;td>1&lt;/td>
&lt;td>$\frac{1}{2}\theta_{pq;11}$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>0&lt;/td>
&lt;td>$\frac{1}{2}\theta_{pq;00}$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>1&lt;/td>
&lt;td>0&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/div>
&lt;div>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>$x_{\bar{p}}$&lt;/th>
&lt;th>$x_{\bar{q}}$&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>0&lt;/td>
&lt;td>0&lt;/td>
&lt;td>0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0&lt;/td>
&lt;td>1&lt;/td>
&lt;td>$\frac{1}{2}\theta_{pq;01}$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>0&lt;/td>
&lt;td>$\frac{1}{2}\theta_{pq;10}$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>1&lt;/td>
&lt;td>0&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/div>
&lt;/div>
&lt;p>上記関数について，ルールに従ってグラフを構築します．
整理すると以下のルールに従ってグラフを構築すればいいことがわかります．&lt;/p>
&lt;div style="display: flex; gap: 20px;">
&lt;div>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>$\theta$&lt;/th>
&lt;th>edge&lt;/th>
&lt;th>capacity&lt;sup id="fnref:6">&lt;a href="#fn:6" class="footnote-ref" role="doc-noteref">6&lt;/a>&lt;/sup>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>$\theta_{p;0}$&lt;/td>
&lt;td>$(p \rightarrow t), (s \rightarrow \bar p)$&lt;/td>
&lt;td>$\frac{1}{2} \theta_{p;0}$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$\theta_{p;1}$&lt;/td>
&lt;td>$(s \rightarrow p), (\bar p \rightarrow t)$&lt;/td>
&lt;td>$\frac{1}{2} \theta_{p;1}$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$\theta_{pq;01}$&lt;/td>
&lt;td>$(p \rightarrow q), (\bar q \rightarrow \bar p)$&lt;/td>
&lt;td>$\frac{1}{2} \theta_{pq;01}$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$\theta_{pq;10}$&lt;/td>
&lt;td>$(q \rightarrow p), (\bar p \rightarrow \bar q)$&lt;/td>
&lt;td>$\frac{1}{2} \theta_{pq;10}$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$\theta_{pq;00}$&lt;/td>
&lt;td>$(p \rightarrow \bar q), (q \rightarrow \bar p)$&lt;/td>
&lt;td>$\frac{1}{2} \theta_{pq;00}$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$\theta_{pq;11}$&lt;/td>
&lt;td>$(\bar q \rightarrow p), (\bar p \rightarrow q)$&lt;/td>
&lt;td>$\frac{1}{2} \theta_{pq;11}$&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/div>
&lt;/div>
&lt;p>このグラフの s-t minimum cut を計算します．各変数の値は，$S$ に属する場合は 0，$T$ に属する場合は 1 をとります．ただし，$x_{\bar{p}} = 1 - x_{p}$ という制約を満たす必要があります．よって，$\bold x$ は次のように構成されます．&lt;/p>
$$
x_{p} = \left\{
\begin{array}{ll}
0 &amp; \text{if} \space p \in S, \bar p \in T \\
1 &amp; \text{if} \space p \in T, \bar p \in S \\
\emptyset &amp; \text{otherwise}
\end{array}
\right.
$$&lt;p>具体例として，変数が $a$ と $b$ の 2 つだけの場合を考えます．&lt;br>
各変数の値に対応する $E(\bold x) = \theta_a(a) + \theta_b(b) + \theta_{ab}(a, b)$ の値は以下のようになります．&lt;/p>
&lt;div style="display: flex; gap: 20px;">
&lt;div>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>a&lt;/th>
&lt;th>b&lt;/th>
&lt;th>$E(\bold x)$&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>0&lt;/td>
&lt;td>0&lt;/td>
&lt;td>$\theta_{a}(0) + \theta_{b}(0) + \theta_{ab}(0, 0)$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0&lt;/td>
&lt;td>1&lt;/td>
&lt;td>$\theta_{a}(0) + \theta_{b}(1) + \theta_{ab}(0, 1)$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>0&lt;/td>
&lt;td>$\theta_{a}(1) + \theta_{b}(0) + \theta_{ab}(1, 0)$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>1&lt;/td>
&lt;td>$\theta_{a}(1) + \theta_{b}(1) + \theta_{ab}(1, 1)$&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/div>
&lt;/div>
&lt;p>対応するグラフは以下のようになります．表記が煩雑になるので図では $\frac{1}{2}$ を除外しています．このグラフの s-t cut の例をいくつか見ていきます．&lt;/p>
&lt;img src="images/general_sample_ab.png" width="50%">
&lt;p>$S = \lbrace s, a, b \rbrace$ とします．この s-t cut の容量は $\frac{1}{2} (\theta_{a}(0) + \theta_{a}(0) + \theta_{b}(0) + \theta_{b}(0) + \theta_{ab}(0, 0) + \theta_{ab}(0, 0))$ です．&lt;br>
この値は $a = 0$，$b = 0$ としたときの $E(\bold x)$ の目的関数と一致します．&lt;/p>
&lt;img src="images/general_sample_ab_1.png" width="50%">
&lt;p>$S = \lbrace s, a \rbrace$ とします．この s-t cut の容量は $\frac{1}{2} (\theta_{a}(0) + \theta_{a}(0) + \theta_{b}(1) + \theta_{b}(1) + \theta_{ab}(0, 1) + \theta_{ab}(0, 1))$ です．&lt;br>
この値は $a = 0$，$b = 0$ としたときの $E(\bold x)$ の目的関数と一致します．&lt;/p>
&lt;img src="images/general_sample_ab_2.png" width="50%">
&lt;p>$S = \lbrace s, a, b, \bar{b} \rbrace$ とします．この場合，$a = 0$，$b = \emptyset$ とし，$b$ のラベルは未定となります．&lt;/p>
&lt;img src="images/general_sample_ab_3.png" width="50%">
&lt;h1 id="5-問題">5. 問題
&lt;/h1>&lt;p>QPBO を使って競プロの問題を解いていきます．&lt;/p>
&lt;h2 id="arc085-e---mulhttpsatcoderjpcontestsarc085tasksarc085_c">&lt;a class="link" href="https://atcoder.jp/contests/arc085/tasks/arc085_c" target="_blank" rel="noopener"
>ARC085 E - MUL&lt;/a>
&lt;/h2>&lt;blockquote>
&lt;p>宝石が $N$ 個あり，それぞれ $1,2,\cdots,N$ と数が書かれています。&lt;br>
あなたは，以下の操作を好きなだけ行うことが出来ます(一度も行わなくてもよいです)。&lt;/p>
&lt;ul>
&lt;li>正整数 $x$ を選ぶ。$x$ の倍数が書かれた宝石を全て叩き割る。&lt;/li>
&lt;/ul>
&lt;p>そして，$i$ が書かれていた宝石が割られずに残っていた場合，$a_i$ 円貰います。 ただし，この $a_i$ は負の場合もあり，その場合はお金を払わなくてはいけません。&lt;br>
うまく操作を行った時，あなたは最大で何円お金を貰えるでしょうか？&lt;/p>
&lt;/blockquote>
&lt;p>まず変数を定義します．&lt;br>
宝石 $i$ が残っているかどうかを $x_i$ で表します．宝石が割れた場合 $0$ を，残っている場合は $1$ をとります．&lt;/p>
&lt;p>次に関数を定義します．&lt;br>
QPBO は目的関数値の最小化を目指すのでコストがいくらかかるかで表します．&lt;br>
宝石 $i$ が残っている場合 $a_i$ 円貰えます．これは $-a_i$ 円のコストを払うということなので，次のように定義できます．&lt;/p>
&lt;ul>
&lt;li>$\theta_{i}(0) = 0$&lt;/li>
&lt;li>$\theta_{i}(1) = -a_i$&lt;/li>
&lt;/ul>
&lt;p>また，宝石 $i$ を壊し，$i$ で割り切れる値が書かれた宝石 $j$ を残すことは許されないので，この場合は無限のコストがかかるとします．よって，次のように定義できます．&lt;/p>
&lt;ul>
&lt;li>$\theta_{ij}(0, 0) = 0$&lt;/li>
&lt;li>$\theta_{ij}(0, 1) = 0$&lt;/li>
&lt;li>$\theta_{ij}(1, 0) = \infty$&lt;/li>
&lt;li>$\theta_{ij}(1, 1) = 0$&lt;/li>
&lt;/ul>
&lt;p>この関数は $\theta_{ij}(0, 1) + \theta_{ij}(1, 0) \ge \theta_{ij}(0, 0) + \theta_{ij}(1, 1)$ を満たしているので劣モジュラ関数です．&lt;br>
あとは，すべての $i$ と $i$ で割り切れる $j$ について上記関数を定義すれば問題を解くことができます．&lt;/p>
&lt;p>&lt;a class="link" href="https://atcoder.jp/contests/arc085/submissions/61474030" target="_blank" rel="noopener"
>提出コード&lt;/a>&lt;/p>
&lt;h2 id="abc193-f---zebranesshttpsatcoderjpcontestsabc193tasksabc193_f">&lt;a class="link" href="https://atcoder.jp/contests/abc193/tasks/abc193_f" target="_blank" rel="noopener"
>ABC193 F - Zebraness&lt;/a>
&lt;/h2>&lt;blockquote>
&lt;p>縦 $N$ マス、横 $N$ マスのマス目があります。上から $i$ 行目、左から $j$ 列目のマスをマス $(i,j)$ と表すことにします。 マス $(i,j)$ の色の情報が文字 $c_{i,j}$ により与えられます。&lt;br>
$B$ はマスが黒で塗られていることを、 $W$ はマスが白で塗られていることを、 $?$ はマスにまだ色が塗られていないことを表します。&lt;br>
高橋くんは、まだ色が塗られていないマスをそれぞれ黒または白で塗り、白黒のマス目を作ります。マス目のしまうま度を、辺で接する黒マスと白マスの組の個数と定義します。高橋くんが達成できるしまうま度の最大値を求めてください。&lt;/p>
&lt;/blockquote>
&lt;p>まず変数を定義します．&lt;br>
マスを $(i, j)$ で表すとすると関数が見にくいので $p = i \times N + j$ で表します．
マス $p$ の色を変数 $x_{p}$ で表します．白の場合 $0$ をとり，黒の場合 $1$ をとります．&lt;/p>
&lt;p>次に関数を定義します．&lt;br>
与えられている色の変更はできないので白から黒や黒から白に変更すると無限のコストがかかるとします．次のように定義できます．&lt;/p>
&lt;ul>
&lt;li>
&lt;p>マス $p$ の色が黒の場合&lt;/p>
&lt;ul>
&lt;li>$\theta_{p}(0) = \infty$&lt;/li>
&lt;li>$\theta_{p}(1) = 0$&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>マス $p$ の色が白の場合&lt;/p>
&lt;ul>
&lt;li>$\theta_{p}(0) = 0$&lt;/li>
&lt;li>$\theta_{p}(1) = \infty$&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>マス $p$ と辺で接するマス $q$ が異なる色だと -1 のコストがかかります．&lt;/p>
&lt;ul>
&lt;li>$\theta_{pq}(0, 0) = 0$&lt;/li>
&lt;li>$\theta_{pq}(0, 1) = -1$&lt;/li>
&lt;li>$\theta_{pq}(1, 0) = -1$&lt;/li>
&lt;li>$\theta_{pq}(1, 1) = 0$&lt;/li>
&lt;/ul>
&lt;p>これは劣モジュラ関数ではないのですが，変数フリップすることで劣モジュラ関数にすることができます．
QPBO 法では変数フリップを考慮しなくていいのでそのまま定義することができます．&lt;/p>
&lt;p>&lt;a class="link" href="https://atcoder.jp/contests/abc193/submissions/61474153" target="_blank" rel="noopener"
>提出コード&lt;/a>&lt;/p>
&lt;h2 id="その他の問題">その他の問題
&lt;/h2>&lt;ul>
&lt;li>&lt;a class="link" href="https://yukicoder.me/problems/no/2713" target="_blank" rel="noopener"
>No.2713 Just Solitaire&lt;/a>
&lt;ul>
&lt;li>&lt;a class="link" href="https://yukicoder.me/submissions/1034571" target="_blank" rel="noopener"
>提出コード&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a class="link" href="https://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2903" target="_blank" rel="noopener"
>AOJ - Board&lt;/a>
&lt;ul>
&lt;li>&lt;a class="link" href="https://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=10082476#1" target="_blank" rel="noopener"
>提出コード&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a class="link" href="https://onlinejudge.u-aizu.ac.jp/challenges/sources/UOA/UAPC/3058" target="_blank" rel="noopener"
>AOJ - Ghost&lt;/a>
&lt;ul>
&lt;li>&lt;a class="link" href="https://onlinejudge.u-aizu.ac.jp/solutions/problem/3058/review/10082488/MitI7/C&amp;#43;&amp;#43;23" target="_blank" rel="noopener"
>提出コード&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a class="link" href="https://atcoder.jp/contests/typical90/tasks/typical90_an" target="_blank" rel="noopener"
>競プロ典型 90 問 040 - Get More Money（★7）&lt;/a>
&lt;ul>
&lt;li>&lt;a class="link" href="https://atcoder.jp/contests/typical90/submissions/61474485" target="_blank" rel="noopener"
>提出コード&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a class="link" href="https://atcoder.jp/contests/abc259/tasks/abc259_g" target="_blank" rel="noopener"
>ABC259 G - Grid Card Game&lt;/a>
&lt;ul>
&lt;li>&lt;a class="link" href="https://atcoder.jp/contests/abc259/submissions/61474556" target="_blank" rel="noopener"
>提出コード&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="参考">参考
&lt;/h1>&lt;ul>
&lt;li>&lt;a class="link" href="https://ieeexplore.ieee.org/document/4204169" target="_blank" rel="noopener"
>Minimizing non-submodular functions with graph cuts – a review&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://www.kspub.co.jp/book/detail/1529090.html" target="_blank" rel="noopener"
>劣モジュラ最適化と機械学習&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://en.wikipedia.org/wiki/Graph_cut_optimization" target="_blank" rel="noopener"
>Graph cut optimization&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://en.wikipedia.org/wiki/Quadratic_pseudo-Boolean_optimization" target="_blank" rel="noopener"
>Quadratic pseudo-Boolean optimization&lt;/a>&lt;/li>
&lt;/ul>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>たぶんです．できない例があったら教えてください&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2">
&lt;p>この数値例は&lt;a class="link" href="https://ja.wikipedia.org/wiki/%E6%9C%80%E5%A4%A7%E3%83%95%E3%83%AD%E3%83%BC%E6%9C%80%E5%B0%8F%E3%82%AB%E3%83%83%E3%83%88%E5%AE%9A%E7%90%86#/media/%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB:Max_flow.svg" target="_blank" rel="noopener"
>最大フロー最小カット定理&lt;/a>から引用しています&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:3">
&lt;p>標準形は一意に定まるとは限りません&amp;#160;&lt;a href="#fnref:3" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:4">
&lt;p>単純な関数の場合は劣モジュラ関数を(ほぼ)標準化したものでした．厳密には $min \lbrace \theta_{p;0}, \theta_{p;1} \rbrace = 0$ を満たしていませんが．&amp;#160;&lt;a href="#fnref:4" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:5">
&lt;p>Minimizing non-submodular functions with graph cuts – a review&amp;#160;&lt;a href="#fnref:5" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:6">
&lt;p>実装では容量に $\frac{1}{2}$ をかけるのではなく，最後に目的関数値に $\frac{1}{2}$ を掛ければいいです&amp;#160;&lt;a href="#fnref:6" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>最小費用流問題の最短路繰り返し法</title><link>https://miti-7.github.io/post/%E6%9C%80%E5%B0%8F%E8%B2%BB%E7%94%A8%E6%B5%81%E5%95%8F%E9%A1%8C%E3%81%AE%E6%9C%80%E7%9F%AD%E8%B7%AF%E7%B9%B0%E3%82%8A%E8%BF%94%E3%81%97%E6%B3%95/</link><pubDate>Mon, 21 Oct 2024 00:00:00 +0900</pubDate><guid>https://miti-7.github.io/post/%E6%9C%80%E5%B0%8F%E8%B2%BB%E7%94%A8%E6%B5%81%E5%95%8F%E9%A1%8C%E3%81%AE%E6%9C%80%E7%9F%AD%E8%B7%AF%E7%B9%B0%E3%82%8A%E8%BF%94%E3%81%97%E6%B3%95/</guid><description>&lt;h2 id="最小費用流問題minimum-cost-flow-problem">最小費用流問題(Minimum Cost Flow Problem)
&lt;/h2>&lt;p>$N$ を頂点の集合，$A$ を辺の集合，$c_{ij}$ を辺 $(i, j)$ の単位流量あたりのコスト，$x_{ij}$ を辺 $(i, j)$ の流量，$b_i$ を頂点 i の需要/供給量，$l$ を辺の下限容量，$u$ を辺の上限容量としたとき，最小費用流問題（以下 MCFP）は以下のように定式化されます．&lt;br>
1 つめの制約を流量保存則と呼び，第一項は頂点 i から出る流量，第二項は頂点 i に入る流量を表します．
2 つめの制約を容量制約と呼びます．&lt;/p>
$$
\begin{aligned}
&amp;\text{minimize} &amp;&amp; \sum_{(i, j) \in A} c_{ij} x_{ij} \\
&amp;\text{subject to}
&amp;&amp; \sum_{j:(i, j) \in A} x_{ij} - \sum_{j:(j,i) \in A} x_{ji} = b_i &amp;&amp; \forall i \in N \\
&amp; &amp;&amp; l_{ij} \le x_{ij} \leq u_{ij} &amp;&amp; \forall (i, j) \in A
\end{aligned}
$$&lt;p>以下ではコスト，流量，需要/供給，下限容量，上限容量はすべて整数とします．また，$\sum_{i \in N} b_i = 0$，コストを非負，下限容量を 0 とします．&lt;/p>
&lt;h2 id="用語定義">用語・定義
&lt;/h2>&lt;ul>
&lt;li>
&lt;p>pseudoflow&lt;/p>
&lt;ul>
&lt;li>容量制約を満たす flow を pseudoflow と呼びます．流量保存則には違反していてもかまいません．&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>残余容量&lt;/p>
&lt;ul>
&lt;li>$r_{ij} = u_{ij} - x_{ij}$ を辺 (i, j) の残余容量と呼びます．&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>imbalance&lt;/p>
&lt;ul>
&lt;li>pseudoflow x に対し，頂点 i の imbalance を次のように定義します．&lt;br>
$e(i) = b(i) + \sum_{j:(j, i) \in A} x_{ji} - \sum_{j:(i,j) \in A} x_{ij}$&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>reduced cost&lt;/p>
&lt;ul>
&lt;li>各頂点のポテンシャル $\pi$ が与えられたとき，$c_{ij}^{\pi} = c_{ij} - \pi(i) + \pi(j)$ を辺 (i, j) の reduced cost と呼びます．&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="reduced-cost-最適性">Reduced Cost 最適性
&lt;/h2>&lt;p>最小費用流問題の実行可能な flow $x$ が最適であるための必要十分条件は，残余ネットワークのすべての辺 (i, j) に対して$c^{\pi}_{ij} \ge 0$ となるポテンシャル $\pi$ が存在することです．&lt;/p>
&lt;h2 id="最短路繰り返し法successive-shortest-path-algorithm">最短路繰り返し法(Successive Shortest Path Algorithm)
&lt;/h2>&lt;p>最短路繰り返し法は容量制約を満たすが流量保存則に違反する pseudoflow x から開始します．&lt;br>
アルゴリズムの各ステップでは reduced cost 最適性を維持しつつ，主問題の実行不能解 x を実行可能解に近づけます．&lt;br>
具体的には，残余ネットワーク上で$e(k) \gt 0$ である頂点 k から $e(l) \lt 0$ である頂点 l へ，最短路に沿って flow を流すことで実行可能性を高めていきます．&lt;br>
実行可能解が得られたときアルゴリズムは終了します．&lt;/p>
&lt;p>最短路繰り返し法の流れは以下のようになります&lt;/p>
&lt;ul>
&lt;li>初期解の構築
&lt;ul>
&lt;li>$x = 0$，$\pi = 0$ とする&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>実行可能解が得られるまで以下を繰り返す
&lt;ul>
&lt;li>reduced cost を距離とする残余ネットワーク上で，$e(k) \gt 0$ である頂点 k から各頂点への最短路を求める
&lt;ul>
&lt;li>$P$ を k から各頂点への最短路，$d$ を最短距離とする&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>ポテンシャルの更新
&lt;ul>
&lt;li>$\pi^{\prime} = \pi - d$&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>flow と imbalance の更新
&lt;ul>
&lt;li>$\delta = min[e(k), min(r_{ij} : (i,j) \in P)]$とし，$P$ に沿って辺の flow を $\delta$ 増加する&lt;/li>
&lt;li>$e(k) = e(k) - \delta$，$e(l) = e(l) + \delta$ と更新する&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>次節からアルゴリズムの各ステップで常に reduced cost 最適性を維持することを確認していきます．&lt;/p>
&lt;h2 id="初期解の構築">初期解の構築
&lt;/h2>&lt;p>初期解が容量制約と reduced cost 最適性を満たすことを確認します．&lt;br>
仮定より，下限容量は 0 のため $x = 0$ は容量制約を満たします．&lt;br>
$\pi = 0$ のため $c_{ij}^{\pi} = c_{ij}$ です．辺のコストはすべて非負を仮定しているため $c_{ij}^{\pi} \ge 0$ となり reduced cost 最適性を満たします．&lt;/p>
&lt;h2 id="ポテンシャルの更新">ポテンシャルの更新
&lt;/h2>&lt;p>ある $x$ に対し $\pi$ が reduced cost 最適性を満たしているとき，ポテンシャルを $\pi^{\prime} = \pi - d$ と更新しても reduced cost 最適性を満たすことを示します&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>．&lt;/p>
&lt;p>$d$ は reduced cost を距離とした残余ネットワーク上での頂点 k から各頂点への最短距離であるため，各辺 (i, j) は $d(j) \le d(i) + c_{ij}^{\pi}$ を満たします．&lt;/p>
&lt;p>上の式に $c_{ij}^{\pi} = c_{ij} - \pi(i) + \pi(j)$ を代入します．&lt;br>
$d(j) \le d(i) + c_{ij} - \pi(i) + \pi(j)$&lt;/p>
&lt;p>$d(j)$を移項し，頂点ごとにまとめます．&lt;br>
$c_{ij} - (\pi(i) - d(i)) + (\pi(j) - d(j)) \ge 0$&lt;/p>
&lt;p>ポテンシャルの更新の仕方から以下が成り立ちます．&lt;br>
$c_{ij} - \pi^{\prime}(i) + \pi^{\prime}(j) = c^{\pi_{ij}^{\prime}} \ge 0$&lt;/p>
&lt;p>よって，ポテンシャルを $\pi^{\prime} = \pi - d$ と更新しても reduced cost 最適性を満たすことがわかりました．&lt;/p>
&lt;h2 id="flow-の更新">flow の更新
&lt;/h2>&lt;p>最短路に沿って flow を更新したとき reduced cost 最適性を満たすことを確認します．&lt;/p>
&lt;p>まず，ポテンシャルを $\pi^{\prime} = \pi - d$ と更新したとき，頂点 k から各頂点への最短路の辺の reduced cost が 0 となることを確認します．&lt;br>
頂点 k から頂点 l の最短路を考えます．最短路であるため，この経路の各辺は $d(j) = d(i) + c_{ij}^{\pi}$ を満たします．&lt;/p>
&lt;p>上の式に $c_{ij}^{\pi} = c_{ij} - \pi(i) + \pi(j)$ を代入します．&lt;br>
$d(j) = d(i) + c_{ij} - \pi(i) + \pi(j)$&lt;/p>
&lt;p>$d(j)$ を移項し，頂点ごとにまとめます．&lt;br>
$c_{ij} - (\pi(i) - d(i)) + (\pi(j) - d(j)) = 0$&lt;/p>
&lt;p>ポテンシャルの更新の仕方から以下が成り立ちます．&lt;br>
$c_{ij} - \pi^{\prime}(i) + \pi^{\prime}(j) = c^{\pi_{ij}^{\prime}} = 0$&lt;/p>
&lt;p>よって，頂点 k から各頂点への最短路の辺の reduced cost は 0 となることがわかりました．&lt;/p>
&lt;p>次に，flow を更新したとき reduced cost 最適性を満たすことを確認します．&lt;br>
$\delta = min[e(s), min(r_{ij} : (i,j) \in P)]$ とし，最短路に沿って辺の flow を更新します．&lt;br>
$\delta$ 選び方から，このように flow を更新しても容量制約を満たします．また，reduced cost が 0 であるため，辺に flow を流すことで残余ネットワーク上に逆辺が生じたとしても reduced cost 最適性には違反しません．&lt;br>
よって，最短路に沿って flow を更新したとき reduced cost 最適性を満たすことがわかりました．&lt;/p>
&lt;h2 id="計算量">計算量
&lt;/h2>&lt;p>$U$ を最大の供給量，$C$ をコストの最大値とします．&lt;br>
アルゴリズムは各イテレーションで最短路問題を解き，供給量は厳密に減少します．
よって，$nU$ 回のイテレーションでアルゴリズムは終了します．最短路問題に 2 分ヒープを使った dijkstra 法を使うとすると $O((m + n) \log n)$ となります．&lt;br>
よって，全体で $O(nU (m + n) \log n)$ となります．&lt;/p>
&lt;h2 id="補足ポテンシャルの更新の改善">補足：ポテンシャルの更新の改善
&lt;/h2>&lt;p>dijkstra 法で最短距離を求めているとします．&lt;br>
上記のアルゴリズムの説明では頂点 k からすべての頂点に対する最短路を求めましたが，$e(l) \lt 0$ のような頂点を見つけたとき探索を終了したとします．最短距離が確定した頂点を permanently labeled node，まだ確定していない頂点を temporarily labeled node と呼びます．&lt;br>
このとき，ポテンシャルは以下のように更新することができます．&lt;/p>
$$
\pi^{\prime} = \left\{
\begin{array}{ll}
\pi_{i} - d_{i} &amp; \text{node i is permanently labeled}\\
\pi_{i} - d_{l} &amp; \text{node i is temporarily labeled}
\end{array}
\right.
$$&lt;details>
&lt;summary>証明&lt;/summary>
$S$ を permanently labeled node の集合，$\bar{S}$ を temporarily labeled node の集合とします．
頂点 i と頂点 j が S と T のどちらに属するかの 4 つ場合について，ポテンシャルが $\pi$ から $\pi^{\prime}$ に変更されたときを考えます．
&lt;h3 id="1-i-in-s-j-in-s-の場合">1. $i \in S, j \in S$ の場合
&lt;/h3>&lt;p>「ポテンシャルの更新」の節と同じです．&lt;/p>
&lt;h3 id="2-i-in-s-j-in-bars-の場合">2. $i \in S, j \in \bar{S}$ の場合
&lt;/h3>&lt;p>$c^{\pi^{\prime}} = c_{ij}^{\pi} + d(i) - d(l)$ と更新されます．&lt;br>
頂点 j は最短距離と確定していないため，$d(l) \le d(j)$ です．&lt;br>
また，頂点 i は最短距離と確定しているため，dijkstra 法のアルゴリズムから $d(j) \le d(i) + c_{ij}^{\pi}$ が成り立ちます．&lt;br>
よって，$d(l) \le d(i) + c_{ij}^{\pi}$ であるため $c_{ij}^{\pi^{\prime}} \ge 0$ を満たします．&lt;/p>
&lt;h3 id="3-i-in-bars-j-in-s-の場合">3. $i \in \bar{S}, j \in S$ の場合
&lt;/h3>&lt;p>$c^{\pi^{\prime}} = c_{ij}^{\pi} + d(l) - d(j)$ と更新されます．&lt;br>
頂点 j は最短距離と確定しているため，$d(j) \le d(l)$ です．&lt;br>
よって，$c_{ij}^{\pi^{\prime}} \ge 0$ を満たします．&lt;/p>
&lt;h3 id="4-i-in-bars-j-in-bars-の場合">4. $i \in \bar{S}, j \in \bar{S}$ の場合
&lt;/h3>&lt;p>$c^{\pi^{\prime}} = c_{ij}^{\pi} + d(l) - d(l)$ と更新されます．&lt;br>
よって，$c_{ij}^{\pi} \ge 0$ を満たします．&lt;/p>
&lt;/details>
&lt;p>また，すべてのポテンシャルに定数を加算しても reduced cost 最適性に影響はないため，全体に $d(l)$ を加算することで以下のように更新することもできます．&lt;/p>
$$
\pi^{\prime} = \left\{
\begin{array}{ll}
\pi_{i} - d_{i} + d_{l} &amp; \text{node i is permanently labeled}\\
\pi_{i} &amp; \text{node i is temporarily labeled}
\end{array}
\right.
$$&lt;h2 id="参考">参考
&lt;/h2>&lt;ul>
&lt;li>&lt;a class="link" href="https://www.amazon.co.jp/dp/1292042702" target="_blank" rel="noopener"
>Network Flows: Pearson New International Edition&lt;/a>&lt;/li>
&lt;/ul>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>すべての頂点の距離が定まることを仮定しています．&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>最短路問題の最適性条件と reduced arc length</title><link>https://miti-7.github.io/post/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%95%8F%E9%A1%8C%E3%81%AE%E6%9C%80%E9%81%A9%E6%80%A7%E6%9D%A1%E4%BB%B6%E3%81%A8-reduced-arc-length/</link><pubDate>Tue, 17 Sep 2024 00:00:00 +0900</pubDate><guid>https://miti-7.github.io/post/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%95%8F%E9%A1%8C%E3%81%AE%E6%9C%80%E9%81%A9%E6%80%A7%E6%9D%A1%E4%BB%B6%E3%81%A8-reduced-arc-length/</guid><description>&lt;h2 id="最短路問題">最短路問題
&lt;/h2>&lt;p>有向グラフが与えられたとき，始点 s から各頂点への最短路を求める問題を単一始点最短路問題といいます．以下では，頂点数を $n$，辺数を $m$，各辺 (u, v) のコストを $c_{uv}$ で表します．また，グラフは強連結を仮定します．&lt;/p>
&lt;h2 id="最短路問題の最適性条件">最短路問題の最適性条件
&lt;/h2>&lt;p>頂点集合を $N$，辺集合を $A$，辺 (u, v) のコストを $c_{uv}$ とします．始点 s から各頂点 v への有向パスの距離の上界を $d(v)$ で表し，これを距離ラベルと呼びます．特に，$d(s) = 0$ です．各頂点 $v \in N$ について，$d(v)$ が始点 s から頂点 v の最短路の長さであるための必要十分条件は以下が成り立つことです．&lt;/p>
$$
\begin{equation}
d(v) \le d(u) + c_{uv} \quad \forall (u, v) \in A
\end{equation}
$$&lt;p>不等式 (1) は，各辺 $(u, v) \in A$ について，頂点 v への距離は頂点 u への距離 + $c_{uv}$ 以下であることを表しています．&lt;/p>
&lt;details>&lt;summary>証明&lt;/summary>
&lt;p>まず，必要条件であることを示します．&lt;br>
対偶をとり，$d(v) \gt d(u) + c_{uv}$ ならば，距離ラベルが最短路の長さではないことを示します．&lt;br>
$d(v) \gt d(u) + c_{uv}$ であるような辺があれば，頂点 u を経由することで頂点 v への距離を改善することができます．&lt;br>
したがって，距離ラベル $d$ は最短路の長さではありません．&lt;/p>
&lt;p>次に，十分条件であることを示します．&lt;br>
頂点 s から頂点 v への任意の有向パスが $s = i_1 \rightarrow i_2 \rightarrow &amp;hellip; \rightarrow i_{k-1} \rightarrow i_k = v$ であったとします．&lt;br>
不等式 (1) から以下の式がそれぞれ成り立ちます．&lt;/p>
$$
\begin{aligned}
d(v) =\; &amp; d(i_k) &amp;&amp; \le\; d(i_{k - 1}) &amp;&amp; +\; c_{i_{k - 1}i_{k}}, \\
&amp; d(i_{k - 1}) &amp;&amp; \le\; d(i_{k - 2}) &amp;&amp; +\; c_{i_{k - 2} i_{k - 1}}, \\
&amp; \vdots \\
&amp; d(i_{2}) &amp;&amp; \le\; d(i_{1}) &amp;&amp; +\; c_{i_{1}i_{2}} = c_{i_{1}i_{2}}.
\end{aligned}
$$&lt;p>式をそれぞれ代入すると&lt;/p>
$$
d(v) = d(i_{k}) \le c_{i_{k-1}i_{k}} + c_{i_{k-2}i_{k-1}} + \dots + c_{i_{1}i_{2}} = \sum_{(u, v) \in P} c_{uv}
$$&lt;p>となり，$d(v)$ は，始点 s から頂点 v への任意の有向パスのコストの合計の下界になります．
$d(v)$ は始点 s から頂点 v への任意の有向パスの下界かつ上界なので，距離ラベル $d(v)$ は最短路の長さです．&lt;/p>
&lt;p>以上のことから，「各頂点 $v \in N$ について距離ラベル $d(v)$ が最短路の長さである」の必要十分条件は，「各辺 $(u, v) \in A$ について $d(v) \le d(u) + c_{uv}$ を満たす」であることがわかりました．&lt;/p>
&lt;/details>
&lt;h2 id="reduced-arc-length-の性質">reduced arc length の性質
&lt;/h2>&lt;p>ある距離ラベル $d$ に対し，$c_{uv}^{d} = c_{uv} + d(u) - d(v)$ を reduced arc length と呼びます．reduced arc length には次の性質があります．&lt;/p>
&lt;ol>
&lt;li>任意の閉路 $W$ について，$\sum_{(u, v) \in W} c_{uv}^{d} = \sum_{(u, v) \in W} c_{uv}$&lt;/li>
&lt;li>頂点 k から頂点 l への任意の有向パス $P$ について，$\sum_{(u, v) \in P} c_{uv}^{d} = \sum_{(u, v) \in P} c_{uv} + d(k) - d(l)$&lt;/li>
&lt;li>距離ラベル $d$ が最適ならば，すべての辺 (u, v) について $c_{uv}^{d} \ge 0$ が成り立つ&lt;/li>
&lt;/ol>
&lt;details>&lt;summary>性質 1 の証明&lt;/summary>
$$
\begin{aligned}
\sum_{(u, v) \in W} c_{uv}^{d} &amp;= \sum_{(u, v) \in W} (c_{uv} + d(u) - d(v)) \\
&amp;= \sum_{(u, v) \in W} c_{uv} + \sum_{(u, v) \in W} (d(u) - d(v)) \\
&amp;= \sum_{(u, v) \in W} c_{uv} \\
\end{aligned}
$$&lt;p>任意の有向閉路 $W$ において，頂点 u は $+d(u)$としてちょうど 1 回，$-d(u)$ としてちょうど 1 回出現するため，$\sum_{(u, v) \in W} (d(u) - d(v)) = 0$ が成り立ちます．&lt;/p>
&lt;/details>
&lt;details>&lt;summary>性質 2 の証明&lt;/summary>
$$
\begin{aligned}
\sum_{(u, v) \in P} c_{uv}^{d} &amp;= \sum_{(u, v) \in P} (c_{uv} + d(u) - d(v)) \\
&amp;= \sum_{(u, v) \in P} c_{uv} + \sum_{(u, v) \in P} (d(u) - d(v)) \\
&amp;= \sum_{(u, v) \in P} c_{uv} + d(k) - d(l) \\
\end{aligned}
$$&lt;p>頂点 k と頂点 l 以外の頂点は，$+d(u)$ としてちょうど 1 回，$-d(u)$ としてちょうど 1 回出現するため互いに打ち消し合います．&lt;br>
頂点 k は $+d(k)$ として，頂点 $l$ は $-d(l)$ としてちょうど 1 回出現します．&lt;/p>
&lt;/details>
&lt;details>&lt;summary>性質 3 の証明&lt;/summary>
最適性条件から直ちに言えます
&lt;/details>
&lt;p>次節からは，reduced arc length の性質を使ったアルゴリズムと問題を見ていきます．&lt;/p>
&lt;h2 id="johnsons-algorithm">Johnson&amp;rsquo;s algorithm
&lt;/h2>&lt;p>任意の 2 頂点の組 (u, v) に対して頂点 u から頂点 v の最短路を求める問題を全点対最短路問題と呼びます．&lt;br>
Johnson&amp;rsquo;s algorithm は全点対最短路問題を解くアルゴリズムです．&lt;/p>
&lt;p>頂点数が $n$ のとき，単一始点最短路問題を n 回解くことによって全点対最短路を求めることができます．&lt;br>
ただし，グラフにコストが負の辺があると，単一始点最路問題を解くのに Dijkstra 法を使うことができません．そこで，グラフのコストを reduced arc length に変換したグラフ上で最短路を求めることにします．reduced arc length の性質 3 から，最適距離ラベル $d$ に対する reduced arc length のコストはすべて 0 以上であるため Dijkstra 法を使うことができます．&lt;br>
変換したグラフ上で最短距離を求めたあと，性質 2 を使って元のグラフの距離に変換します．&lt;br>
最適距離ラベルは Bellman–Ford 法を使い求めることができます．負閉路が見つかった場合はアルゴリズムを終了します．&lt;/p>
&lt;p>Dijkstra 法に二分ヒープを使うとき，Bellman–Ford 法に $O(nm)$，Dijkstra 法に $O((n + m) \log n)$ かかるため，計算量は全体として $O(nm + n ((n + m) \log n))$ となります．&lt;/p>
&lt;p>例として，&lt;a class="link" href="https://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_1_C&amp;amp;lang=ja" target="_blank" rel="noopener"
>AOJ - All Pairs Shortest Path&lt;/a> を解きます．&lt;br>
与えられるグラフは強連結ではないため，人工頂点 s を追加し，s から他のすべての頂点に重さ 0 の辺を張ります．この s を始点として Bellman-Ford 法を使うことで最適距離ラベルを求めることができます．&lt;br>
実装では人工頂点を追加するのではなく， Bellman-Ford の初期解をすべて 0 とすることで対応しています．&lt;br>
&lt;a class="link" href="https://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=9647270#1" target="_blank" rel="noopener"
>提出コード&lt;/a>&lt;/p>
&lt;h2 id="abc237-e---skiinghttpsatcoderjpcontestsabc237tasksabc237_e">&lt;a class="link" href="https://atcoder.jp/contests/abc237/tasks/abc237_e" target="_blank" rel="noopener"
>ABC237 E - Skiing&lt;/a>
&lt;/h2>&lt;p>問題概要&lt;br>
$N$ 頂点，$M$ 辺の強連結の有向グラフと各頂点 u の高さ $H(u)$ が与えられる．$H(u) \ge H(v)$ としたとき，頂点 u から頂点 v にはコスト $H(v) - H(u)$ の辺が，頂点 v から頂点 u にはコスト $2(H(u) - H(v))$ の辺が張られている．頂点 1 から各頂点への最短距離の中で最も小さいものを求めよ．&lt;/p>
&lt;p>負辺のあるグラフの最短路問題なので Bellman–Ford 法を使えば答えが求まりますが，Bellman–Ford 法の計算量は $O(nm)$ なので TLE になってしまいます．
そこで，グラフのコストを reduced arc length に変換したグラフ上で最短路を求めることにします．&lt;/p>
&lt;p>まず，不等式 (1) を満たすような距離ラベルを考えます．&lt;br>
ある距離ラベル $d$ に対して，$H(u) \ge H(v)$ のとき，$c_{uv}^{d}$ と $c_{vu}^{d}$ は以下のように表せます．&lt;/p>
$$
\begin{aligned}
c_{uv}^{d} &amp;= c_{uv} + d(u) - d(v) = H(v) - H(u) + d(u) - d(v) \\
c_{vu}^{d} &amp;= c_{vu} + d(v) - d(u) = 2(H(u)- H(v)) + d(v) - d(u) \\
\end{aligned}
$$&lt;p>u と v についてまとめて式を整理します．&lt;/p>
$$
\begin{aligned}
c_{uv}^{d} &amp;= (H(v) - d(v)) - (H(u) - d(u)) \\
c_{vu}^{d} &amp;= (2H(u) - d(u)) - (2H(v) - d(v)) \\
\end{aligned}
$$&lt;p>$c_{uv}^{d} \ge 0$ かつ $c_{vu}^{d} \ge 0$ にしたいので，各頂点 u について $d(u) = H(u)$ とすると以下のようになります．&lt;/p>
$$
\begin{aligned}
c_{uv}^{d} &amp;= (H(v) - H(v)) - (H(u) - H(u)) = 0 \\
c_{vu}^{d} &amp;= (2H(u) - H(u)) - (2H(v) - H(v)) = H(u) - H(v)\\
\end{aligned}
$$&lt;p>以上のことから，次のように問題を言い換えることができます．&lt;br>
$N$ 頂点，$M$ 辺の強連結の有向グラフと各頂点 u の高さ $H(u)$ が与えられる．$H(u) \ge H(v)$ のとき，頂点 u から頂点 v にはコスト 0 の辺が，頂点 v から頂点 u にはコスト $H(u) - H(v)$ の辺が張られている．頂点 1 から各頂点への最短距離の中で最も小さいものを求めよ．&lt;/p>
&lt;p>すべての辺のコストは 0 以上なので Dijkstra 法で求めることができます．&lt;br>
求まる値は変換したグラフ上での値なので，$distance[u] - H[0] + H[u]$ として元のグラフ上での値に戻します．&lt;/p>
&lt;p>&lt;a class="link" href="https://atcoder.jp/contests/abc237/submissions/57838602" target="_blank" rel="noopener"
>提出コード&lt;/a>&lt;/p>
&lt;h2 id="参考">参考
&lt;/h2>&lt;ul>
&lt;li>&lt;a class="link" href="https://www.amazon.co.jp/dp/1292042702" target="_blank" rel="noopener"
>Network Flows: Pearson New International Edition&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://en.wikipedia.org/wiki/Johnson%27s_algorithm" target="_blank" rel="noopener"
>Johnson&amp;rsquo;s algorithm&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://atcoder.jp/contests/abc237/editorial/3339" target="_blank" rel="noopener"
>E - Skiing 解説&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>最小費用流問題の Primal Network Simplex 法</title><link>https://miti-7.github.io/post/%E6%9C%80%E5%B0%8F%E8%B2%BB%E7%94%A8%E6%B5%81%E5%95%8F%E9%A1%8C%E3%81%AE-primal-network-simplex-%E6%B3%95/</link><pubDate>Wed, 11 Sep 2024 00:00:00 +0900</pubDate><guid>https://miti-7.github.io/post/%E6%9C%80%E5%B0%8F%E8%B2%BB%E7%94%A8%E6%B5%81%E5%95%8F%E9%A1%8C%E3%81%AE-primal-network-simplex-%E6%B3%95/</guid><description>&lt;img src="https://miti-7.github.io/post/%E6%9C%80%E5%B0%8F%E8%B2%BB%E7%94%A8%E6%B5%81%E5%95%8F%E9%A1%8C%E3%81%AE-primal-network-simplex-%E6%B3%95/images/%E3%83%9D%E3%83%86%E3%83%B3%E3%82%B7%E3%83%A3%E3%83%AB%E3%81%AE%E6%9B%B4%E6%96%B0.png" alt="Featured image of post 最小費用流問題の Primal Network Simplex 法" />&lt;h2 id="最小費用流問題minimum-cost-flow-problem">最小費用流問題(Minimum Cost Flow Problem)
&lt;/h2>&lt;p>$N$ を頂点の集合，$A$ を辺の集合，$c_{ij}$ を辺 $(i, j)$ の単位流量あたりのコスト，$x_{ij}$ を辺 $(i, j)$ の流量，$b_i$ を頂点 i の需要/供給量，$l$ を辺の下限容量，$u$ を辺の上限容量としたとき，最小費用流問題（以下 MCFP）は以下のように定式化されます．&lt;br>
1 つめの制約を流量保存則と呼び，第一項は頂点 i から出る流量，第二項は頂点 i に入る流量を表します．
2 つめの制約を容量制約と呼びます．&lt;/p>
$$
\begin{aligned}
&amp;\text{minimize} &amp;&amp; \sum_{(i, j) \in A} c_{ij} x_{ij} \\
&amp;\text{subject to}
&amp;&amp; \sum_{j:(i, j) \in A} x_{ij} - \sum_{j:(j,i) \in A} x_{ji} = b_i &amp;&amp; \forall i \in N \\
&amp; &amp;&amp; l_{ij} \le x_{ij} \leq u_{ij} &amp;&amp; \forall (i, j) \in A
\end{aligned}
$$&lt;p>以下ではコスト，流量，需要/供給，下限容量，上限容量はすべて整数とします．また，$\sum_{i \in N} b_i = 0$ を仮定します．&lt;/p>
&lt;h2 id="primal-network-simplex-法">Primal Network Simplex 法
&lt;/h2>&lt;p>primal network simplex 法は，ネットワーク構造を利用することで simplex 法を効率化させたアルゴリズムです．今回は primal network simplex 法で MCFP を解いていきます．&lt;br>
MCFP が必ず 最適 spanning tree solution という解を持つことを利用し，spanning tree solution のみを探索することで効率的に最適解を見つけることができます&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>．&lt;/p>
&lt;p>primal network simplex 法は，simplex 法の観点と負閉路除去法の観点から説明することができますが，今回は負閉路除去法の観点で説明します．
節 1 で spanning tree solution の定義をします．節 2 で spanning tree solution は spanning tree structure として表せることと，spanning tree structure が最適解となる条件について示します．節 3 で primal network simplex 法の流れについて説明し，節 4 から 節 8 でアルゴリズムの各段階の詳細について述べます．節 9 から節 11 で退化について説明します．&lt;/p>
&lt;h2 id="1-spanning-tree-solution">1. spanning tree solution
&lt;/h2>&lt;p>ある実行可能解 $x$ に対して， $l_{ij} &amp;lt; x_{ij} &amp;lt; u_{ij}$ を満たす辺を free arc，$x_{ij} = l_{ij}$ か $x_{ij} = u_{ij}$ を満たす辺を restricted arc と呼びます．
解 $x$ とそれに関連する全域木が以下の条件を満たすとき，spanning tree solution と呼びます．特に，$x$ が 最適解であるとき最適 spanning tree solution と呼びます．&lt;/p>
&lt;ul>
&lt;li>$x$ が実行可能解である&lt;/li>
&lt;li>全域木に含まれない辺（non-tree arc）がすべて restricted arc である&lt;/li>
&lt;/ul>
&lt;p>具体例を示します．簡単のため，辺容量の下限はすべて 0 としコストは省略します．$b(0) = 2$，$b(3) = -2$ とします．&lt;br>
下の図のグラフでは辺 (0, 1)，(2, 3) が free arc，辺 (0, 2)，(1, 2)，(1, 3) が restricted arc です．&lt;br>
解 $x$ は流量保存則と容量制約を満たすため実行可能解です．全域木として，青色の辺 (0, 1)，(0, 2)，(2, 3) を選ぶ&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>と，non-tree arc は (1, 2) と (1, 3) となり，すべて restricted arc であるため spanning tree solution となります．&lt;/p>
&lt;img src="images/spanning_tree_solutionの例1.png" width="50%">
&lt;p>また，全域木として，青色の辺 (0, 1)，(1, 2)，(2, 3) を選んでも spanning tree solution となります．
このように，1 つの実行可能解に複数の spanning tree solution が対応することがあります．&lt;/p>
&lt;img src="images/spanning_tree_solutionの例2.png" width="50%">
&lt;h2 id="2-spanning-tree-structure-と最適性条件">2. spanning tree structure と最適性条件
&lt;/h2>&lt;p>spanning tree solution は辺集合を次の 3 つに分割します．&lt;/p>
&lt;ul>
&lt;li>T: 全域木の辺&lt;/li>
&lt;li>L: non-tree arc のうち，flow が下限の辺&lt;/li>
&lt;li>U: non-tree arc のうち，flow が上限の辺&lt;/li>
&lt;/ul>
&lt;p>この 3 つ組 (T, L, U) を spanning tree structure と呼びます．spanning tree structure は spanning tree solution から一意に構築されます．&lt;/p>
&lt;p>頂点 i のポテンシャルを $\pi(i)$，辺 (i, j) の reduced cost を $c_{ij}^{\pi} = c_{ij} - \pi(i) + \pi(j)$ で表します．spanning tree structure が次の条件を満たすとき，spanning tree structure に対応する spanning tree solution は最適 spanning solution となります．このような，spanning tree structure を最適 spanning tree structure と呼びます．&lt;/p>
$$
\begin{aligned}
c^{\pi}_{ij} = 0 &amp;&amp; \forall (i, j) \in T \\
c^{\pi}_{ij} \ge 0 &amp;&amp; \forall (i, j) \in L \\
c^{\pi}_{ij} \le 0 &amp;&amp; \forall (i, j) \in U \\
\end{aligned}
$$&lt;p>全域木の根のポテンシャルを 0 と固定すると $T$ に属する辺 (i, j) が $c^{\pi}_{ij} = 0$ を満たすように各頂点のポテンシャル $\pi$ を定めることができます．このとき，$-\pi(i)$ は根から頂点 i への木のパスの長さとみなすことができます．
具体例として，下の図の全域木について各頂点のポテンシャルを求めていきます．頂点 0 を根とします．&lt;/p>
&lt;p>頂点 1 のポテンシャルを求めます．
辺 (i, j) の reduced cost は $c_{ij}^{\pi} = c_{ij} - \pi(i) + \pi(j)$ です．全域木の辺の reduced cost は 0，辺 (0, 1) のコストは 1，頂点 0 のポテンシャルは 0 であることから，$0 = 1 - 0 + \pi(1)$ となり，$\pi(1) = -1$と求められます．&lt;/p>
&lt;p>頂点 2 のポテンシャルを求めます．
辺 (2, 1) のコストは 5 ，頂点 1 のポテンシャルは -1 なので，$0 = 5 - \pi(2) + (-1)$ となり，$\pi(2) = 4$ と求められます．&lt;/p>
&lt;p>同様の計算を行うことで，全頂点のポテンシャルを計算することができます．&lt;/p>
&lt;img src="images/ポテンシャルの計算.png" width="50%">
&lt;p>全頂点のポテンシャルを求めると，$L$ と $U$ に属する辺の reduced cost を計算することができます．すべての辺が最適性条件を満たすならば，最適 spanning tree structure と判定できます．&lt;/p>
&lt;h2 id="3-network-simplex-法のアルゴリズムの流れ">3. Network Simplex 法のアルゴリズムの流れ
&lt;/h2>&lt;p>spanning tree structure が与えられたとき，全域木の reduced cost が 0 となるように各頂点のポテンシャルを計算し，各辺の reduced cost を求めることで最適 spanning structure かどうか判定することができました．
最適 spanning tree structure でない場合， $L$ に属する $c_{ij}^{\pi} \lt 0$ である辺か，$U$ に属する $c_{ij}^{\pi} \gt 0$ である辺が 1 つ以上存在することになります．
これらの辺を $T$ に追加したときを考えます．&lt;/p>
&lt;h3 id="l-に属する-cpi_ij-lt-0-である辺を-t-に追加">$L$ に属する $c^{\pi}_{ij} \lt 0$ である辺を $T$ に追加
&lt;/h3>&lt;p>$L$ に属する $c_{ij}^{\pi} \lt 0$ である辺 (i, j) を $T$ に追加したとします．&lt;br>
このとき，根から i，i から j，j から根をたどるパスの flow を 1 増加すると，目的関数値は $c^{\pi}_{ij}$ 増加します．&lt;/p>
&lt;p>具体例を見てみます．下の図の全域木にコスト -8 の辺 (2, 4) を追加したとします．この辺の reduced cost は $-8 - 4 + (-3) = -15$ です．&lt;br>
辺 (0, 1)，(2, 1)，(2, 4)，(3, 4)，(3, 0) の順に flow を 1 単位流すと，全体のコストの合計は，1 + (-5) + (-8) + (-5) + 2 = -15 となり，目的関数値が 15 減少する（-15 増加する）ことがわかります&lt;sup id="fnref:3">&lt;a href="#fn:3" class="footnote-ref" role="doc-noteref">3&lt;/a>&lt;/sup>．&lt;/p>
&lt;img src="images/全域木にLの辺を追加.png" width="50%">
&lt;h3 id="u-に属する-cpi_ij-gt-0-である辺を-t-に追加">$U$ に属する $c^{\pi}_{ij} \gt 0$ である辺を $T$ に追加
&lt;/h3>&lt;p>$U$ に属する $c_{ij}^{\pi} \gt 0$ である辺 (i, j) を $T$ に追加したとします．&lt;br>
このとき，根から j， j から i，i から根をたどるパスの flow を 1 増加すると，目的関数値は $c^{\pi}_{ij}$ 減少します．&lt;/p>
&lt;p>下の図の全域木にコスト -5 の辺 (6, 4) を追加したとします．この辺の reduced cost は $(-5) - (-11) + (-3) = 3$ です．&lt;br>
辺 (3, 0)，(3, 4)，(6, 4)，(5, 6)，(3, 5)，(3, 0) の順に flow を 1 単位流すと，全体のコストの合計は，-2 + 5 + (-(-5)) + (-7) + (-6) + 2 = -3 となり，目的関数値が 3 減少することがわかります．&lt;br>
また，辺 (0, 3) に対し，頂点 0 から 頂点 3 に flow を流し，頂点 3 から頂点 0 に flow を流すと flow は打ち消し合うため，追加した辺によって生じる閉路のみを考慮すればいいこともわかります．&lt;/p>
&lt;img src="images/全域木にUの辺を追加.png" width="50%">
&lt;p>以上のことから，spanning tree structure が最適でないとき，最適性条件に違反する辺を全域木に追加したことによって生じる閉路の flow を更新することで目的関数値を減少できることがわかりました．&lt;br>
閉路の flow を限界まで増加させると，1 本以上の辺の flow が下限容量か上限容量に達するため，その辺を取り除くことによって新しい spanning tree solution を生成することができます．&lt;br>
primal network simplex 法は これらの処理を最適性条件を満たすまで繰り返すことで最適解を求めます．&lt;/p>
&lt;p>primal network simplex 法の流れは以下のようになります&lt;/p>
&lt;ul>
&lt;li>初期 spanning tree structure を構築する&lt;/li>
&lt;li>spanning tree structure が最適性条件を満たさない間，以下を繰り返す
&lt;ul>
&lt;li>最適性条件に違反する辺を $U$ か $L$ から選び，全域木に追加する&lt;/li>
&lt;li>閉路の flow を更新する&lt;/li>
&lt;li>flow が下限容量か上限容量に達した辺を閉路から 1 つ取り除き新しく全域木を作成する&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>次節からアルゴリズムの各段階の詳細について説明していきます．&lt;/p>
&lt;h2 id="4-初期-spanning-tree-structre-の構築">4. 初期 spanning tree structre の構築
&lt;/h2>&lt;p>初期 spanning tree structre (T, L, U) を構築します．&lt;br>
まず，人工頂点 $s$ を作り，$s$ と既存の各頂点 $u$ の間に以下のように辺をはります．&lt;/p>
&lt;ul>
&lt;li>$b(u) \ge 0$ の場合，流量 $b(u)$ の辺 $(u, s)$ を加える&lt;/li>
&lt;li>$b(u) \lt 0$ の場合，流量 $-b(u)$ の辺 $(s, u)$ を加える&lt;/li>
&lt;/ul>
&lt;p>いずれの人工辺も容量とコストは十分大きい値とします．人工辺は $T$ に，もとからある辺は $L$ に，$U$ は空とします.&lt;br>
このように作られた spanning tree structure は実行可能解です．今後はこの拡張された network 上で問題を解いていきます．人工辺のコストは十分大きいため最適解が得られたとき人工辺に flow は流れていません．&lt;/p>
&lt;p>例として下のグラフの初期 spanning tree structure を構築します．&lt;br>
$b(0) = 2$，$b(3) = -2$，他の頂点の需要/供給は 0 とします．また，すべての辺の下限容量は 0 とします&lt;sup id="fnref:4">&lt;a href="#fn:4" class="footnote-ref" role="doc-noteref">4&lt;/a>&lt;/sup>．&lt;/p>
&lt;img src="images/初期解の問題例.png" width="50%">
&lt;p>まず，人工頂点として，$s$ を追加します．&lt;br>
$b(u) \ge 0$ である頂点 0, 1, 2 から s に向けて辺を追加します．$b(0) = 2$ であるため，辺 (0, s)の flow は 2 とします．&lt;br>
s から $b(u) \lt 0$ である頂点 3 に向けて辺を追加します．$b(3) = -2$ であるため，辺 (s, 3)の flow は 2 とします．&lt;/p>
&lt;img src="images/初期解の構築.png" width="50%">
&lt;p>初期 spanning tree structure は以下のようになります．&lt;/p>
&lt;ul>
&lt;li>$T$ に属する辺：(0, s)，(1, s)，(2, s)，(s, 3)&lt;/li>
&lt;li>$L$ に属する辺：(0, 1)，(0, 2)，(1, 2)，(1, 3)，(2, 3)&lt;/li>
&lt;li>$U$ に属する辺：なし&lt;/li>
&lt;/ul>
&lt;h2 id="5-entring-arc-の選択">5. entring arc の選択
&lt;/h2>&lt;p>$T$ に追加する辺（entring arc）を $U$ か $L$ から選びます．&lt;br>
このとき，以下のような最適性条件を満たさない辺（eligible arc）を選びます．また，$|c^{\pi}_{ij}|$ を violation と呼びます．&lt;/p>
$$
\begin{aligned}
c^{\pi}_{ij} \lt 0 &amp;&amp; \forall (i, j) \in L \\
c^{\pi}_{ij} \gt 0 &amp;&amp; \forall (i, j) \in U
\end{aligned}
$$&lt;p>代表的な辺の選択方法は以下の 3 つです．&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Best eligible arc pivot rule(Dantzig&amp;rsquo;s pivot rule)&lt;/p>
&lt;ul>
&lt;li>violation の最も大きい eligible arc を entring arc とする&lt;/li>
&lt;li>1 flow 単位の改善が最も大きいため，イテレーションの回数は少なくなる&lt;/li>
&lt;li>すべての non-tree arc を調べる必要があるため，1 回のイテレーションのコストが大きい&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>First eligible arc pivot rule&lt;/p>
&lt;ul>
&lt;li>最初に見つけた eligible arc を entring arc とする．次のイテレーションでは，前回選択した辺の次から探索を開始する．最後の辺まで探索をしたら先頭に戻る&lt;/li>
&lt;li>1 回のイテレーションのコストが小さい&lt;/li>
&lt;li>1 flow 単位の改善が小さくなるので，イテレーションの回数が多くなる&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Block search pivot rule&lt;/p>
&lt;ul>
&lt;li>辺をブロックに分割し，ブロックの中で violation の最も大きい eligible arc を entring arc とする．ブロック内で見つからなかった場合，次のブロックを探索する&lt;/li>
&lt;li>すべての辺を同じブロックにしたとき，Best eligible arc pivot rule と同じ挙動になる&lt;/li>
&lt;li>すべての辺を違うブロックにしたとき，First eligible arc pivot rule と同じ挙動になる&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="6-flow-の更新">6. flow の更新
&lt;/h2>&lt;p>全域木に辺を追加すると閉路 $W$ がちょうど 1 つできます．この閉路の flow を 1 単位増加するごとに，MCFP の目的関数値は $|c^{\pi}_{ij}|$ 減少するため，$W$ の flow を容量制約を満たす限界まで増加します．&lt;br>
閉路 $W$ の向きを次のように定めます．&lt;/p>
&lt;ul>
&lt;li>$(k, l) \in L$ のとき，辺 (k, l) と同じ方向&lt;/li>
&lt;li>$(k, l) \in U$ のとき，辺 (k, l) と逆方向&lt;/li>
&lt;/ul>
&lt;p>閉路 $W$ の順辺の集合を $\bar W$，逆辺の集合を $\underbar W$ で表したとき，$W$ の各辺の flow の増加できる量は以下のようになります．&lt;/p>
$$
\delta_{ij} = \left\{
\begin{array}{ll}
u_{ij} - x_{ij} &amp; (i, j) \in \bar{W}\\
x_{ij} - l_{ij} &amp; (i, j) \in \underbar{W}
\end{array}
\right.
$$&lt;p>$\delta = min \lbrace \delta_{ij} : (i, j) \in W \rbrace$ とし，$W$ の各辺の flow を以下のように更新します．&lt;/p>
$$
x_{ij} = \left\{
\begin{array}{ll}
x_{ij} + \delta &amp; (i, j) \in \bar{W}\\
x_{ij} - \delta &amp; (i, j) \in \underbar{W}
\end{array}
\right.
$$&lt;p>具体例を見ます．すべての辺の下限は 0 とします．&lt;br>
$U$ に属する辺 (6, 4) を $T$ に追加すると，辺 (6, 4)，(5, 6)，(3, 5)，(3, 4) からなる閉路ができます．&lt;br>
辺 (6, 4) は $U$ に属するので，(6, 4) と逆方向である反時計回りを $W$ の向きとします．$\bar W$ に属する辺は，(3, 4)，$\underbar W$ に属する辺は，(6, 4)，(5, 6)，(3, 5) です．&lt;br>
各辺の $\delta_{ij}$ と $\delta$ は以下の通りです．&lt;/p>
&lt;ul>
&lt;li>$\delta_{64} = 6 - 0 = 6$&lt;/li>
&lt;li>$\delta_{56} = 2 - 0 = 2$&lt;/li>
&lt;li>$\delta_{35} = 4 - 0 = 4$&lt;/li>
&lt;li>$\delta_{34} = 3 - 1 = 2$&lt;/li>
&lt;li>$\delta = min \lbrace 6, 2, 4, 2 \rbrace = 2$&lt;/li>
&lt;/ul>
&lt;img src="images/閉路のflowの更新.png" width="50%">
&lt;p>閉路 $W$ の flow を 2 増加すると以下のようになります．&lt;/p>
&lt;img src="images/閉路のflowの更新結果.png" width="50%">
&lt;p>別の例をみます．
辺 (3, 4) の flow が 3 のとき，各辺の $\delta_{ij}$は以下のようになります．&lt;/p>
&lt;ul>
&lt;li>$\delta_{64} = 6 - 0 = 6$&lt;/li>
&lt;li>$\delta_{56} = 2 - 0 = 2$&lt;/li>
&lt;li>$\delta_{35} = 4 - 0 = 4$&lt;/li>
&lt;li>$\delta_{34} = 3 - 3 = 0$&lt;/li>
&lt;li>$\delta = min \lbrace 6, 2, 4, 0 \rbrace = 0$&lt;/li>
&lt;/ul>
&lt;p>このように全域木に $x_{ij} = l_{ij}$ や $x_{ij} = u_{ij}$ の辺があると flow が更新できないことがあります．&lt;/p>
&lt;img src="images/閉路のflowを更新できない例.png" width="50%">
&lt;h2 id="7-leaving-arc-の選択">7. leaving arc の選択
&lt;/h2>&lt;p>閉路の flow を限界まで増加したとき 1 本以上の辺が $\delta = \delta_{ij}$ となります．この辺を blocking arc と呼びます．&lt;br>
blocking arc を取り除く辺（leaving arc）として選びます（複数ある場合は任意の辺を選びます）．&lt;br>
辺 (i, j) が $x_{ij}$ = $l_{ij}$ になったときは $L$ に，$x_{ij} = u_{ij}$ になったときは $U$ に入ります．&lt;/p>
&lt;p>閉路 $W$ の flow を更新した結果，辺 (5, 6) の flow が下限容量に，辺 (3, 4) の flow が上限容量になった場合を考えます．&lt;/p>
&lt;img src="images/閉路のflowの更新結果.png" width="50%">
&lt;p>辺 (5, 6) と辺 (3, 4) のどちらかを取り除くことができます．辺 (5, 6) を取り除き $L$ に追加すると下の全域木 $T$ が得られます．&lt;/p>
&lt;img src="images/閉路の辺の削除.png" width="50%">
&lt;h2 id="8-ポテンシャルの更新">8. ポテンシャルの更新
&lt;/h2>&lt;p>辺 (p, q) を削除したとき，木は 2 つの部分木に分割されます．根がある方の部分木を $T_1$，ない方の部分木を $T_2$ とします．&lt;br>
木の根のポテンシャルを 0 に固定し， 辺の reduced cost が 0 になるようにポテンシャルを算出していたことを考えると，$T_1$ に含まれる頂点のポテンシャルは変化せず，$T_2$ に含まれる頂点のポテンシャルのみ変化することがわかります．&lt;/p>
&lt;p>全域木に辺 (k, l) が追加され，頂点 k が $T_1$ に，頂点 l が $T_2$ に含まれる場合を考えます．&lt;br>
$T_2$ は頂点 q を根とする部分木から頂点 l を根とする部分木に変化するため，$T_2$ に属する頂点のポテンシャルを更新する必要があります．&lt;br>
木のすべての頂点のポテンシャルに定数を加算しても reduced cost は保たれるため，新しい $\pi(l)$ と現在の $\pi(l)$ の差分 $d$ が求められれば，$T_2$ に属するすべての頂点に $d$ を加算することでポテンシャルを正しい値に更新できます．&lt;br>
頂点 k のポテンシャルは変化しないことから，頂点 l の新しいポテンシャル $\pi^{\prime}(l)$ は $0 - c_{kl} + \pi(k)$ となります．&lt;br>
よって，頂点 l の新しいポテンシャルとの現在のポテンシャルの差は $\pi^{\prime}(l) - \pi(l) = 0 - c_{kl} + \pi(k) - \pi(l) = -(c_{kl} - \pi(k) + \pi(l))$ となり，これは $-c_{kl}^{\pi}$ です．&lt;br>
以上のことから，$T_2$ に属するすべての頂点に $-c_{kl}^{\pi}$ を加算することでポテンシャルを正しい値に更新できることがわかりました．&lt;br>
頂点 l が $T_1$ に，頂点 k が $T_2$ に含まれる場合も同様の議論により，$c_{kl}^{\pi}$ 増加することが示せます．&lt;/p>
&lt;p>まとめると，辺 (k, l)を追加したとき $T_2$ に含まれる頂点のポテンシャルは以下のように更新されます．&lt;/p>
&lt;ul>
&lt;li>頂点 k が $T_1$ に，頂点 l が $T_2$ に含まれる場合
&lt;ul>
&lt;li>$T_2$ に含まれる頂点のポテンシャルは $-c^{\pi}_{kl}$ 増加&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>頂点 l が $T_1$ に，頂点 k が $T_2$ に含まれる場合
&lt;ul>
&lt;li>$T_2$ に含まれる頂点のポテンシャルは $c^{\pi}_{kl}$ 増加&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;img src="images/ポテンシャルの更新.png" width="75%">
&lt;h2 id="9-strongly-feasible-spanning-tree">9. Strongly Feasible Spanning Tree
&lt;/h2>&lt;p>primal network simplex 法が有限回で終了するのかを考えます．&lt;br>
アルゴリズムの各イテレーションでは，全域木に辺を追加するこことで閉路を作り，この閉路の flow を更新することで目的関数値を減少させます．&lt;br>
目的関数値は flow 1 単位あたり $|c^{\pi}_{ij}|$ 減少するため，常に正の量の flow を流せるならアルゴリズムは有限回で終了します．&lt;br>
しかし，節 6 の最後の例のように閉路に restricted arc があると flow が増加できないイテレーションが発生することがあります．このイテレーションを degenerate iteration といいます．&lt;br>
実は primal network simplex 法は entring arc と leaving arc を任意に選ぶと degenerate iteration が無限に発生しアルゴリズムが有限回で終了しないことがあります．&lt;/p>
&lt;p>そこで，strongly feasible spanning tree という概念を導入します．&lt;br>
常に strongly feasible spanning tree を維持することによって，アルゴリズムが有限回で終了することが保証できます．&lt;/p>
&lt;h3 id="strongly-feasible-spanning-tree">strongly feasible spanning tree
&lt;/h3>&lt;p>次の条件を満たす spanning tree を strongly feasible spanning tree と呼びます．&lt;/p>
&lt;ul>
&lt;li>任意の頂点から正の量の flow を容量制約に違反することなく木に沿って根に送ることができる&lt;/li>
&lt;/ul>
&lt;p>下の図は strongly feasible spanning tree の例です．&lt;br>
すべての頂点から頂点 0 に向かって 1 以上の flow を送ることができます．&lt;br>
strongly feasible spanning tree は flow が下限の辺のは根に向いていて，flow が上限の辺は根と反対を向いている全域木とみなすこともできます．&lt;/p>
&lt;img src="images/strongly_feasible_spanning_treeの例.png" width="50%">
&lt;p>下の図は strongly feasible spanning tree ではない例です．&lt;br>
辺 (2, 1) の flow は上限容量であるため，頂点 2 から根に flow を送ることはできません．また，辺 (3, 4) の flow は下限容量であるため，頂点 4 から根に flow を送ることはできません．&lt;/p>
&lt;img src="images/strongly_feasible_spanning_treeではない例.png" width="50%">
&lt;p>節 4 の「初期 spanning tree structure の構築」は strongly feasible spanning tree を構築します．次の節で leaving arc をどのように選べば strongly feasible spanning tree を維持できるのか見ていきます．&lt;/p>
&lt;h2 id="10-strongly-feasible-spanning-tree-を保つ-leaving-arc-の選び方">10. Strongly Feasible Spanning Tree を保つ leaving arc の選び方
&lt;/h2>&lt;p>辺 (k, l) を entring arc とします．頂点 k と l の最小共通祖先を頂点 w とします．&lt;br>
このとき閉路 $W$ に沿って，頂点 w から開始して最後に見つけた blocking arc を leaving arc とすると，spanning tree は strongly feasible を維持できます．&lt;/p>
&lt;p>具体例をみます．&lt;br>
$L$ に属する辺 (k, l) が追加され閉路 $W$ が生成されたとします．閉路の向きは辺 (k, l) と同じ向きです．&lt;br>
この閉路には flow を流すことができず，辺 (w, 1) と辺 (p, q) が blocking arc になります．&lt;br>
頂点 w から閉路の向きに沿って探索し，最後に見つかる blocking arc は辺 (p, q) であるため，この辺を leaving arc とします．&lt;/p>
&lt;img src="images/strongly_feasible_spanning_treeを維持するようなleaving_arcの選び方.png" width="30%">
&lt;p>strongly feasible spanning tree から上記の方法で leaving arc を選んだとき，strongly feasible spanning tree が維持されることを示します．pivot 操作の直前は strongly feasible spanning tree であるという前提を利用します．&lt;/p>
&lt;p>頂点 w から頂点 q のパスを $W_1$，頂点 p から頂点 w のパスを $W_2$ とします．&lt;br>
「$W_1$」，「$W_2$」，「閉路以外の頂点」の 3 つについて，「任意の頂点から正の量の flow を容量制約に違反することなく木に沿って根に送ることができる」という条件を満たすか確認します．&lt;/p>
&lt;ul>
&lt;li>
&lt;p>$W_1$ 内の頂点&lt;/p>
&lt;ul>
&lt;li>直前が non-degenerate pivot&lt;sup id="fnref:5">&lt;a href="#fn:5" class="footnote-ref" role="doc-noteref">5&lt;/a>&lt;/sup> の場合
&lt;ul>
&lt;li>$\delta \gt 0$ であるため，頂点 w から$W_1$ 内の頂点に flow が送られている．$W_1$ の各頂点からは頂点 w まで $\delta$ の flow を押し戻すことができるため条件を満たす&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>直前が degenerate pivot&lt;sup id="fnref:6">&lt;a href="#fn:6" class="footnote-ref" role="doc-noteref">6&lt;/a>&lt;/sup> の場合
&lt;ul>
&lt;li>前提から，pivot の直前では頂点 l から頂点 w のパスで flow を送れていたため，このパス内に blocking arc は存在しない．よって $W_1$ は頂点 w と頂点 k の間にある&lt;/li>
&lt;li>$\delta = 0$ であり，頂点 w から頂点 k のどの辺の flow にも変化はないため条件を満たす&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>$W_2$ 内の頂点&lt;/p>
&lt;ul>
&lt;li>leaving arc の選び方を考えると，$W_2$ 内に blocking arc はないため条件を満たす&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>$W$ 以外の頂点&lt;/p>
&lt;ul>
&lt;li>頂点 u から根へのパスに閉路 $W$ が含まれないとき
&lt;ul>
&lt;li>前提から，閉路以外の flow に変化はないため，条件を満たす&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>頂点 u から根へのパスに閉路 $W$ が含まれるとき
&lt;ul>
&lt;li>u から閉路までのパスは，flow に変化がないため条件を満たす．閉路に到達したとき閉路から根まで条件を満たすので全体として条件を満たす&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>以上のことから，leaving arc に $W$ に沿って最後に見つけた blocking arc を選ぶことで，常に strongly feasible spanning tree を維持できることがわかりました．&lt;/p>
&lt;h2 id="11-アルゴリズムが有限回で終了することの証明">11. アルゴリズムが有限回で終了することの証明
&lt;/h2>&lt;p>2 つの non-degenerate pivot の間の連続する degenerate pivot が有限回であることを示します．&lt;/p>
&lt;p>degenerate pivot が発生したとき，ノードのポテンシャルが単調減少することを示します．$n$ を頂点の数，$C$ をコストの絶対値の最大値としたとき，ノードのポテンシャルの下界は $-nC$ であるため連続する degenerate pivot は有限回で終了します．&lt;/p>
&lt;ul>
&lt;li>
&lt;p>entring arc (k, l) が $L$ に属していた場合&lt;/p>
&lt;ul>
&lt;li>辺 (k, l) は $L$ に属し，最適性条件に違反するため，reduced cost は $c^{\pi}_{kl} \lt 0$ です．&lt;/li>
&lt;li>全域木は常に strongly feasible spanning tree を維持していることを考えると，degenerate pivot の場合は頂点 l から頂点 w の間に blocking arc は存在しないため，新しく作成される木は頂点 l に 頂点 k がぶら下がる形になります．&lt;/li>
&lt;li>頂点 k を根とする部分木のポテンシャルは $c^{\pi}_{kl} \lt 0$ 増加するため，ノードのポテンシャルは単調減少します&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>entring arc (k, l) が $U$ に属していた場合&lt;/p>
&lt;ul>
&lt;li>辺 (k, l) は $U$ に属し，最適性条件に違反するため，reduced cost は $c^{\pi}_{kl} \gt 0$ です．&lt;/li>
&lt;li>新しく作成される木は頂点 k に 頂点 l がぶら下がる形になります．&lt;/li>
&lt;li>頂点 l を根とする部分木のポテンシャルは $c^{\pi}_{kl} \gt 0$ 減少するため，ノードのポテンシャルは単調減少します&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>以上のことから 2 つの non-degenerate pivot の間の連続する degenerate pivot が有限回であることがわかりました．
non-degenerate pivot は目的関数値を厳密に減少させるため，アルゴリズムは有限回で終了します．&lt;/p>
&lt;h2 id="補足-1-最適-spanning-tree-solution-が必ず存在することについて">補足 1. 最適 spanning tree solution が必ず存在することについて
&lt;/h2>&lt;h3 id="cycle-free-solution">cycle free solution
&lt;/h3>&lt;p>free arc のみからなる閉路を持たないような実行可能解 $x$ を cycle free solution といいます．&lt;/p>
&lt;p>下の図は cycle free solution の例です．辺の上に (流量，コスト) を示し，下限容量は 0，上限容量は無限とします．&lt;br>
青色の辺 (0, 1)，(1, 3)，(3, 4) が free arc です．free arc のみからなる閉路がないため cycle free solution です．この解の目的関数値は $(2 \times 0) + (2 \times 1) + (2 \times 0) = 2$ です．&lt;/p>
&lt;img src="images/cycle_free_solutionの例.png" width="50%">
&lt;p>下の図は cycle free solution ではない例です．&lt;br>
青色の辺 (0, 1)，(1, 2)，(1, 3)，(2, 4)，(3, 4) が free arc です．free arc のみからなる閉路があるため cycle free solution ではありません．この解の目的関数値は $(2 \times 0) + (1 \times 3) + (1 \times 1) + (1 \times -1) + (1 \times 0) = 3$ です．&lt;/p>
&lt;img src="images/cycle_free_solutionではない例.png" width="50%">
&lt;p>cycle free solution でない解が与えられたとき，閉路の flow を操作することで，目的関数値が大きくならないように cycle free solution にすることができます．&lt;br>
この解の場合，時計回りに flow を 1 増加すると，辺 (2, 4)，(1, 2) の flow が 1 減り，辺(1, 3)，(3, 4) の flow が 1 増えます．結果，この解の目的関数値は $(2 \times 0) + (0 \times 3) + (2 \times 1) + (0 \times -1) + (2 \times 0) = 2$ と 1 小さくなり，さらに cycle free solution になりました．&lt;/p>
&lt;img src="images/cycle_free_solutionに変形.png" width="50%">
&lt;p>このように，cycle free でない解は閉路の flow を操作することで目的関数値が大きくならないように cycle free solution にできるため，MCFP に最適解があるとき，常に同じ目的関数値である cycle free solution を持つことがわかります．&lt;/p>
&lt;h3 id="cycle-free-solution-から-spanning-tree-solution-を求める">cycle free solution から spanning tree solution を求める
&lt;/h3>&lt;p>cycle free solution は辺を適切に選ぶことで spanning tree solution を求めるとができます．&lt;br>
下の図では，青色の辺(0, 1)，(1, 2)，(1, 3)，(3, 4) を全域木として選んでいます．&lt;/p>
&lt;img src="images/cycle_free_solutionをspanning_tree_solutionに.png" width="50%">
&lt;p>以上のことから，MCFP に最適解があるとき，常に同じ目的関数値である最適 spanning tree solution を持つことがわかりました．&lt;/p>
&lt;h2 id="補足-2-spanning-tree-structure-の最適性条件">補足 2. Spanning Tree Structure の最適性条件
&lt;/h2>&lt;p>spanning tree structure が次の条件を満たすとき，spanning tree structure に対応する spanning tree solution は最適 spanning solution となることを示します．&lt;/p>
$$
\begin{aligned}
c^{\pi}_{ij} = 0 &amp;&amp; \forall (i, j) \in T \\
c^{\pi}_{ij} \ge 0 &amp;&amp; \forall (i, j) \in L \\
c^{\pi}_{ij} \le 0 &amp;&amp; \forall (i, j) \in U \\
\end{aligned}
$$&lt;p>まず，$\sum_{(i, j) \in A} c_{ij} x_{ij}$ を最小化することは $\sum_{(i, j) \in A} c_{ij}^{\pi} x_{ij}$ を最小化することと等しいことを示します．&lt;/p>
&lt;p>$z(\pi) = \sum_{(i, j) \in A} c_{ij}^{\pi} x_{ij}$ とします．$c_{ij}^{\pi} = c_{ij} - \pi(i) + \pi(j)$ なので，$z(0) = \sum_{(i, j) \in A} c_{ij} x_{ij}$ です．&lt;br>
頂点 k のポテンシャルを $0$ から $\pi(k)$ まで増加したとします．&lt;br>
$c_{ij}^{\pi} = c_{ij} - \pi(i) + \pi(j)$ なので，reduced cost は頂点 k から流出する flow 1 単位あたり $\pi(k)$ 減少し，頂点 k に流入する flow 1 単位あたり $\pi(k)$ 増加します．よって，全体の reduced cost は $ - \pi(k) \times k$ からの流出量 + $\pi(k) \times k$ への流入量だけ変化します．&lt;/p>
&lt;p>MCFP の制約条件から，各頂点 i の流出量と流入量の関係は $\sum_{j:(i, j) \in A} x_{ij} - \sum_{j:(j,i) \in A} x_{ji} = b_i$ です．&lt;br>
よって，頂点 k のポテンシャルを $\pi(k)$ 増加すると，目的関数値は $\pi(k)b(k)$ 減少することになります．&lt;br>
すべての頂点に同様のことがいえるので，$z(0) - z(\pi) = \sum_{i \in N} \pi(i)b(i) = \pi b$ となります．&lt;br>
$\pi b$ は定数のため，$z(\pi)$ を最小化する flow は $z(0)$ を最小化することがわかりました．&lt;/p>
&lt;p>次に，$x^{\ast}$ を上の最適性条件を満たす (T, L, U) に対応する解としたとき，これが最適解であることを示します．&lt;br>
最適性条件を満たすポテンシャルを $\pi$ としたとき，$\sum_{(i, j) \in A} c_{ij}^{\pi} x_{ij}$ の最小化を考えます．&lt;br>
$\sum_{(i, j) \in A} c_{ij}^{\pi} x_{ij}$ を最小化することは $\sum_{(i, j) \in L} c_{ij}^{\pi} x_{ij} - \sum_{(i, j) \in U} |c_{ij}^{\pi}| x_{ij}$ を最小化すること等しいです．&lt;/p>
&lt;p>$\forall (i, j) \in L$ に対して $x_{ij} \ge x_{ij}^{\ast} = l_{ij}$ であり，$\forall (i, j) \in U$ に対して $x_{ij} \le x_{ij}^{\ast} = u_{ij}$ であるため，$x^{\ast}$ の目的関数値は $x$ の目的関数値以下となります．&lt;br>
以上のことから，最適性条件を満たす spanning tree structure は最適解となることがわかりました．&lt;/p>
&lt;h2 id="参考">参考
&lt;/h2>&lt;ul>
&lt;li>&lt;a class="link" href="https://www.amazon.co.jp/dp/1292042702" target="_blank" rel="noopener"
>Network Flows: Pearson New International Edition&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://homes.di.unimi.it/righini/Didattica/OttimizzazioneCombinatoria/MaterialeOC/9b%20-%20NetworkSimplex.pdf" target="_blank" rel="noopener"
>The network simplex algorithm&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://coral.ise.lehigh.edu/~ted/teaching/ie411/" target="_blank" rel="noopener"
>IE 411: Graphs and Network Flows (Python)&lt;/a>&lt;/li>
&lt;/ul>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>正確には，実行可能領域に下界が存在するならば最適 spanning tree solution が少なくとも 1 つ存在します．&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2">
&lt;p>全域木の辺として restricted arc を選ぶこともできます&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:3">
&lt;p>辺 (i, j) に対し頂点 j から頂点 i に flow を流すと，辺 (i, j) の flow を減らすことになります．例えば，辺 (2, 1) に対して頂点 1 から頂点 2 に flow を流すと，辺 (2, 1) の flow は 1 減り，コストは 5 下がります．&amp;#160;&lt;a href="#fnref:3" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:4">
&lt;p>辺の lower が 0 でない場合，先に lower 分の flow を流しておきます．&amp;#160;&lt;a href="#fnref:4" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:5">
&lt;p>$\delta \gt 0$ である pivot&amp;#160;&lt;a href="#fnref:5" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:6">
&lt;p>$\delta = 0$ である pivot&amp;#160;&lt;a href="#fnref:6" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item></channel></rss>