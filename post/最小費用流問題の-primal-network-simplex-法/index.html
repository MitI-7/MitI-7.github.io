<!doctype html><html lang=ja dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="最小費用流問題(Minimum Cost Flow Problem) $N$ を頂点の集合，$A$ を辺の集合，$c_{ij}$ を辺 $(i, j)$ の単位流量あたりのコスト，$x_{ij}$ を辺 $(i, j)$ の流量，$b_i$ を頂点 i の需要/供給量，$l$ を辺の下限容量，$u$ を辺の上限容量としたとき，最小費用流問題（以下 MCFP）は以下のように定式化されます．\n1 つめの制約を流量保存則と呼び，第一項は頂点 i から出る流量，第二項は頂点 i に入る流量を表します． 2 つめの制約を容量制約と呼びます．\n"><title>最小費用流問題の Primal Network Simplex 法</title><link rel=canonical href=https://miti-7.github.io/post/%E6%9C%80%E5%B0%8F%E8%B2%BB%E7%94%A8%E6%B5%81%E5%95%8F%E9%A1%8C%E3%81%AE-primal-network-simplex-%E6%B3%95/><link rel=stylesheet href=/scss/style.min.d71c2372cfafb2b91702509882c4a416b145224db25049e8a59681371b974984.css><meta property='og:title' content="最小費用流問題の Primal Network Simplex 法"><meta property='og:description' content="最小費用流問題(Minimum Cost Flow Problem) $N$ を頂点の集合，$A$ を辺の集合，$c_{ij}$ を辺 $(i, j)$ の単位流量あたりのコスト，$x_{ij}$ を辺 $(i, j)$ の流量，$b_i$ を頂点 i の需要/供給量，$l$ を辺の下限容量，$u$ を辺の上限容量としたとき，最小費用流問題（以下 MCFP）は以下のように定式化されます．\n1 つめの制約を流量保存則と呼び，第一項は頂点 i から出る流量，第二項は頂点 i に入る流量を表します． 2 つめの制約を容量制約と呼びます．\n"><meta property='og:url' content='https://miti-7.github.io/post/%E6%9C%80%E5%B0%8F%E8%B2%BB%E7%94%A8%E6%B5%81%E5%95%8F%E9%A1%8C%E3%81%AE-primal-network-simplex-%E6%B3%95/'><meta property='og:site_name' content='Eating Your Own Cat Food'><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='minimum cost flow'><meta property='article:published_time' content='2024-09-11T00:00:00+09:00'><meta property='article:modified_time' content='2024-09-11T00:00:00+09:00'><meta property='og:image' content='https://miti-7.github.io/post/%E6%9C%80%E5%B0%8F%E8%B2%BB%E7%94%A8%E6%B5%81%E5%95%8F%E9%A1%8C%E3%81%AE-primal-network-simplex-%E6%B3%95/images/%E3%83%9D%E3%83%86%E3%83%B3%E3%82%B7%E3%83%A3%E3%83%AB%E3%81%AE%E6%9B%B4%E6%96%B0.png'><meta name=twitter:site content="@miti_7"><meta name=twitter:creator content="@miti_7"><meta name=twitter:title content="最小費用流問題の Primal Network Simplex 法"><meta name=twitter:description content="最小費用流問題(Minimum Cost Flow Problem) $N$ を頂点の集合，$A$ を辺の集合，$c_{ij}$ を辺 $(i, j)$ の単位流量あたりのコスト，$x_{ij}$ を辺 $(i, j)$ の流量，$b_i$ を頂点 i の需要/供給量，$l$ を辺の下限容量，$u$ を辺の上限容量としたとき，最小費用流問題（以下 MCFP）は以下のように定式化されます．\n1 つめの制約を流量保存則と呼び，第一項は頂点 i から出る流量，第二項は頂点 i に入る流量を表します． 2 つめの制約を容量制約と呼びます．\n"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content='https://miti-7.github.io/post/%E6%9C%80%E5%B0%8F%E8%B2%BB%E7%94%A8%E6%B5%81%E5%95%8F%E9%A1%8C%E3%81%AE-primal-network-simplex-%E6%B3%95/images/%E3%83%9D%E3%83%86%E3%83%B3%E3%82%B7%E3%83%A3%E3%83%AB%E3%81%AE%E6%9B%B4%E6%96%B0.png'><link rel="shortcut icon" href=/images/favicon.ico><script async src="https://www.googletagmanager.com/gtag/js?id=G-5V27L45K60"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-5V27L45K60")}</script><link rel=stylesheet href=https://use.fontawesome.com/releases/v6.7.2/css/all.css></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"dark")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label=メニューを開く・閉じる>
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/images/avatar.png width=300 height=300 class=site-logo loading=lazy alt=Avatar></a></figure><div class=site-meta><h1 class=site-name><a href=/>Eating Your Own Cat Food</a></h1><h2 class=site-description></h2></div></header><ol class=menu-social><li><a href=https://x.com/MitI_7 target=_blank title=01_Twitter rel=me><svg class="icon icon-tabler icon-tabler-brand-twitter" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M22 4.01c-1 .49-1.98.689-3 .99-1.121-1.265-2.783-1.335-4.38-.737S11.977 6.323 12 8v1c-3.245.083-6.135-1.395-8-4 0 0-4.182 7.433 4 11-1.872 1.247-3.739 2.088-6 2 3.308 1.803 6.913 2.423 10.034 1.517 3.58-1.04 6.522-3.723 7.651-7.742a13.84 13.84.0 00.497-3.753C20.18 7.773 21.692 5.25 22 4.009z"/></svg></a></li><li><a href=https://github.com/MitI-7 target=_blank title=02_GitHub rel=me><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=/index.xml target=_blank title=03_RSS rel=me><svg class="icon icon-tabler icon-tabler-rss" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="5" cy="19" r="1"/><path d="M4 4a16 16 0 0116 16"/><path d="M4 11a9 9 0 019 9"/></svg></a></li><li><a href=mailto:miti_7@outlook.com target=_blank title=05_mail rel=me><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-mail"><path d="M4 4h16c1.1.0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1.0-2-.9-2-2V6c0-1.1.9-2 2-2z"/><polyline points="22,6 12,13 2,6"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span></a></li><li><a href=/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Archives</span></a></li><li><a href=/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>Search</span></a></li><li><a href=/links/><svg class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M10 14a3.5 3.5.0 005 0l4-4a3.5 3.5.0 00-5-5l-.5.5"/><path d="M14 10a3.5 3.5.0 00-5 0l-4 4a3.5 3.5.0 005 5l.5-.5"/></svg>
<span>Links</span></a></li><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>ダークモード</span></li></ol></li></ol></aside><main class="main full-width"><article class="has-image main-article"><header class=article-header><div class=article-image><a href=/post/%E6%9C%80%E5%B0%8F%E8%B2%BB%E7%94%A8%E6%B5%81%E5%95%8F%E9%A1%8C%E3%81%AE-primal-network-simplex-%E6%B3%95/><img src=/post/%E6%9C%80%E5%B0%8F%E8%B2%BB%E7%94%A8%E6%B5%81%E5%95%8F%E9%A1%8C%E3%81%AE-primal-network-simplex-%E6%B3%95/images/%E3%83%9D%E3%83%86%E3%83%B3%E3%82%B7%E3%83%A3%E3%83%AB%E3%81%AE%E6%9B%B4%E6%96%B0_hu_b8f0a0c94d77548d.png srcset="/post/%E6%9C%80%E5%B0%8F%E8%B2%BB%E7%94%A8%E6%B5%81%E5%95%8F%E9%A1%8C%E3%81%AE-primal-network-simplex-%E6%B3%95/images/%E3%83%9D%E3%83%86%E3%83%B3%E3%82%B7%E3%83%A3%E3%83%AB%E3%81%AE%E6%9B%B4%E6%96%B0_hu_b8f0a0c94d77548d.png 800w, /post/%E6%9C%80%E5%B0%8F%E8%B2%BB%E7%94%A8%E6%B5%81%E5%95%8F%E9%A1%8C%E3%81%AE-primal-network-simplex-%E6%B3%95/images/%E3%83%9D%E3%83%86%E3%83%B3%E3%82%B7%E3%83%A3%E3%83%AB%E3%81%AE%E6%9B%B4%E6%96%B0_hu_a7e1202312e24124.png 1600w" width=800 height=347 loading=lazy alt="Featured image of post 最小費用流問題の Primal Network Simplex 法"></a></div><div class=article-details><header class=article-category><a href=/categories/%E7%B5%84%E5%90%88%E3%81%9B%E6%9C%80%E9%81%A9%E5%8C%96/>組合せ最適化
</a><a href=/categories/%E3%82%B0%E3%83%A9%E3%83%95/>グラフ
</a><a href=/categories/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0/>アルゴリズム</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/post/%E6%9C%80%E5%B0%8F%E8%B2%BB%E7%94%A8%E6%B5%81%E5%95%8F%E9%A1%8C%E3%81%AE-primal-network-simplex-%E6%B3%95/>最小費用流問題の Primal Network Simplex 法</a></h2></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>2024/09/11</time></div></footer></div></header><section class=article-content><h2 id=最小費用流問題minimum-cost-flow-problem>最小費用流問題(Minimum Cost Flow Problem)</h2><p>$N$ を頂点の集合，$A$ を辺の集合，$c_{ij}$ を辺 $(i, j)$ の単位流量あたりのコスト，$x_{ij}$ を辺 $(i, j)$ の流量，$b_i$ を頂点 i の需要/供給量，$l$ を辺の下限容量，$u$ を辺の上限容量としたとき，最小費用流問題（以下 MCFP）は以下のように定式化されます．<br>1 つめの制約を流量保存則と呼び，第一項は頂点 i から出る流量，第二項は頂点 i に入る流量を表します．
2 つめの制約を容量制約と呼びます．</p>$$
\begin{aligned}
&\text{minimize} && \sum_{(i, j) \in A} c_{ij} x_{ij} \\
&\text{subject to}
&& \sum_{j:(i, j) \in A} x_{ij} - \sum_{j:(j,i) \in A} x_{ji} = b_i && \forall i \in N \\
& && l_{ij} \le x_{ij} \leq u_{ij} && \forall (i, j) \in A
\end{aligned}
$$<p>以下ではコスト，流量，需要/供給，下限容量，上限容量はすべて整数とします．また，$\sum_{i \in N} b_i = 0$ を仮定します．</p><h2 id=primal-network-simplex-法>Primal Network Simplex 法</h2><p>primal network simplex 法は，ネットワーク構造を利用することで simplex 法を効率化させたアルゴリズムです．今回は primal network simplex 法で MCFP を解いていきます．<br>MCFP が必ず 最適 spanning tree solution という解を持つことを利用し，spanning tree solution のみを探索することで効率的に最適解を見つけることができます<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>．</p><p>primal network simplex 法は，simplex 法の観点と負閉路除去法の観点から説明することができますが，今回は負閉路除去法の観点で説明します．
節 1 で spanning tree solution の定義をします．節 2 で spanning tree solution は spanning tree structure として表せることと，spanning tree structure が最適解となる条件について示します．節 3 で primal network simplex 法の流れについて説明し，節 4 から 節 8 でアルゴリズムの各段階の詳細について述べます．節 9 から節 11 で退化について説明します．</p><h2 id=1-spanning-tree-solution>1. spanning tree solution</h2><p>ある実行可能解 $x$ に対して， $l_{ij} &lt; x_{ij} &lt; u_{ij}$ を満たす辺を free arc，$x_{ij} = l_{ij}$ か $x_{ij} = u_{ij}$ を満たす辺を restricted arc と呼びます．
解 $x$ とそれに関連する全域木が以下の条件を満たすとき，spanning tree solution と呼びます．特に，$x$ が 最適解であるとき最適 spanning tree solution と呼びます．</p><ul><li>$x$ が実行可能解である</li><li>全域木に含まれない辺（non-tree arc）がすべて restricted arc である</li></ul><p>具体例を示します．簡単のため，辺容量の下限はすべて 0 としコストは省略します．$b(0) = 2$，$b(3) = -2$ とします．<br>下の図のグラフでは辺 (0, 1)，(2, 3) が free arc，辺 (0, 2)，(1, 2)，(1, 3) が restricted arc です．<br>解 $x$ は流量保存則と容量制約を満たすため実行可能解です．全域木として，青色の辺 (0, 1)，(0, 2)，(2, 3) を選ぶ<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>と，non-tree arc は (1, 2) と (1, 3) となり，すべて restricted arc であるため spanning tree solution となります．</p><img src=images/spanning_tree_solutionの例1.png width=50%><p>また，全域木として，青色の辺 (0, 1)，(1, 2)，(2, 3) を選んでも spanning tree solution となります．
このように，1 つの実行可能解に複数の spanning tree solution が対応することがあります．</p><img src=images/spanning_tree_solutionの例2.png width=50%><h2 id=2-spanning-tree-structure-と最適性条件>2. spanning tree structure と最適性条件</h2><p>spanning tree solution は辺集合を次の 3 つに分割します．</p><ul><li>T: 全域木の辺</li><li>L: non-tree arc のうち，flow が下限の辺</li><li>U: non-tree arc のうち，flow が上限の辺</li></ul><p>この 3 つ組 (T, L, U) を spanning tree structure と呼びます．spanning tree structure は spanning tree solution から一意に構築されます．</p><p>頂点 i のポテンシャルを $\pi(i)$，辺 (i, j) の reduced cost を $c_{ij}^{\pi} = c_{ij} - \pi(i) + \pi(j)$ で表します．spanning tree structure が次の条件を満たすとき，spanning tree structure に対応する spanning tree solution は最適 spanning solution となります．このような，spanning tree structure を最適 spanning tree structure と呼びます．</p>$$
\begin{aligned}
c^{\pi}_{ij} = 0 && \forall (i, j) \in T \\
c^{\pi}_{ij} \ge 0 && \forall (i, j) \in L \\
c^{\pi}_{ij} \le 0 && \forall (i, j) \in U \\
\end{aligned}
$$<p>全域木の根のポテンシャルを 0 と固定すると $T$ に属する辺 (i, j) が $c^{\pi}_{ij} = 0$ を満たすように各頂点のポテンシャル $\pi$ を定めることができます．このとき，$-\pi(i)$ は根から頂点 i への木のパスの長さとみなすことができます．
具体例として，下の図の全域木について各頂点のポテンシャルを求めていきます．頂点 0 を根とします．</p><p>頂点 1 のポテンシャルを求めます．
辺 (i, j) の reduced cost は $c_{ij}^{\pi} = c_{ij} - \pi(i) + \pi(j)$ です．全域木の辺の reduced cost は 0，辺 (0, 1) のコストは 1，頂点 0 のポテンシャルは 0 であることから，$0 = 1 - 0 + \pi(1)$ となり，$\pi(1) = -1$と求められます．</p><p>頂点 2 のポテンシャルを求めます．
辺 (2, 1) のコストは 5 ，頂点 1 のポテンシャルは -1 なので，$0 = 5 - \pi(2) + (-1)$ となり，$\pi(2) = 4$ と求められます．</p><p>同様の計算を行うことで，全頂点のポテンシャルを計算することができます．</p><img src=images/ポテンシャルの計算.png width=50%><p>全頂点のポテンシャルを求めると，$L$ と $U$ に属する辺の reduced cost を計算することができます．すべての辺が最適性条件を満たすならば，最適 spanning tree structure と判定できます．</p><h2 id=3-network-simplex-法のアルゴリズムの流れ>3. Network Simplex 法のアルゴリズムの流れ</h2><p>spanning tree structure が与えられたとき，全域木の reduced cost が 0 となるように各頂点のポテンシャルを計算し，各辺の reduced cost を求めることで最適 spanning structure かどうか判定することができました．
最適 spanning tree structure でない場合， $L$ に属する $c_{ij}^{\pi} \lt 0$ である辺か，$U$ に属する $c_{ij}^{\pi} \gt 0$ である辺が 1 つ以上存在することになります．
これらの辺を $T$ に追加したときを考えます．</p><h3 id=l-に属する-cpi_ij-lt-0-である辺を-t-に追加>$L$ に属する $c^{\pi}_{ij} \lt 0$ である辺を $T$ に追加</h3><p>$L$ に属する $c_{ij}^{\pi} \lt 0$ である辺 (i, j) を $T$ に追加したとします．<br>このとき，根から i，i から j，j から根をたどるパスの flow を 1 増加すると，目的関数値は $c^{\pi}_{ij}$ 増加します．</p><p>具体例を見てみます．下の図の全域木にコスト -8 の辺 (2, 4) を追加したとします．この辺の reduced cost は $-8 - 4 + (-3) = -15$ です．<br>辺 (0, 1)，(2, 1)，(2, 4)，(3, 4)，(3, 0) の順に flow を 1 単位流すと，全体のコストの合計は，1 + (-5) + (-8) + (-5) + 2 = -15 となり，目的関数値が 15 減少する（-15 増加する）ことがわかります<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>．</p><img src=images/全域木にLの辺を追加.png width=50%><h3 id=u-に属する-cpi_ij-gt-0-である辺を-t-に追加>$U$ に属する $c^{\pi}_{ij} \gt 0$ である辺を $T$ に追加</h3><p>$U$ に属する $c_{ij}^{\pi} \gt 0$ である辺 (i, j) を $T$ に追加したとします．<br>このとき，根から j， j から i，i から根をたどるパスの flow を 1 増加すると，目的関数値は $c^{\pi}_{ij}$ 減少します．</p><p>下の図の全域木にコスト -5 の辺 (6, 4) を追加したとします．この辺の reduced cost は $(-5) - (-11) + (-3) = 3$ です．<br>辺 (3, 0)，(3, 4)，(6, 4)，(5, 6)，(3, 5)，(3, 0) の順に flow を 1 単位流すと，全体のコストの合計は，-2 + 5 + (-(-5)) + (-7) + (-6) + 2 = -3 となり，目的関数値が 3 減少することがわかります．<br>また，辺 (0, 3) に対し，頂点 0 から 頂点 3 に flow を流し，頂点 3 から頂点 0 に flow を流すと flow は打ち消し合うため，追加した辺によって生じる閉路のみを考慮すればいいこともわかります．</p><img src=images/全域木にUの辺を追加.png width=50%><p>以上のことから，spanning tree structure が最適でないとき，最適性条件に違反する辺を全域木に追加したことによって生じる閉路の flow を更新することで目的関数値を減少できることがわかりました．<br>閉路の flow を限界まで増加させると，1 本以上の辺の flow が下限容量か上限容量に達するため，その辺を取り除くことによって新しい spanning tree solution を生成することができます．<br>primal network simplex 法は これらの処理を最適性条件を満たすまで繰り返すことで最適解を求めます．</p><p>primal network simplex 法の流れは以下のようになります</p><ul><li>初期 spanning tree structure を構築する</li><li>spanning tree structure が最適性条件を満たさない間，以下を繰り返す<ul><li>最適性条件に違反する辺を $U$ か $L$ から選び，全域木に追加する</li><li>閉路の flow を更新する</li><li>flow が下限容量か上限容量に達した辺を閉路から 1 つ取り除き新しく全域木を作成する</li></ul></li></ul><p>次節からアルゴリズムの各段階の詳細について説明していきます．</p><h2 id=4-初期-spanning-tree-structre-の構築>4. 初期 spanning tree structre の構築</h2><p>初期 spanning tree structre (T, L, U) を構築します．<br>まず，人工頂点 $s$ を作り，$s$ と既存の各頂点 $u$ の間に以下のように辺をはります．</p><ul><li>$b(u) \ge 0$ の場合，流量 $b(u)$ の辺 $(u, s)$ を加える</li><li>$b(u) \lt 0$ の場合，流量 $-b(u)$ の辺 $(s, u)$ を加える</li></ul><p>いずれの人工辺も容量とコストは十分大きい値とします．人工辺は $T$ に，もとからある辺は $L$ に，$U$ は空とします.<br>このように作られた spanning tree structure は実行可能解です．今後はこの拡張された network 上で問題を解いていきます．人工辺のコストは十分大きいため最適解が得られたとき人工辺に flow は流れていません．</p><p>例として下のグラフの初期 spanning tree structure を構築します．<br>$b(0) = 2$，$b(3) = -2$，他の頂点の需要/供給は 0 とします．また，すべての辺の下限容量は 0 とします<sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup>．</p><img src=images/初期解の問題例.png width=50%><p>まず，人工頂点として，$s$ を追加します．<br>$b(u) \ge 0$ である頂点 0, 1, 2 から s に向けて辺を追加します．$b(0) = 2$ であるため，辺 (0, s)の flow は 2 とします．<br>s から $b(u) \lt 0$ である頂点 3 に向けて辺を追加します．$b(3) = -2$ であるため，辺 (s, 3)の flow は 2 とします．</p><img src=images/初期解の構築.png width=50%><p>初期 spanning tree structure は以下のようになります．</p><ul><li>$T$ に属する辺：(0, s)，(1, s)，(2, s)，(s, 3)</li><li>$L$ に属する辺：(0, 1)，(0, 2)，(1, 2)，(1, 3)，(2, 3)</li><li>$U$ に属する辺：なし</li></ul><h2 id=5-entring-arc-の選択>5. entring arc の選択</h2><p>$T$ に追加する辺（entring arc）を $U$ か $L$ から選びます．<br>このとき，以下のような最適性条件を満たさない辺（eligible arc）を選びます．また，$|c^{\pi}_{ij}|$ を violation と呼びます．</p>$$
\begin{aligned}
c^{\pi}_{ij} \lt 0 && \forall (i, j) \in L \\
c^{\pi}_{ij} \gt 0 && \forall (i, j) \in U
\end{aligned}
$$<p>代表的な辺の選択方法は以下の 3 つです．</p><ul><li><p>Best eligible arc pivot rule(Dantzig&rsquo;s pivot rule)</p><ul><li>violation の最も大きい eligible arc を entring arc とする</li><li>1 flow 単位の改善が最も大きいため，イテレーションの回数は少なくなる</li><li>すべての non-tree arc を調べる必要があるため，1 回のイテレーションのコストが大きい</li></ul></li><li><p>First eligible arc pivot rule</p><ul><li>最初に見つけた eligible arc を entring arc とする．次のイテレーションでは，前回選択した辺の次から探索を開始する．最後の辺まで探索をしたら先頭に戻る</li><li>1 回のイテレーションのコストが小さい</li><li>1 flow 単位の改善が小さくなるので，イテレーションの回数が多くなる</li></ul></li><li><p>Block search pivot rule</p><ul><li>辺をブロックに分割し，ブロックの中で violation の最も大きい eligible arc を entring arc とする．ブロック内で見つからなかった場合，次のブロックを探索する</li><li>すべての辺を同じブロックにしたとき，Best eligible arc pivot rule と同じ挙動になる</li><li>すべての辺を違うブロックにしたとき，First eligible arc pivot rule と同じ挙動になる</li></ul></li></ul><h2 id=6-flow-の更新>6. flow の更新</h2><p>全域木に辺を追加すると閉路 $W$ がちょうど 1 つできます．この閉路の flow を 1 単位増加するごとに，MCFP の目的関数値は $|c^{\pi}_{ij}|$ 減少するため，$W$ の flow を容量制約を満たす限界まで増加します．<br>閉路 $W$ の向きを次のように定めます．</p><ul><li>$(k, l) \in L$ のとき，辺 (k, l) と同じ方向</li><li>$(k, l) \in U$ のとき，辺 (k, l) と逆方向</li></ul><p>閉路 $W$ の順辺の集合を $\bar W$，逆辺の集合を $\underbar W$ で表したとき，$W$ の各辺の flow の増加できる量は以下のようになります．</p>$$
\delta_{ij} = \left\{
\begin{array}{ll}
u_{ij} - x_{ij} & (i, j) \in \bar{W}\\
x_{ij} - l_{ij} & (i, j) \in \underbar{W}
\end{array}
\right.
$$<p>$\delta = min \lbrace \delta_{ij} : (i, j) \in W \rbrace$ とし，$W$ の各辺の flow を以下のように更新します．</p>$$
x_{ij} = \left\{
\begin{array}{ll}
x_{ij} + \delta & (i, j) \in \bar{W}\\
x_{ij} - \delta & (i, j) \in \underbar{W}
\end{array}
\right.
$$<p>具体例を見ます．すべての辺の下限は 0 とします．<br>$U$ に属する辺 (6, 4) を $T$ に追加すると，辺 (6, 4)，(5, 6)，(3, 5)，(3, 4) からなる閉路ができます．<br>辺 (6, 4) は $U$ に属するので，(6, 4) と逆方向である反時計回りを $W$ の向きとします．$\bar W$ に属する辺は，(3, 4)，$\underbar W$ に属する辺は，(6, 4)，(5, 6)，(3, 5) です．<br>各辺の $\delta_{ij}$ と $\delta$ は以下の通りです．</p><ul><li>$\delta_{64} = 6 - 0 = 6$</li><li>$\delta_{56} = 2 - 0 = 2$</li><li>$\delta_{35} = 4 - 0 = 4$</li><li>$\delta_{34} = 3 - 1 = 2$</li><li>$\delta = min \lbrace 6, 2, 4, 2 \rbrace = 2$</li></ul><img src=images/閉路のflowの更新.png width=50%><p>閉路 $W$ の flow を 2 増加すると以下のようになります．</p><img src=images/閉路のflowの更新結果.png width=50%><p>別の例をみます．
辺 (3, 4) の flow が 3 のとき，各辺の $\delta_{ij}$は以下のようになります．</p><ul><li>$\delta_{64} = 6 - 0 = 6$</li><li>$\delta_{56} = 2 - 0 = 2$</li><li>$\delta_{35} = 4 - 0 = 4$</li><li>$\delta_{34} = 3 - 3 = 0$</li><li>$\delta = min \lbrace 6, 2, 4, 0 \rbrace = 0$</li></ul><p>このように全域木に $x_{ij} = l_{ij}$ や $x_{ij} = u_{ij}$ の辺があると flow が更新できないことがあります．</p><img src=images/閉路のflowを更新できない例.png width=50%><h2 id=7-leaving-arc-の選択>7. leaving arc の選択</h2><p>閉路の flow を限界まで増加したとき 1 本以上の辺が $\delta = \delta_{ij}$ となります．この辺を blocking arc と呼びます．<br>blocking arc を取り除く辺（leaving arc）として選びます（複数ある場合は任意の辺を選びます）．<br>辺 (i, j) が $x_{ij}$ = $l_{ij}$ になったときは $L$ に，$x_{ij} = u_{ij}$ になったときは $U$ に入ります．</p><p>閉路 $W$ の flow を更新した結果，辺 (5, 6) の flow が下限容量に，辺 (3, 4) の flow が上限容量になった場合を考えます．</p><img src=images/閉路のflowの更新結果.png width=50%><p>辺 (5, 6) と辺 (3, 4) のどちらかを取り除くことができます．辺 (5, 6) を取り除き $L$ に追加すると下の全域木 $T$ が得られます．</p><img src=images/閉路の辺の削除.png width=50%><h2 id=8-ポテンシャルの更新>8. ポテンシャルの更新</h2><p>辺 (p, q) を削除したとき，木は 2 つの部分木に分割されます．根がある方の部分木を $T_1$，ない方の部分木を $T_2$ とします．<br>木の根のポテンシャルを 0 に固定し， 辺の reduced cost が 0 になるようにポテンシャルを算出していたことを考えると，$T_1$ に含まれる頂点のポテンシャルは変化せず，$T_2$ に含まれる頂点のポテンシャルのみ変化することがわかります．</p><p>全域木に辺 (k, l) が追加され，頂点 k が $T_1$ に，頂点 l が $T_2$ に含まれる場合を考えます．<br>$T_2$ は頂点 q を根とする部分木から頂点 l を根とする部分木に変化するため，$T_2$ に属する頂点のポテンシャルを更新する必要があります．<br>木のすべての頂点のポテンシャルに定数を加算しても reduced cost は保たれるため，新しい $\pi(l)$ と現在の $\pi(l)$ の差分 $d$ が求められれば，$T_2$ に属するすべての頂点に $d$ を加算することでポテンシャルを正しい値に更新できます．<br>頂点 k のポテンシャルは変化しないことから，頂点 l の新しいポテンシャル $\pi^{\prime}(l)$ は $0 - c_{kl} + \pi(k)$ となります．<br>よって，頂点 l の新しいポテンシャルとの現在のポテンシャルの差は $\pi^{\prime}(l) - \pi(l) = 0 - c_{kl} + \pi(k) - \pi(l) = -(c_{kl} - \pi(k) + \pi(l))$ となり，これは $-c_{kl}^{\pi}$ です．<br>以上のことから，$T_2$ に属するすべての頂点に $-c_{kl}^{\pi}$ を加算することでポテンシャルを正しい値に更新できることがわかりました．<br>頂点 l が $T_1$ に，頂点 k が $T_2$ に含まれる場合も同様の議論により，$c_{kl}^{\pi}$ 増加することが示せます．</p><p>まとめると，辺 (k, l)を追加したとき $T_2$ に含まれる頂点のポテンシャルは以下のように更新されます．</p><ul><li>頂点 k が $T_1$ に，頂点 l が $T_2$ に含まれる場合<ul><li>$T_2$ に含まれる頂点のポテンシャルは $-c^{\pi}_{kl}$ 増加</li></ul></li><li>頂点 l が $T_1$ に，頂点 k が $T_2$ に含まれる場合<ul><li>$T_2$ に含まれる頂点のポテンシャルは $c^{\pi}_{kl}$ 増加</li></ul></li></ul><img src=images/ポテンシャルの更新.png width=75%><h2 id=9-strongly-feasible-spanning-tree>9. Strongly Feasible Spanning Tree</h2><p>primal network simplex 法が有限回で終了するのかを考えます．<br>アルゴリズムの各イテレーションでは，全域木に辺を追加するこことで閉路を作り，この閉路の flow を更新することで目的関数値を減少させます．<br>目的関数値は flow 1 単位あたり $|c^{\pi}_{ij}|$ 減少するため，常に正の量の flow を流せるならアルゴリズムは有限回で終了します．<br>しかし，節 6 の最後の例のように閉路に restricted arc があると flow が増加できないイテレーションが発生することがあります．このイテレーションを degenerate iteration といいます．<br>実は primal network simplex 法は entring arc と leaving arc を任意に選ぶと degenerate iteration が無限に発生しアルゴリズムが有限回で終了しないことがあります．</p><p>そこで，strongly feasible spanning tree という概念を導入します．<br>常に strongly feasible spanning tree を維持することによって，アルゴリズムが有限回で終了することが保証できます．</p><h3 id=strongly-feasible-spanning-tree>strongly feasible spanning tree</h3><p>次の条件を満たす spanning tree を strongly feasible spanning tree と呼びます．</p><ul><li>任意の頂点から正の量の flow を容量制約に違反することなく木に沿って根に送ることができる</li></ul><p>下の図は strongly feasible spanning tree の例です．<br>すべての頂点から頂点 0 に向かって 1 以上の flow を送ることができます．<br>strongly feasible spanning tree は flow が下限の辺のは根に向いていて，flow が上限の辺は根と反対を向いている全域木とみなすこともできます．</p><img src=images/strongly_feasible_spanning_treeの例.png width=50%><p>下の図は strongly feasible spanning tree ではない例です．<br>辺 (2, 1) の flow は上限容量であるため，頂点 2 から根に flow を送ることはできません．また，辺 (3, 4) の flow は下限容量であるため，頂点 4 から根に flow を送ることはできません．</p><img src=images/strongly_feasible_spanning_treeではない例.png width=50%><p>節 4 の「初期 spanning tree structure の構築」は strongly feasible spanning tree を構築します．次の節で leaving arc をどのように選べば strongly feasible spanning tree を維持できるのか見ていきます．</p><h2 id=10-strongly-feasible-spanning-tree-を保つ-leaving-arc-の選び方>10. Strongly Feasible Spanning Tree を保つ leaving arc の選び方</h2><p>辺 (k, l) を entring arc とします．頂点 k と l の最小共通祖先を頂点 w とします．<br>このとき閉路 $W$ に沿って，頂点 w から開始して最後に見つけた blocking arc を leaving arc とすると，spanning tree は strongly feasible を維持できます．</p><p>具体例をみます．<br>$L$ に属する辺 (k, l) が追加され閉路 $W$ が生成されたとします．閉路の向きは辺 (k, l) と同じ向きです．<br>この閉路には flow を流すことができず，辺 (w, 1) と辺 (p, q) が blocking arc になります．<br>頂点 w から閉路の向きに沿って探索し，最後に見つかる blocking arc は辺 (p, q) であるため，この辺を leaving arc とします．</p><img src=images/strongly_feasible_spanning_treeを維持するようなleaving_arcの選び方.png width=30%><p>strongly feasible spanning tree から上記の方法で leaving arc を選んだとき，strongly feasible spanning tree が維持されることを示します．pivot 操作の直前は strongly feasible spanning tree であるという前提を利用します．</p><p>頂点 w から頂点 q のパスを $W_1$，頂点 p から頂点 w のパスを $W_2$ とします．<br>「$W_1$」，「$W_2$」，「閉路以外の頂点」の 3 つについて，「任意の頂点から正の量の flow を容量制約に違反することなく木に沿って根に送ることができる」という条件を満たすか確認します．</p><ul><li><p>$W_1$ 内の頂点</p><ul><li>直前が non-degenerate pivot<sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup> の場合<ul><li>$\delta \gt 0$ であるため，頂点 w から$W_1$ 内の頂点に flow が送られている．$W_1$ の各頂点からは頂点 w まで $\delta$ の flow を押し戻すことができるため条件を満たす</li></ul></li><li>直前が degenerate pivot<sup id=fnref:6><a href=#fn:6 class=footnote-ref role=doc-noteref>6</a></sup> の場合<ul><li>前提から，pivot の直前では頂点 l から頂点 w のパスで flow を送れていたため，このパス内に blocking arc は存在しない．よって $W_1$ は頂点 w と頂点 k の間にある</li><li>$\delta = 0$ であり，頂点 w から頂点 k のどの辺の flow にも変化はないため条件を満たす</li></ul></li></ul></li><li><p>$W_2$ 内の頂点</p><ul><li>leaving arc の選び方を考えると，$W_2$ 内に blocking arc はないため条件を満たす</li></ul></li><li><p>$W$ 以外の頂点</p><ul><li>頂点 u から根へのパスに閉路 $W$ が含まれないとき<ul><li>前提から，閉路以外の flow に変化はないため，条件を満たす</li></ul></li><li>頂点 u から根へのパスに閉路 $W$ が含まれるとき<ul><li>u から閉路までのパスは，flow に変化がないため条件を満たす．閉路に到達したとき閉路から根まで条件を満たすので全体として条件を満たす</li></ul></li></ul></li></ul><p>以上のことから，leaving arc に $W$ に沿って最後に見つけた blocking arc を選ぶことで，常に strongly feasible spanning tree を維持できることがわかりました．</p><h2 id=11-アルゴリズムが有限回で終了することの証明>11. アルゴリズムが有限回で終了することの証明</h2><p>2 つの non-degenerate pivot の間の連続する degenerate pivot が有限回であることを示します．</p><p>degenerate pivot が発生したとき，ノードのポテンシャルが単調減少することを示します．$n$ を頂点の数，$C$ をコストの絶対値の最大値としたとき，ノードのポテンシャルの下界は $-nC$ であるため連続する degenerate pivot は有限回で終了します．</p><ul><li><p>entring arc (k, l) が $L$ に属していた場合</p><ul><li>辺 (k, l) は $L$ に属し，最適性条件に違反するため，reduced cost は $c^{\pi}_{kl} \lt 0$ です．</li><li>全域木は常に strongly feasible spanning tree を維持していることを考えると，degenerate pivot の場合は頂点 l から頂点 w の間に blocking arc は存在しないため，新しく作成される木は頂点 l に 頂点 k がぶら下がる形になります．</li><li>頂点 k を根とする部分木のポテンシャルは $c^{\pi}_{kl} \lt 0$ 増加するため，ノードのポテンシャルは単調減少します</li></ul></li><li><p>entring arc (k, l) が $U$ に属していた場合</p><ul><li>辺 (k, l) は $U$ に属し，最適性条件に違反するため，reduced cost は $c^{\pi}_{kl} \gt 0$ です．</li><li>新しく作成される木は頂点 k に 頂点 l がぶら下がる形になります．</li><li>頂点 l を根とする部分木のポテンシャルは $c^{\pi}_{kl} \gt 0$ 減少するため，ノードのポテンシャルは単調減少します</li></ul></li></ul><p>以上のことから 2 つの non-degenerate pivot の間の連続する degenerate pivot が有限回であることがわかりました．
non-degenerate pivot は目的関数値を厳密に減少させるため，アルゴリズムは有限回で終了します．</p><h2 id=補足-1-最適-spanning-tree-solution-が必ず存在することについて>補足 1. 最適 spanning tree solution が必ず存在することについて</h2><h3 id=cycle-free-solution>cycle free solution</h3><p>free arc のみからなる閉路を持たないような実行可能解 $x$ を cycle free solution といいます．</p><p>下の図は cycle free solution の例です．辺の上に (流量，コスト) を示し，下限容量は 0，上限容量は無限とします．<br>青色の辺 (0, 1)，(1, 3)，(3, 4) が free arc です．free arc のみからなる閉路がないため cycle free solution です．この解の目的関数値は $(2 \times 0) + (2 \times 1) + (2 \times 0) = 2$ です．</p><img src=images/cycle_free_solutionの例.png width=50%><p>下の図は cycle free solution ではない例です．<br>青色の辺 (0, 1)，(1, 2)，(1, 3)，(2, 4)，(3, 4) が free arc です．free arc のみからなる閉路があるため cycle free solution ではありません．この解の目的関数値は $(2 \times 0) + (1 \times 3) + (1 \times 1) + (1 \times -1) + (1 \times 0) = 3$ です．</p><img src=images/cycle_free_solutionではない例.png width=50%><p>cycle free solution でない解が与えられたとき，閉路の flow を操作することで，目的関数値が大きくならないように cycle free solution にすることができます．<br>この解の場合，時計回りに flow を 1 増加すると，辺 (2, 4)，(1, 2) の flow が 1 減り，辺(1, 3)，(3, 4) の flow が 1 増えます．結果，この解の目的関数値は $(2 \times 0) + (0 \times 3) + (2 \times 1) + (0 \times -1) + (2 \times 0) = 2$ と 1 小さくなり，さらに cycle free solution になりました．</p><img src=images/cycle_free_solutionに変形.png width=50%><p>このように，cycle free でない解は閉路の flow を操作することで目的関数値が大きくならないように cycle free solution にできるため，MCFP に最適解があるとき，常に同じ目的関数値である cycle free solution を持つことがわかります．</p><h3 id=cycle-free-solution-から-spanning-tree-solution-を求める>cycle free solution から spanning tree solution を求める</h3><p>cycle free solution は辺を適切に選ぶことで spanning tree solution を求めるとができます．<br>下の図では，青色の辺(0, 1)，(1, 2)，(1, 3)，(3, 4) を全域木として選んでいます．</p><img src=images/cycle_free_solutionをspanning_tree_solutionに.png width=50%><p>以上のことから，MCFP に最適解があるとき，常に同じ目的関数値である最適 spanning tree solution を持つことがわかりました．</p><h2 id=補足-2-spanning-tree-structure-の最適性条件>補足 2. Spanning Tree Structure の最適性条件</h2><p>spanning tree structure が次の条件を満たすとき，spanning tree structure に対応する spanning tree solution は最適 spanning solution となることを示します．</p>$$
\begin{aligned}
c^{\pi}_{ij} = 0 && \forall (i, j) \in T \\
c^{\pi}_{ij} \ge 0 && \forall (i, j) \in L \\
c^{\pi}_{ij} \le 0 && \forall (i, j) \in U \\
\end{aligned}
$$<p>まず，$\sum_{(i, j) \in A} c_{ij} x_{ij}$ を最小化することは $\sum_{(i, j) \in A} c_{ij}^{\pi} x_{ij}$ を最小化することと等しいことを示します．</p><p>$z(\pi) = \sum_{(i, j) \in A} c_{ij}^{\pi} x_{ij}$ とします．$c_{ij}^{\pi} = c_{ij} - \pi(i) + \pi(j)$ なので，$z(0) = \sum_{(i, j) \in A} c_{ij} x_{ij}$ です．<br>頂点 k のポテンシャルを $0$ から $\pi(k)$ まで増加したとします．<br>$c_{ij}^{\pi} = c_{ij} - \pi(i) + \pi(j)$ なので，reduced cost は頂点 k から流出する flow 1 単位あたり $\pi(k)$ 減少し，頂点 k に流入する flow 1 単位あたり $\pi(k)$ 増加します．よって，全体の reduced cost は $ - \pi(k) \times k$ からの流出量 + $\pi(k) \times k$ への流入量だけ変化します．</p><p>MCFP の制約条件から，各頂点 i の流出量と流入量の関係は $\sum_{j:(i, j) \in A} x_{ij} - \sum_{j:(j,i) \in A} x_{ji} = b_i$ です．<br>よって，頂点 k のポテンシャルを $\pi(k)$ 増加すると，目的関数値は $\pi(k)b(k)$ 減少することになります．<br>すべての頂点に同様のことがいえるので，$z(0) - z(\pi) = \sum_{i \in N} \pi(i)b(i) = \pi b$ となります．<br>$\pi b$ は定数のため，$z(\pi)$ を最小化する flow は $z(0)$ を最小化することがわかりました．</p><p>次に，$x^{\ast}$ を上の最適性条件を満たす (T, L, U) に対応する解としたとき，これが最適解であることを示します．<br>最適性条件を満たすポテンシャルを $\pi$ としたとき，$\sum_{(i, j) \in A} c_{ij}^{\pi} x_{ij}$ の最小化を考えます．<br>$\sum_{(i, j) \in A} c_{ij}^{\pi} x_{ij}$ を最小化することは $\sum_{(i, j) \in L} c_{ij}^{\pi} x_{ij} - \sum_{(i, j) \in U} |c_{ij}^{\pi}| x_{ij}$ を最小化すること等しいです．</p><p>$\forall (i, j) \in L$ に対して $x_{ij} \ge x_{ij}^{\ast} = l_{ij}$ であり，$\forall (i, j) \in U$ に対して $x_{ij} \le x_{ij}^{\ast} = u_{ij}$ であるため，$x^{\ast}$ の目的関数値は $x$ の目的関数値以下となります．<br>以上のことから，最適性条件を満たす spanning tree structure は最適解となることがわかりました．</p><h2 id=参考>参考</h2><ul><li><a class=link href=https://www.amazon.co.jp/dp/1292042702 target=_blank rel=noopener>Network Flows: Pearson New International Edition</a></li><li><a class=link href=https://homes.di.unimi.it/righini/Didattica/OttimizzazioneCombinatoria/MaterialeOC/9b%20-%20NetworkSimplex.pdf target=_blank rel=noopener>The network simplex algorithm</a></li><li><a class=link href=https://coral.ise.lehigh.edu/~ted/teaching/ie411/ target=_blank rel=noopener>IE 411: Graphs and Network Flows (Python)</a></li></ul><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>正確には，実行可能領域に下界が存在するならば最適 spanning tree solution が少なくとも 1 つ存在します．&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>全域木の辺として restricted arc を選ぶこともできます&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>辺 (i, j) に対し頂点 j から頂点 i に flow を流すと，辺 (i, j) の flow を減らすことになります．例えば，辺 (2, 1) に対して頂点 1 から頂点 2 に flow を流すと，辺 (2, 1) の flow は 1 減り，コストは 5 下がります．&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p>辺の lower が 0 でない場合，先に lower 分の flow を流しておきます．&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5><p>$\delta \gt 0$ である pivot&#160;<a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:6><p>$\delta = 0$ である pivot&#160;<a href=#fnref:6 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></section><footer class=article-footer><section class=article-tags><a href=/tags/minimum-cost-flow/>Minimum Cost Flow</a></section></footer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css integrity=sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV crossorigin=anonymous><script src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js integrity=sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8 crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous defer></script><script>window.addEventListener("DOMContentLoaded",()=>{renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],ignoredClasses:["gist"]})})</script></article><section class="section sns_parent"><div class="container sns_section"><div class="sns_button twitter"><a href="http://x.com/intent/tweet?url=https%3a%2f%2fmiti-7.github.io%2fpost%2f%25E6%259C%2580%25E5%25B0%258F%25E8%25B2%25BB%25E7%2594%25A8%25E6%25B5%2581%25E5%2595%258F%25E9%25A1%258C%25E3%2581%25AE-primal-network-simplex-%25E6%25B3%2595%2f&text=%e6%9c%80%e5%b0%8f%e8%b2%bb%e7%94%a8%e6%b5%81%e5%95%8f%e9%a1%8c%e3%81%ae%20Primal%20Network%20Simplex%20%e6%b3%95" target=_blank title=twitter><i class="fab fa-twitter"></i></a></div><div class="sns_button hatena"><a href="http://b.hatena.ne.jp/add?mode=confirm&url=https%3a%2f%2fmiti-7.github.io%2fpost%2f%25E6%259C%2580%25E5%25B0%258F%25E8%25B2%25BB%25E7%2594%25A8%25E6%25B5%2581%25E5%2595%258F%25E9%25A1%258C%25E3%2581%25AE-primal-network-simplex-%25E6%25B3%2595%2f&title=%e6%9c%80%e5%b0%8f%e8%b2%bb%e7%94%a8%e6%b5%81%e5%95%8f%e9%a1%8c%e3%81%ae%20Primal%20Network%20Simplex%20%e6%b3%95" target=_blank title=hatena><i class=hatena-icon></i></i></a></div><div class="sns_button bluesky"><a href="https://bsky.app/intent/compose?text=%E6%9C%80%E5%B0%8F%E8%B2%BB%E7%94%A8%E6%B5%81%E5%95%8F%E9%A1%8C%E3%81%AE+Primal+Network+Simplex+%E6%B3%95+https%3A%2F%2Fmiti-7.github.io%2Fpost%2F%25E6%259C%2580%25E5%25B0%258F%25E8%25B2%25BB%25E7%2594%25A8%25E6%25B5%2581%25E5%2595%258F%25E9%25A1%258C%25E3%2581%25AE-primal-network-simplex-%25E6%25B3%2595%2F" target=_blank title="Share on Bluesky"><i class="fab fa-bluesky"></i></a></div></div></section><aside class=related-content--wrapper><h2 class=section-title>関連するコンテンツ</h2><div class=related-content><div class="flex article-list--tile"><article><a href=/post/minimum-cost-flow-successive-shortest-path/><div class=article-details><h2 class=article-title>最小費用流問題の最短路繰り返し法</h2></div></a></article><article class=has-image><a href=/post/optimum-branchings-edmonds/><div class=article-image><img src=/post/optimum-branchings-edmonds/images/branching%E3%81%AE%E4%BE%8B.b4c49e5afb120ad7bedfb2ab459e2218_hu_8911dc54670ab757.png width=250 height=150 loading=lazy alt="Featured image of post Optimum Branchings と Edmonds のアルゴリズム" data-key=optimum-branchings-edmonds data-hash="md5-tMSeWvsSCte+37KrRZ4iGA=="></div><div class=article-details><h2 class=article-title>Optimum Branchings と Edmonds のアルゴリズム</h2></div></a></article><article><a href=/post/primal-dual-algorithm%E5%8E%B3%E5%AF%86%E8%A7%A3/><div class=article-details><h2 class=article-title>Primal Dual Algorithm(厳密解)</h2></div></a></article><article class=has-image><a href=/post/quadratic-pseudo-boolean-optimization/><div class=article-image><img src=/post/quadratic-pseudo-boolean-optimization/images/general_sample_ab_1.4998d222353165ec59581a5fa08b102f_hu_7879d51069c68570.png width=250 height=150 loading=lazy alt="Featured image of post Quadratic Pseudo-Boolean Optimization" data-hash="md5-SZjSIjUxZexZWBpfoIsQLw=="></div><div class=article-details><h2 class=article-title>Quadratic Pseudo-Boolean Optimization</h2></div></a></article><article><a href=/post/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%95%8F%E9%A1%8C%E3%81%AE%E6%9C%80%E9%81%A9%E6%80%A7%E6%9D%A1%E4%BB%B6%E3%81%A8-reduced-arc-length/><div class=article-details><h2 class=article-title>最短路問題の最適性条件と reduced arc length</h2></div></a></article></div></div></aside><script src=https://giscus.app/client.js data-repo=MitI-7/MitI-7.github.io data-repo-id=R_kgDOMu10ww data-category=Announcements data-category-id=DIC_kwDOMu10w84Cltew data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=light data-lang=en crossorigin=anonymous async></script><script>function setGiscusTheme(e){let t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:{setConfig:{theme:e}}},"https://giscus.app")}(function(){addEventListener("message",t=>{if(event.origin!=="https://giscus.app")return;e()}),window.addEventListener("onColorSchemeChange",e);function e(){setGiscusTheme(document.documentElement.dataset.scheme==="light"?"light":"dark")}})()</script><footer class=site-footer><section class=copyright>&copy;
2024 -
2025 Eating Your Own Cat Food</section><section class=powerby><a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> で構築されています。<br>テーマ <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.27.0>Stack</a></b> は <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a> によって設計されています。</section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>